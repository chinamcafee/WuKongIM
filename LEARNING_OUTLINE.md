# 📚 WuKongIM 深度学习教学大纲

## 🎯 学习目标
通过本课程，你将：
1. 理解 WuKongIM 的完整架构设计
2. 掌握分布式 IM 系统的核心技术
3. 深入理解改进版 Raft 共识算法
4. 学会高性能网络编程（Reactor 模式）
5. 了解 IM 业务的各项功能实现

---

## 📖 第一部分：基础篇（入门阶段）

### 第一章：初识 WuKongIM
**目标**：建立整体认知，理解项目定位

1.1 **项目概览**
   - WuKongIM 是什么？解决什么问题？
   - 核心特性：去中心化、高性能、高可用
   - 技术亮点：改进版 Raft、Reactor 模式、自研存储
   - 应用场景：IM、消息中台、物联网、AI 通信

1.2 **快速体验**
   - 单机模式启动（`main.go:25-50`）
   - 发送第一条消息
   - 查看后台管理系统
   - 理解频道订阅/发布模型

1.3 **项目结构解读**
   - `/cmd` - 命令行入口
   - `/internal` - 内部业务逻辑
   - `/pkg` - 可复用的核心包
   - 代码组织原则与设计理念

---

### 第二章：服务启动流程
**目标**：理解系统如何启动，各组件初始化顺序

2.1 **启动链路追踪**
   - `main.go:48` → `cmd.Execute()`
   - `cmd/root.go:307` → 配置解析
   - `internal/server/server.go:675` → 服务初始化

2.2 **核心组件初始化**
   - 网络引擎（wknet.Engine）
   - 集群服务（cluster.Server）
   - 存储引擎（wkdb.DB）
   - 事件总线（EventBus）
   - API 服务器（apiServer）

2.3 **启动顺序与依赖关系**
   - 为什么要按这个顺序启动？
   - 各组件之间的依赖关系
   - 优雅关闭机制

**实践环节**：
- 添加启动日志，追踪完整启动过程
- 修改配置参数，观察影响

---

## 📖 第二部分：网络层（进阶阶段）

### 第三章：Reactor 网络模型
**目标**：掌握高性能网络编程核心模式

3.1 **Reactor 模式原理**
   - 什么是 Reactor 模式？
   - 为什么不用 goroutine-per-connection？
   - I/O 多路复用：epoll/kqueue

3.2 **WuKongIM 的 Reactor 实现**
   - `pkg/wknet/engine.go:160` - Engine 引擎
   - `pkg/wknet/reactor_main.go:27` - MainReactor
   - `pkg/wknet/reactor_sub.go` - SubReactor 数组

3.3 **连接处理流程**
   ```
   新连接 → MainReactor.Accept()
         → 负载均衡选择 SubReactor
         → SubReactor.Poller 监听读写事件
         → 事件回调处理
   ```

3.4 **性能优化技术**
   - TimingWheel 时间轮算法（超时管理）
   - ConnMatrix 连接矩阵（快速查找）
   - 对象池（减少 GC 压力）
   - 零拷贝技术

**实践环节**：
- 分析单个连接的完整生命周期
- 压测：对比 Reactor vs goroutine-per-conn 性能

---

### 第四章：协议解析与消息处理
**目标**：理解二进制协议设计与解析

4.1 **WuKongIM 二进制协议**
   - 协议格式：包头 + 包体
   - 各类消息包：CONNECT、SEND、ACK 等
   - 为什么不用 JSON？性能对比

4.2 **Frame 解析流程**
   - `pkg/wknet` - 从字节流到 Frame
   - 粘包/半包处理
   - 协议版本兼容

4.3 **WebSocket 支持**
   - WebSocket 握手
   - Frame 封装与解封装
   - JSON 协议支持

**实践环节**：
- 手写一个简单的客户端，发送二进制消息
- 抓包分析协议细节

---

## 📖 第三部分：事件驱动架构

### 第五章：EventBus 事件总线
**目标**：理解事件驱动架构的设计与实现

5.1 **事件驱动架构概述**
   - 为什么使用事件驱动？
   - 与传统请求-响应的区别
   - 解耦与扩展性

5.2 **三大事件池**
   - `internal/eventbus/eventbus.go:59`
   - UserEventPool：用户连接事件
   - ChannelEventPool：频道消息事件
   - PusherEventPool：消息推送事件

5.3 **事件处理链**
   - 事件生成 → 入队 → 路由 → Handler 执行
   - Handler 责任链模式
   - 事件转发（跨节点）

5.4 **核心事件解析**
   - EventConnect：连接建立
   - EventOnSend：消息发送
   - EventChannelDistribute：消息分发
   - EventPushOnline：在线推送

**实践环节**：
- 自定义一个新事件类型
- 追踪一条消息从发送到接收的所有事件

---

### 第六章：消息发送完整链路
**目标**：追踪一条消息的完整生命周期

6.1 **发送链路分层**
   ```
   客户端发送
   → 网络层接收（wknet）
   → 用户事件处理（UserHandler）
   → 频道事件处理（ChannelHandler）
   → 权限校验
   → Webhook 回调
   → Raft 共识写入
   → 存储持久化
   → 消息分发（PusherHandler）
   → 推送给订阅者
   ```

6.2 **源码追踪**
   - `internal/user/handler/event_onsend.go` - 用户层处理
   - `internal/channel/handler/event_onsend.go` - 频道层处理
   - `internal/pusher/handler/base.go:40` - 推送层处理

6.3 **性能关键路径**
   - 零拷贝传输
   - 批量写入优化
   - 异步 ACK 机制

**实践环节**：
- 使用 Debug 追踪完整链路
- 分析每个环节的耗时

---

## 📖 第四部分：存储层

### 第七章：WuKongDB 自研存储引擎
**目标**：理解为 IM 场景优化的存储设计

7.1 **为什么自研存储？**
   - 通用数据库的问题
   - IM 场景的特殊需求
   - PebbleDB 选型（LSM-Tree）

7.2 **存储架构**
   - `pkg/wkdb/wukongdb.go:566` - 核心实现
   - Sharding 分片设计（默认 16 个分片）
   - BatchDB 批量写入优化
   - 多级缓存设计

7.3 **数据模型**
   - 消息数据：`pkg/wkdb/message.go`
   - 频道数据：`pkg/wkdb/channel.go`
   - 会话数据：`pkg/wkdb/conversation.go`
   - 订阅关系：`pkg/wkdb/subscriber.go`

7.4 **索引设计**
   - 消息 ID 索引
   - 频道消息索引
   - 用户会话索引
   - 时间序列优化

**实践环节**：
- 分析单条消息的存储路径
- 查看 PebbleDB 的 SST 文件结构
- 测试分片带来的性能提升

---

### 第八章：缓存设计
**目标**：理解多级缓存如何提升性能

8.1 **缓存层次**
   - ChannelInfoCache：频道信息
   - ConversationCache：最近会话
   - PermissionCache：权限数据
   - DeviceCache：设备信息
   - StreamCache：流式消息

8.2 **缓存策略**
   - LRU 淘汰算法
   - 缓存预热
   - 缓存穿透/击穿防护

8.3 **缓存一致性**
   - 写入时更新缓存
   - 分布式缓存同步
   - 缓存失效策略

**实践环节**：
- 监控缓存命中率
- 压测缓存性能

---

## 📖 第五部分：分布式核心（高级阶段）

### 第九章：分布式架构概览
**目标**：建立分布式系统的整体认知

9.1 **WuKongIM 分布式特性**
   - 去中心化设计
   - 无单点故障
   - 数据互备
   - 自动扩容
   - 故障自动转移

9.2 **三层架构设计**
   ```
   Node 层（ConfigServer）
     └─ 管理：集群节点、槽位分配

   Slot 层（SlotServer）
     └─ 管理：频道配置、用户数据

   Channel 层（ChannelServer）
     └─ 管理：消息日志
   ```

9.3 **槽位机制**
   - 什么是槽位（Slot）？
   - 槽位数量（默认 1024）
   - 槽位分配算法
   - 槽位迁移

9.4 **节点角色**
   - Leader：主节点
   - Follower：从节点
   - Learner：学习者节点
   - Proxy：代理节点

**实践环节**：
- 启动 3 节点集群
- 查看槽位分配情况
- 模拟节点加入/退出

---

### 第十章：Raft 共识算法基础
**目标**：理解 Raft 算法原理（为后续改进版做铺垫）

10.1 **为什么需要共识算法？**
   - 分布式系统的一致性问题
   - CAP 理论
   - Raft vs Paxos

10.2 **Raft 核心概念**
   - Leader Election（领导选举）
   - Log Replication（日志复制）
   - Safety（安全性保证）

10.3 **Raft 状态机**
   - Follower 状态
   - Candidate 状态
   - Leader 状态
   - 状态转换条件

10.4 **Term（任期）机制**
   - 什么是 Term？
   - Term 如何递增？
   - Term 的作用

10.5 **日志复制流程**
   - Leader 接收请求
   - Leader 追加日志
   - Leader 发送 AppendEntries
   - Follower 确认
   - Leader 提交（Commit）
   - 应用到状态机（Apply）

**实践环节**：
- 使用动画工具理解 Raft
- 阅读 Raft 论文关键章节

---

### 第十一章：WuKongIM 的改进版 Raft（重点）
**目标**：理解 WuKongIM 对 Raft 的创新改进

11.1 **传统 Raft 的问题**
   - Leader 推送压力大
   - 慢 Follower 拖累整体
   - Leader 需要跟踪每个 Follower 状态

11.2 **Pull 模式 Raft 设计**
   ```
   传统 Push 模式：
   Leader ─[push logs]→ Follower

   改进 Pull 模式：
   Leader ─[notify]→ Follower
   Follower ─[request logs]→ Leader
   Leader ─[respond logs]→ Follower
   ```

11.3 **源码实现**
   - `pkg/raft/raft/raft.go` - Raft 核心
   - `pkg/raft/raft/node.go` - 节点状态机
   - `pkg/raft/types/types.go:867` - 类型定义

11.4 **关键事件类型**
   - Campaign：发起选举
   - Ping：心跳
   - Propose：提议日志
   - SyncReq/SyncResp：同步请求/响应
   - VoteReq/VoteResp：投票请求/响应

11.5 **Pull 模式优势**
   - Leader CPU 压力降低
   - Follower 自主控制同步速度
   - 更好的网络分区容忍性
   - 慢节点不影响整体

**实践环节**：
- 对比 Push vs Pull 模式性能
- 模拟慢 Follower 场景
- 分析日志同步延迟

---

### 第十二章：多层 Raft 架构（创新点）
**目标**：理解分层共识的设计理念

12.1 **为什么需要多层 Raft？**
   - 单一 Raft 组的扩展性限制
   - 不同数据的不同特性
   - 故障隔离

12.2 **第一层：Node Raft（ConfigServer）**
   - `pkg/cluster/cluster/server.go:426`
   - 管理内容：节点列表、槽位分配
   - Raft 组数量：1 个（全局）
   - 数据量：小
   - 变更频率：低

12.3 **第二层：Slot Raft（SlotServer）**
   - `pkg/cluster/slot/server.go`
   - 管理内容：频道配置、用户数据、会话元数据
   - Raft 组数量：1024 个（每槽位一个）
   - 数据量：中
   - 变更频率：中

12.4 **第三层：Channel Raft（ChannelServer）**
   - `pkg/cluster/channel/server.go`
   - 管理内容：消息日志
   - Raft 组数量：动态创建（每活跃频道一个）
   - 数据量：大
   - 变更频率：高

12.5 **动态 Raft 组管理**
   - 频道活跃时创建 Raft 组
   - 频道空闲时销毁 Raft 组
   - 状态持久化与恢复
   - 内存优化

**实践环节**：
- 观察集群中 Raft 组的创建/销毁
- 分析不同层 Raft 的性能特征
- 计算内存节省效果

---

### 第十三章：集群操作与故障处理
**目标**：理解集群的各种操作场景

13.1 **节点加入集群**
   - Join 请求流程
   - 槽位分配
   - 数据同步
   - 节点就绪

13.2 **节点主动退出**
   - Leave 请求
   - 槽位重新分配
   - 数据迁移
   - 配置更新

13.3 **节点故障检测**
   - 心跳超时
   - 故障判定
   - Leader 选举

13.4 **自动故障转移**
   - Follower 发起选举
   - 新 Leader 当选
   - 客户端自动重连
   - 数据不丢失保证

13.5 **脑裂预防**
   - Quorum 机制
   - Term 递增
   - Pre-Vote 优化

**实践环节**：
- 模拟节点宕机
- 观察故障转移过程
- 验证数据完整性

---

### 第十四章：数据分片与路由
**目标**：理解数据如何分布在集群中

14.1 **槽位哈希算法**
   - ChannelID → Hash → Slot
   - 哈希算法选择
   - 负载均衡

14.2 **数据路由**
   - 客户端如何找到正确的节点？
   - 槽位信息同步
   - 请求转发机制

14.3 **数据复制**
   - 副本数量（Replica）
   - 副本分布策略
   - 数据一致性保证

14.4 **扩容与缩容**
   - 添加新节点
   - 槽位重新分配
   - 数据迁移（零停机）
   - 删除节点

**实践环节**：
- 计算某个频道所在的槽位
- 追踪跨节点请求转发
- 实战：扩容集群

---

## 📖 第六部分：IM 业务功能

### 第十五章：频道模型（Channel）
**目标**：理解 WuKongIM 的核心抽象

15.1 **频道（Channel）概念**
   - 什么是频道？
   - 频道 vs 传统群聊
   - 统一抽象的好处

15.2 **频道类型**
   - Person：单聊（1v1）
   - Group：群聊
   - Community：社区/频道
   - CustomerService：客服
   - Info：系统消息

15.3 **频道操作**
   - 创建频道
   - 订阅/取消订阅
   - 黑名单/白名单
   - 禁言设置

15.4 **频道配置**
   - 保存/获取配置
   - 配置同步
   - 配置版本控制

**实践环节**：
- 创建不同类型的频道
- 测试黑白名单功能

---

### 第十六章：消息系统
**目标**：深入理解消息的全生命周期

16.1 **消息结构**
   - MessageID：消息唯一标识
   - Payload：消息内容
   - MessageSeq：消息序号
   - Timestamp：时间戳

16.2 **消息类型**
   - 普通消息
   - 指令消息
   - 信令消息
   - 流式消息（Stream）

16.3 **消息发送**
   - 发送流程
   - ACK 确认
   - 重试机制
   - 去重处理

16.4 **消息接收**
   - 在线推送
   - 离线存储
   - 消息拉取
   - 已读回执

16.5 **消息存储**
   - 永久存储
   - 消息索引
   - 批量查询优化

16.6 **消息漫游**
   - 跨设备同步
   - 历史消息拉取
   - 增量同步

**实践环节**：
- 追踪消息序号生成
- 测试消息去重
- 实现已读回执

---

### 第十七章：在线状态与多端同步
**目标**：理解用户状态管理

17.1 **在线状态**
   - 连接建立
   - 心跳保持
   - 状态查询
   - 状态推送

17.2 **多设备在线**
   - 设备标识（DeviceID）
   - 同账号多设备
   - 设备踢出策略
   - 设备列表管理

17.3 **消息多端同步**
   - 所有设备接收消息
   - 消息已读状态同步
   - 会话同步

**实践环节**：
- 同一账号多设备登录
- 测试消息同步

---

### 第十八章：最近会话（Conversation）
**目标**：理解会话列表的维护

18.1 **会话概念**
   - 什么是会话？
   - 会话列表的作用

18.2 **会话数据**
   - 最后一条消息
   - 未读数
   - 置顶状态
   - @提醒

18.3 **会话更新**
   - 服务端维护
   - 实时更新
   - 增量同步

18.4 **会话操作**
   - 删除会话
   - 清空未读
   - 置顶/取消置顶

**实践环节**：
- 分析会话更新逻辑
- 优化未读数计算

---

### 第十九章：Webhook 与扩展机制
**目标**：理解如何对接业务系统

19.1 **Webhook 机制**
   - `internal/webhook/webhook.go`
   - Webhook 事件类型
   - 回调时机

19.2 **重要 Webhook**
   - onSend：消息发送前
   - onMessage：消息存储后
   - onChannelCreate：频道创建
   - onConnect：连接建立

19.3 **Datasource**
   - 数据源对接
   - 用户信息查询
   - 频道信息查询

19.4 **Plugin 插件系统**
   - 插件接口
   - 插件注册
   - 插件生命周期

**实践环节**：
- 实现一个 Webhook 服务
- 编写一个简单插件

---

### 第二十章：特色功能
**目标**：学习 WuKongIM 的创新功能

20.1 **流式消息（Stream Message）**
   - 什么是流式消息？
   - 使用场景：AI 对话
   - 实现原理：`pkg/wkcache/`
   - 分片传输与合并

20.2 **指令消息（CMD）**
   - 指令消息 vs 普通消息
   - 不存储、不离线
   - 使用场景：实时信令

20.3 **消息回应（Reaction）**
   - 表情回应
   - 回应统计
   - 实时更新

20.4 **消息搜索**
   - 全文搜索
   - 索引设计
   - 性能优化

**实践环节**：
- 实现 AI 流式对话
- 测试指令消息实时性

---

## 📖 第七部分：监控与运维

### 第二十一章：监控系统
**目标**：理解如何监控集群健康状态

21.1 **Prometheus 集成**
   - 指标采集
   - 指标类型
   - 关键指标

21.2 **关键监控指标**
   - 消息吞吐量
   - 在线连接数
   - Raft 日志复制延迟
   - 存储容量

21.3 **分布式追踪**
   - Trace 系统：`pkg/trace/`
   - 请求链路追踪
   - 性能分析

21.4 **日志系统**
   - 日志级别
   - 日志聚合
   - 日志查询

**实践环节**：
- 配置 Prometheus + Grafana
- 创建监控大盘
- 分析性能瓶颈

---

### 第二十二章：性能优化
**目标**：学习各种性能优化技巧

22.1 **网络层优化**
   - 零拷贝
   - 批量发送
   - 连接复用

22.2 **存储层优化**
   - 批量写入
   - 压缩算法
   - Compaction 调优

22.3 **内存优化**
   - 对象池
   - GC 优化
   - 内存泄漏排查

22.4 **CPU 优化**
   - 热点分析
   - Goroutine 泄漏
   - 锁竞争优化

**实践环节**：
- 使用 pprof 分析性能
- 压测并优化

---

### 第二十三章：故障排查
**目标**：掌握常见问题的排查方法

23.1 **网络问题**
   - 连接断开
   - 消息丢失
   - 延迟高

23.2 **集群问题**
   - 节点无法加入
   - Leader 频繁切换
   - 脑裂

23.3 **存储问题**
   - 磁盘满
   - 写入慢
   - 数据损坏

23.4 **性能问题**
   - CPU 飙高
   - 内存泄漏
   - 协程泄漏

**实践环节**：
- 模拟各种故障场景
- 实战排查与修复

---

## 📖 第八部分：实战项目

### 第二十四章：实战：构建聊天应用
**目标**：基于 WuKongIM 构建完整应用

24.1 **需求分析**
   - 单聊
   - 群聊
   - 文件传输
   - 已读回执

24.2 **架构设计**
   - 客户端设计
   - 业务服务器设计
   - WuKongIM 集成

24.3 **核心功能实现**
   - 用户注册/登录
   - 发送/接收消息
   - 创建群聊
   - 好友管理

24.4 **高级功能**
   - 消息加密
   - 敏感词过滤
   - 消息撤回
   - 红包功能

**实践环节**：
- 完整实现一个聊天应用

---

### 第二十五章：实战：构建客服系统
**目标**：利用 WuKongIM 构建客服场景

25.1 **客服系统特点**
   - 访客分配
   - 会话转接
   - 消息优先级
   - 满意度评价

25.2 **技术实现**
   - 客服频道设计
   - 智能分配算法
   - 排队机制
   - 数据统计

**实践环节**：
- 实现客服系统原型

---

## 📖 第九部分：高级专题

### 第二十六章：源码贡献指南
**目标**：学习如何为 WuKongIM 贡献代码

26.1 **代码规范**
   - Go 编码规范
   - 项目代码风格
   - 注释规范

26.2 **开发流程**
   - Fork & Clone
   - 创建分支
   - 提交 PR
   - Code Review

26.3 **测试要求**
   - 单元测试
   - 集成测试
   - 端到端测试

**实践环节**：
- 修复一个 Issue
- 提交你的第一个 PR

---

### 第二十七章：架构演进与未来
**目标**：思考架构的演进方向

27.1 **当前架构的优势**
   - 去中心化
   - 高性能
   - 可扩展

27.2 **可能的改进方向**
   - 跨地域部署
   - 更大规模集群
   - 更细粒度的分片

27.3 **新兴技术探索**
   - QUIC 协议
   - CRDT 算法
   - AI 集成

---

## 📊 学习建议

### 学习路径
1. **第 1-2 周**：第一部分（基础篇）
2. **第 3-4 周**：第二部分（网络层）
3. **第 5-6 周**：第三部分（事件驱动）
4. **第 7-8 周**：第四部分（存储层）
5. **第 9-12 周**：第五部分（分布式核心）⭐ 重点
6. **第 13-14 周**：第六部分（IM 功能）
7. **第 15-16 周**：第七部分（监控运维）
8. **第 17-20 周**：第八、九部分（实战）

### 学习方法
1. **理论 + 实践**：每章都有实践环节
2. **源码阅读**：精确到文件和行数
3. **动手实验**：搭建环境，实际操作
4. **笔记总结**：记录关键点
5. **讨论交流**：随时提问

### 重点章节（必须掌握）
- ⭐⭐⭐ 第二章：启动流程
- ⭐⭐⭐ 第三章：Reactor 模式
- ⭐⭐⭐ 第十一章：改进版 Raft（核心创新）
- ⭐⭐⭐ 第十二章：多层 Raft（核心创新）
- ⭐⭐⭐ 第十三章：故障处理
- ⭐⭐ 第七章：存储引擎
- ⭐⭐ 第六章：消息链路

---

## 🎓 学习成果
完成本课程后，你将能够：
1. ✅ 独立搭建 WuKongIM 分布式集群
2. ✅ 理解分布式系统的核心技术
3. ✅ 掌握 Raft 共识算法及其改进
4. ✅ 理解高性能网络编程
5. ✅ 能够排查和解决常见问题
6. ✅ 基于 WuKongIM 构建自己的应用
7. ✅ 有能力为项目贡献代码
