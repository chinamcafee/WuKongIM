# 2.2 核心组件初始化

> **学习目标**：深入理解 `Server.New()` 函数的初始化过程，掌握各核心组件的创建顺序、配置方式及其相互依赖关系。

---

## 📊 初始化流程概览

```
cmd/root.go:116 → s := server.New(serverOpts)
    ↓
internal/server/server.go:90 → Server.New()
    ├─ 1. 配置检查
    ├─ 2. 创建三大事件池 ⭐⭐⭐
    ├─ 3. 上下文与监控
    ├─ 4. 网络引擎初始化 ⭐⭐
    ├─ 5. 流式消息缓存
    ├─ 6. 各种管理器 ⭐
    ├─ 7. 集群服务器 ⭐⭐⭐
    ├─ 8. API 服务器
    └─ 9. 插件服务器
    ↓
返回 *Server（所有组件已就绪）
```

---

## 🔍 完整源码解析

**文件位置**：`internal/server/server.go:90-277`

### **函数签名**

```go
func New(opts *options.Options) *Server
```

**参数**：
- `opts *options.Options`：服务器配置选项

**返回值**：
- `*Server`：完全初始化的服务器实例

---

## 1️⃣ 基础设置（Lines 91-106）

### **代码**

```go
func New(opts *options.Options) *Server {
    now := time.Now().UTC()
    options.G = opts  // 设置全局配置

    s := &Server{
        opts:  opts,
        Log:   wklog.NewWKLog("Server"),
        start: now,
    }
    s.ctx, s.cancel = context.WithCancel(context.Background())

    // 配置检查
    err := opts.Check()
    if err != nil {
        panic(err)
    }

    return s
}
```

---

### **详细解析**

#### **A. 全局配置设置**（Line 92）

```go
options.G = opts
```

**作用**：将配置设置为全局变量，方便各模块访问

**设计原因**：
- 避免在每个函数调用时传递配置参数
- 简化代码（但牺牲了一定的可测试性）

**访问方式**：

```go
// 在其他包中访问
import "github.com/WuKongIM/WuKongIM/internal/options"

func someFunction() {
    addr := options.G.Addr  // 直接访问全局配置
}
```

---

#### **B. Server 结构体创建**（Lines 94-98）

```go
s := &Server{
    opts:  opts,
    Log:   wklog.NewWKLog("Server"),
    start: now,
}
```

**初始化的字段**：

| 字段 | 类型 | 作用 |
|------|------|------|
| `opts` | `*options.Options` | 配置选项 |
| `Log` | `wklog.Log` | 日志器（带 "Server" 前缀） |
| `start` | `time.Time` | 启动时间（UTC） |

**为什么用 UTC 时间？**
- 避免时区问题
- 便于分布式环境下的时间对比
- 日志分析时统一时间基准

---

#### **C. 上下文创建**（Line 99）

```go
s.ctx, s.cancel = context.WithCancel(context.Background())
```

**作用**：
- 创建可取消的上下文
- 用于优雅关闭所有子系统

**使用场景**：

```go
// 启动时传递给所有组件
go someComponent.Run(s.ctx)

// 关闭时取消上下文
func (s *Server) Stop() {
    s.cancel()  // 所有监听 ctx.Done() 的 goroutine 都会退出
}
```

---

#### **D. 配置检查**（Lines 102-105）

```go
err := opts.Check()
if err != nil {
    panic(err)
}
```

**检查内容**（`internal/options/options.go:Check()`）：
- 必填字段是否设置
- 配置值是否合法（如端口范围）
- 目录是否存在且可写
- 集群配置一致性

**为什么用 panic？**
- 配置错误是致命问题，无法继续运行
- 在启动阶段快速失败（Fail Fast）
- 避免带着错误配置运行导致更严重的问题

---

## 2️⃣ 三大事件池初始化 ⭐⭐⭐（Lines 108-121）

### **代码**

```go
// 用户事件池
s.userHandler = userhandler.NewHandler()
s.userEventPool = userevent.NewEventPool(s.userHandler)
eventbus.RegisterUser(s.userEventPool)

// 频道事件池
s.channelHandler = channelhandler.NewHandler()
s.channelEventPool = channelevent.NewEventPool(s.channelHandler)
eventbus.RegisterChannel(s.channelEventPool)

// 推送事件池
s.pushHandler = pusherhandler.NewHandler()
s.pushEventPool = pusherevent.NewEventPool(s.pushHandler)
eventbus.RegisterPusher(s.pushEventPool)
```

---

### **详细解析**

#### **A. 事件池的作用**

事件池是 WuKongIM 的**核心设计**，采用**事件驱动架构**：

```
网络事件
    ↓
事件分类
    ├─ 用户事件 → UserEventPool
    ├─ 频道事件 → ChannelEventPool
    └─ 推送事件 → PusherEventPool
    ↓
异步处理
    ↓
业务逻辑执行
```

---

#### **B. 用户事件池**

```go
s.userHandler = userhandler.NewHandler()
s.userEventPool = userevent.NewEventPool(s.userHandler)
eventbus.RegisterUser(s.userEventPool)
```

**职责**：处理用户相关事件

| 事件类型 | 处理文件 | 作用 |
|---------|---------|------|
| `EventConnect` | `internal/user/handler/event_connect.go` | 连接建立 |
| `EventConnack` | `internal/user/handler/event_connack.go` | 连接确认 |
| `EventOnSend` | `internal/user/handler/event_onsend.go` | 用户发送消息 |
| `EventConnWrite` | `internal/user/handler/event_connwrite.go` | 连接写数据 |
| `EventConnClose` | `internal/user/handler/event_connclose.go` | 连接关闭 |

**初始化步骤**：

1. **创建 Handler**：`userhandler.NewHandler()`
   - 包含所有事件处理逻辑
   - 持有对其他组件的引用（通过 `Start()` 注入）

2. **创建事件池**：`userevent.NewEventPool(s.userHandler)`
   - 内部维护事件队列
   - 启动多个 Worker Goroutine 处理事件

3. **注册到事件总线**：`eventbus.RegisterUser(s.userEventPool)`
   - 全局事件总线知道如何分发用户事件

---

#### **C. 频道事件池**

```go
s.channelHandler = channelhandler.NewHandler()
s.channelEventPool = channelevent.NewEventPool(s.channelHandler)
eventbus.RegisterChannel(s.channelEventPool)
```

**职责**：处理频道相关事件

| 事件类型 | 处理文件 | 作用 |
|---------|---------|------|
| `EventOnSend` | `internal/channel/handler/event_onsend.go` | 频道消息发送 |
| `EventDistribute` | `internal/channel/handler/event_distribute.go` | 消息分发 |
| `EventWebhook` | `internal/channel/handler/event_webhook.go` | Webhook 回调 |
| `EventOnStream` | `internal/channel/handler/event_onstream.go` | 流式消息处理 |

**流程示例**：

```
用户发送消息
    ↓
UserEventPool.EventOnSend
    ├─ 基本验证
    └─ 转发到 ChannelEventPool
    ↓
ChannelEventPool.EventOnSend
    ├─ 权限检查
    ├─ Webhook 回调
    ├─ Raft 共识（集群模式）
    └─ 存储持久化
    ↓
ChannelEventPool.EventDistribute
    ├─ 查找订阅者
    └─ 转发到 PusherEventPool
```

---

#### **D. 推送事件池**

```go
s.pushHandler = pusherhandler.NewHandler()
s.pushEventPool = pusherevent.NewEventPool(s.pushHandler)
eventbus.RegisterPusher(s.pushEventPool)
```

**职责**：处理消息推送

| 事件类型 | 处理文件 | 作用 |
|---------|---------|------|
| `EventPushOnline` | `internal/pusher/handler/event_pushonline.go` | 在线推送 |
| `EventPushOffline` | `internal/pusher/handler/event_pushoffline.go` | 离线存储 |

**推送流程**：

```
ChannelEventPool.EventDistribute
    ↓
PusherEventPool.EventPushOnline
    ├─ 检查用户在线状态
    ├─ 在线用户 → 直接推送
    └─ 离线用户 → EventPushOffline
    ↓
存储到离线队列
```

---

#### **E. 为什么先创建事件池？**

**设计原因**：

1. **最核心的组件**
   - 所有业务逻辑都通过事件池处理
   - 其他组件（网络、存储）都依赖事件池

2. **注册到全局事件总线**
   - 后续初始化的组件需要通过事件总线发送事件
   - 必须在其他组件之前完成注册

3. **依赖注入准备**
   - 事件池创建完成后，可以注入给其他组件
   - 如：网络引擎需要事件池来分发网络事件

---

## 3️⃣ 监控与追踪（Lines 123-132）

### **代码**

```go
s.ctx, s.cancel = context.WithCancel(context.Background())

s.trace = trace.New(s.ctx)
err = s.trace.Start()
if err != nil {
    s.Log.Panic("trace start error", zap.Error(err))
}
```

---

### **详细解析**

#### **A. 追踪系统**

**作用**：
- 性能监控
- 调用链追踪
- 统计信息收集

**实现**：`pkg/trace/trace.go`

```go
type Trace struct {
    ctx    context.Context
    cancel context.CancelFunc

    // 统计指标
    MessageCount  atomic.Uint64  // 消息数量
    ConnCount     atomic.Int64   // 连接数量
    LatencySum    atomic.Uint64  // 延迟总和
}

func (t *Trace) Start() error {
    go t.collectLoop()  // 定期收集统计信息
    return nil
}
```

**查看监控数据**：

```bash
# 访问 /varz API
curl http://localhost:5001/varz

# 返回示例
{
  "uptime": "2h30m15s",
  "connections": 1523,
  "messages_in": 152341,
  "messages_out": 152341,
  "avg_latency_ms": 2.3
}
```

---

## 4️⃣ 网络引擎初始化 ⭐⭐（Lines 140-151）

### **代码**

```go
s.engine = wknet.NewEngine(
    wknet.WithAddr(opts.Addr),
    wknet.WithWSAddr(opts.WS.WSAddr),
    wknet.WithWSSAddr(opts.WS.WSSAddr),
    wknet.WithWSTLSConfig(opts.WS.TLSConfig),
    wknet.WithOnConnect(s.onConnect),
    wknet.WithOnClose(s.onClose),
    wknet.WithOnData(s.onData),
)
```

---

### **详细解析**

#### **A. 网络引擎选项**

| 选项 | 作用 | 示例值 |
|------|------|--------|
| `WithAddr` | TCP 监听地址 | `tcp://0.0.0.0:5100` |
| `WithWSAddr` | WebSocket 监听地址 | `ws://0.0.0.0:5200` |
| `WithWSSAddr` | WebSocket TLS 监听地址 | `wss://0.0.0.0:5210` |
| `WithWSTLSConfig` | TLS 配置 | 证书、密钥 |
| `WithOnConnect` | 连接建立回调 | `s.onConnect` |
| `WithOnClose` | 连接关闭回调 | `s.onClose` |
| `WithOnData` | 数据到达回调 | `s.onData` |

---

#### **B. 网络回调函数**

##### **连接建立回调**（`internal/server/server.go:onConnect`）

```go
func (s *Server) onConnect(conn wknet.Conn) error {
    s.Log.Debug("new connection", zap.String("remote", conn.RemoteAddr().String()))

    // 添加事件到用户事件池
    eventbus.User.AddEvent(&eventbus.UserContext{
        EventType: eventbus.EventConnect,
        Conn:      conn,
    })

    return nil
}
```

**流程**：

```
客户端连接
    ↓
wknet.Engine 接受连接
    ↓
调用 s.onConnect(conn)
    ↓
发送 EventConnect 事件
    ↓
UserEventPool 处理
    ↓
event_connect.go → 认证、初始化连接状态
```

---

##### **数据到达回调**（`internal/server/server.go:onData`）

```go
func (s *Server) onData(conn wknet.Conn, data []byte) error {
    // 解析协议帧
    frame, err := protocol.DecodeFrame(data)
    if err != nil {
        return err
    }

    // 根据帧类型分发事件
    switch frame.FrameType {
    case protocol.SEND:
        eventbus.User.AddEvent(&eventbus.UserContext{
            EventType: eventbus.EventOnSend,
            Conn:      conn,
            Frame:     frame,
        })
    case protocol.PING:
        // 直接回复 PONG
        conn.Write(protocol.EncodePong())
    // ... 其他类型
    }

    return nil
}
```

**帧类型**：

| 帧类型 | 值 | 作用 |
|-------|---|------|
| `CONNECT` | 1 | 连接请求 |
| `CONNACK` | 2 | 连接确认 |
| `SEND` | 3 | 发送消息 |
| `SENDACK` | 4 | 发送确认 |
| `RECV` | 5 | 接收消息 |
| `RECVACK` | 6 | 接收确认 |
| `PING` | 7 | 心跳请求 |
| `PONG` | 8 | 心跳响应 |

---

##### **连接关闭回调**（`internal/server/server.go:onClose`）

```go
func (s *Server) onClose(conn wknet.Conn) {
    s.Log.Debug("connection closed", zap.String("remote", conn.RemoteAddr().String()))

    eventbus.User.AddEvent(&eventbus.UserContext{
        EventType: eventbus.EventConnClose,
        Conn:      conn,
    })
}
```

**清理工作**：
- 移除连接映射
- 更新在线状态
- 清理订阅关系
- 触发离线事件

---

#### **C. Reactor 模式回顾**

**架构**：

```
┌─────────────────────────────────────────┐
│           wknet.Engine                  │
├─────────────────────────────────────────┤
│                                         │
│  ┌───────────────────────────────────┐ │
│  │  ReactorMain（主 Reactor）        │ │
│  │  ├─ Accept 新连接                 │ │
│  │  └─ 分发到 SubReactor            │ │
│  └───────────────────────────────────┘ │
│                  ↓                      │
│  ┌───────────────────────────────────┐ │
│  │  ReactorSub[]（子 Reactor 数组）  │ │
│  │  ├─ Epoll/Kqueue 监听 I/O         │ │
│  │  ├─ 读取数据 → onData()           │ │
│  │  └─ 连接关闭 → onClose()          │ │
│  └───────────────────────────────────┘ │
│                                         │
└─────────────────────────────────────────┘
```

**详细学习**：参见第三章《Reactor 网络模型详解》

---

## 5️⃣ 流式消息缓存（Lines 159-193）

### **代码**

```go
s.streamCache = wkcache.NewStreamCache(
    wkcache.WithOnUserStreamDeleted(func(channelID string, channelType uint8, uid string) {
        // 用户流式消息删除回调
    }),
    wkcache.WithOnStreamDeleted(func(channelID string, channelType uint8, streamSeq uint32) {
        // 流式消息删除回调
    }),
)
```

---

### **详细解析**

#### **A. 什么是流式消息？**

**概念**：支持**实时编辑**的消息类型（类似 ChatGPT 打字效果）

**场景**：
- AI 对话（逐字返回）
- 文档协同编辑
- 直播弹幕

**与普通消息的区别**：

| 特性 | 普通消息 | 流式消息 |
|------|---------|---------|
| 发送方式 | 一次性完整发送 | 分多次增量发送 |
| 序列号 | MessageSeq | StreamSeq + StreamNo |
| 存储 | 永久存储 | 临时缓存 |
| 查询 | 历史消息 API | 流式消息 API |

---

#### **B. StreamCache 的作用**

**职责**：
- 缓存正在编辑中的流式消息
- 接收增量更新
- 完成后转为普通消息

**数据结构**（`pkg/wkcache/stream.go`）：

```go
type StreamCache struct {
    // channelID+channelType → streamSeq → StreamItem
    cache map[string]map[uint32]*StreamItem
    mu    sync.RWMutex
}

type StreamItem struct {
    ChannelID   string
    ChannelType uint8
    StreamSeq   uint32    // 流式消息序列号
    StreamNo    uint32    // 当前片段编号
    Content     []byte    // 累积的内容
    UpdateTime  time.Time // 最后更新时间
}
```

---

#### **C. 流式消息完整流程**

```
AI 开始回复
    ↓
发送 STREAM_START（streamSeq=1, streamNo=0）
    ↓
StreamCache.Add(streamSeq=1)
    ↓
发送增量内容（streamNo=1,2,3...）
    ↓
StreamCache.Append(streamSeq=1, content="...")
    ↓
发送 STREAM_END（streamNo=999）
    ↓
StreamCache.Complete(streamSeq=1)
    ├─ 转换为普通消息
    ├─ 存储到 WuKongDB
    └─ 清理缓存
```

---

#### **D. 删除回调**

##### **用户流式消息删除**

```go
wkcache.WithOnUserStreamDeleted(func(channelID string, channelType uint8, uid string) {
    // 通知客户端：某用户的流式消息已被删除
    eventbus.Pusher.AddEvent(&eventbus.PusherContext{
        EventType:   eventbus.EventPushStreamDeleted,
        ChannelID:   channelID,
        ChannelType: channelType,
        UID:         uid,
    })
})
```

##### **流式消息完成删除**

```go
wkcache.WithOnStreamDeleted(func(channelID string, channelType uint8, streamSeq uint32) {
    // 流式消息已完成，清理缓存
    s.Log.Debug("stream deleted",
        zap.String("channelID", channelID),
        zap.Uint8("channelType", channelType),
        zap.Uint32("streamSeq", streamSeq))
})
```

---

## 6️⃣ 管理器初始化 ⭐（Lines 195-206）

### **代码**

```go
// 重试管理器
s.retryManager = manager.NewRetryManager()

// 会话管理器
s.conversationManager = manager.NewConversationManager(10)

// 标签管理器（订阅者）
s.tagManager = manager.NewTagManager(
    16,  // 分片数量
    time.Second*10,  // 超时时间
    func(channelID string, channelType uint8, tagKey string) ([]string, error) {
        // 获取标签订阅者回调
        return s.store.GetSubscribers(channelID, channelType, tagKey)
    },
)

// 连接管理器
s.connManager = manager.NewConnManager()

// 系统账号管理器
s.systemAccountManager = manager.NewSystemAccountManager()
```

---

### **详细解析**

#### **A. 重试管理器**（`internal/manager/manager_retry.go`）

**职责**：管理消息发送失败后的重试队列

**使用场景**：
- 网络波动导致发送失败
- 接收方暂时离线
- Raft 共识失败

**工作原理**：

```go
type RetryManager struct {
    queue  *list.List  // 重试队列
    ticker *time.Ticker
}

func (m *RetryManager) Add(msg *RetryMessage) {
    m.queue.PushBack(msg)
}

func (m *RetryManager) Start() {
    go func() {
        for range m.ticker.C {
            // 遍历队列，重试发送
            for e := m.queue.Front(); e != nil; {
                msg := e.Value.(*RetryMessage)
                if time.Since(msg.LastRetry) > msg.Interval {
                    err := m.retrySend(msg)
                    if err == nil {
                        // 成功，移除
                        next := e.Next()
                        m.queue.Remove(e)
                        e = next
                    } else {
                        msg.RetryCount++
                        msg.LastRetry = time.Now()
                        e = e.Next()
                    }
                } else {
                    e = e.Next()
                }
            }
        }
    }()
}
```

**重试策略**：

| 重试次数 | 间隔时间 | 最大次数 |
|---------|---------|---------|
| 1 | 1 秒 | - |
| 2 | 2 秒 | - |
| 3 | 4 秒 | - |
| 4+ | 10 秒 | 10 次 |

---

#### **B. 会话管理器**（`internal/manager/manager_conversation.go`）

**职责**：管理最近会话列表

**参数**：`10` = 每个用户缓存最多 10 个最近会话

**数据结构**：

```go
type ConversationManager struct {
    // uid → []Conversation（LRU 缓存）
    cache *lru.Cache
}

type Conversation struct {
    ChannelID   string
    ChannelType uint8
    LastMsgSeq  uint64
    UnreadCount int
    UpdateTime  time.Time
}
```

**API 使用**：

```bash
# 获取最近会话
curl -X POST http://localhost:5001/conversation/sync \
  -H "Content-Type: application/json" \
  -d '{
    "uid": "user001",
    "version": 0
  }'

# 返回
{
  "conversations": [
    {
      "channel_id": "user002",
      "channel_type": 1,
      "unread_count": 3,
      "last_msg_seq": 152
    }
  ]
}
```

---

#### **C. 标签管理器**（`internal/manager/manager_tag.go` ⭐⭐）

**职责**：管理订阅者标签（用于消息分发优化）

**参数解析**：

```go
s.tagManager = manager.NewTagManager(
    16,                // shardCount：分片数量（提升并发）
    time.Second*10,    // timeout：获取订阅者超时时间
    func(...) ([]string, error) {  // dataSource：数据源回调
        return s.store.GetSubscribers(channelID, channelType, tagKey)
    },
)
```

---

##### **什么是标签（Tag）？**

**概念**：订阅者的**分组标识**，用于精准推送

**场景示例**：

```
群聊（1000 人）
├─ 在线用户（500 人）     ← tag = "online"
├─ 离线用户（500 人）     ← tag = "offline"
├─ iOS 设备（300 人）     ← tag = "ios"
├─ Android 设备（400 人） ← tag = "android"
└─ Web 设备（300 人）     ← tag = "web"
```

**推送优化**：

```go
// ❌ 低效：遍历所有订阅者
subscribers := store.GetAllSubscribers(channelID)
for _, uid := range subscribers {
    if isOnline(uid) {
        push(uid, message)
    }
}

// ✅ 高效：只获取在线订阅者
onlineUsers := tagManager.GetSubscribers(channelID, "online")
for _, uid := range onlineUsers {
    push(uid, message)
}
```

---

##### **TagManager 工作原理**

**数据结构**：

```go
type TagManager struct {
    shards     []*TagShard  // 分片数组
    dataSource DataSourceFunc
}

type TagShard struct {
    // channelID+channelType+tagKey → []uid
    cache map[string][]string
    mu    sync.RWMutex
}

func (m *TagManager) GetSubscribers(
    channelID string,
    channelType uint8,
    tagKey string,
) ([]string, error) {
    // 1. 计算分片索引
    shardIdx := hash(channelID) % len(m.shards)
    shard := m.shards[shardIdx]

    // 2. 查缓存
    key := makeKey(channelID, channelType, tagKey)
    shard.mu.RLock()
    cached, ok := shard.cache[key]
    shard.mu.RUnlock()

    if ok {
        return cached, nil
    }

    // 3. 缓存未命中，调用数据源
    subscribers, err := m.dataSource(channelID, channelType, tagKey)
    if err != nil {
        return nil, err
    }

    // 4. 写入缓存
    shard.mu.Lock()
    shard.cache[key] = subscribers
    shard.mu.Unlock()

    return subscribers, nil
}
```

**分片优势**：
- 减少锁竞争（16 个分片 = 16 把锁）
- 提升并发性能

---

#### **D. 连接管理器**（`internal/manager/manager_conn.go`）

**职责**：管理 UID 到连接的映射

**数据结构**：

```go
type ConnManager struct {
    // uid → []wknet.Conn（支持多设备）
    conns map[string][]wknet.Conn
    mu    sync.RWMutex
}

func (m *ConnManager) Add(uid string, conn wknet.Conn) {
    m.mu.Lock()
    defer m.mu.Unlock()
    m.conns[uid] = append(m.conns[uid], conn)
}

func (m *ConnManager) Get(uid string) []wknet.Conn {
    m.mu.RLock()
    defer m.mu.RUnlock()
    return m.conns[uid]
}
```

**使用场景**：

```go
// 推送消息给用户
conns := connManager.Get("user001")
for _, conn := range conns {
    conn.Write(encodeMessage(msg))
}
```

---

#### **E. 系统账号管理器**（`internal/manager/manager_systemaccount.go`）

**职责**：管理系统账号（如官方通知账号）

**功能**：
- 系统消息发送（无需权限检查）
- 通知类消息
- 运营消息

**示例**：

```go
// 添加系统账号
systemAccountManager.Add("system_notice")

// 检查是否为系统账号
if systemAccountManager.IsSystemAccount(fromUID) {
    // 跳过权限检查
}
```

---

## 7️⃣ 集群服务器初始化 ⭐⭐⭐（Lines 211-257）

### **代码**

```go
clusterServer := cluster.New(
    cluster.WithNodeID(opts.Cluster.NodeId),
    cluster.WithAddr(opts.Cluster.Addr),
    cluster.WithServerAddr(opts.Cluster.ServerAddr),
    cluster.WithInitNodes(opts.Cluster.InitNodes),
    cluster.WithSeed(opts.Cluster.Seed),
    cluster.WithSlotCount(opts.Cluster.SlotCount),
    cluster.WithSlotMaxReplicaCount(opts.Cluster.SlotMaxReplicaCount),
    cluster.WithChannelMaxReplicaCount(opts.Cluster.ChannelMaxReplicaCount),
    cluster.WithOnSlotApply(s.onSlotApply),
    cluster.WithOnChannelApply(s.onChannelApply),
)
s.clusterServer = clusterServer
```

---

### **详细解析**

#### **A. 集群配置选项**

| 选项 | 作用 | 示例值 |
|------|------|--------|
| `WithNodeID` | 节点 ID（全局唯一） | `1001` |
| `WithAddr` | 集群通信地址 | `tcp://192.168.1.10:11110` |
| `WithServerAddr` | 对外服务地址 | `tcp://192.168.1.10:5100` |
| `WithInitNodes` | 初始节点列表 | `["1001@192.168.1.10:11110", ...]` |
| `WithSeed` | 种子节点 | `1001` |
| `WithSlotCount` | 槽位数量 | `1024` |
| `WithSlotMaxReplicaCount` | 槽位最大副本数 | `3` |
| `WithChannelMaxReplicaCount` | 频道最大副本数 | `3` |

---

#### **B. 集群架构回顾**

**三层 Raft 架构**：

```
┌─────────────────────────────────────────────────┐
│      第一层：Node Raft（ConfigServer）          │
│  管理：节点列表、槽位分配                        │
│  Raft 组数：1 个                                │
├─────────────────────────────────────────────────┤
│  NodeID: 1001, 1002, 1003                      │
│  Slots: [0-341], [342-682], [683-1023]         │
└─────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────┐
│      第二层：Slot Raft（SlotServer）            │
│  管理：频道配置、用户数据、会话                  │
│  Raft 组数：1024 个                             │
├─────────────────────────────────────────────────┤
│  Slot 0    Slot 1    ...    Slot 1023          │
│  (Raft)    (Raft)           (Raft)             │
└─────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────┐
│     第三层：Channel Raft（ChannelServer）       │
│  管理：消息日志                                  │
│  Raft 组数：动态创建（每个活跃频道一个）         │
├─────────────────────────────────────────────────┤
│  Channel A   Channel B   ...                   │
│  (Raft)      (Raft)                            │
└─────────────────────────────────────────────────┘
```

**详细学习**：参见第九章~第十四章《分布式架构》

---

#### **C. Raft 应用回调**

##### **Slot 应用回调**

```go
cluster.WithOnSlotApply(s.onSlotApply)

// 实现：internal/server/server_cluster.go
func (s *Server) onSlotApply(req *cluster.SlotLogReq) (*cluster.SlotLogResp, error) {
    switch req.Type {
    case cluster.SlotLogTypeAddOrUpdateChannel:
        // 添加或更新频道配置
        return s.handleAddOrUpdateChannel(req)

    case cluster.SlotLogTypeAddSubscriber:
        // 添加订阅者
        return s.handleAddSubscriber(req)

    case cluster.SlotLogTypeRemoveSubscriber:
        // 移除订阅者
        return s.handleRemoveSubscriber(req)

    // ... 其他类型
    }
}
```

**作用**：
- Slot Raft 达成共识后，调用此回调应用日志
- 将频道配置、订阅关系写入本地存储

---

##### **Channel 应用回调**

```go
cluster.WithOnChannelApply(s.onChannelApply)

// 实现：internal/server/server_cluster.go
func (s *Server) onChannelApply(req *cluster.ChannelLogReq) (*cluster.ChannelLogResp, error) {
    switch req.Type {
    case cluster.ChannelLogTypeMessage:
        // 消息日志
        return s.handleMessageLog(req)

    // ... 其他类型
    }
}
```

**作用**：
- Channel Raft 达成共识后，调用此回调应用日志
- 将消息写入本地存储

---

#### **D. 集群配置示例**

**三节点集群配置**（`exampleconfig/cluster1.yaml`）：

```yaml
cluster:
  nodeId: 1001
  addr: "tcp://127.0.0.1:11110"
  serverAddr: "tcp://127.0.0.1:5100"
  initNodes:
    - "1001@127.0.0.1:11110"
    - "1002@127.0.0.1:11111"
    - "1003@127.0.0.1:11112"
  seed: 1001
  slotCount: 1024
  slotMaxReplicaCount: 3
  channelMaxReplicaCount: 3
```

**启动集群**：

```bash
# 节点 1
./wukongim --config exampleconfig/cluster1.yaml

# 节点 2
./wukongim --config exampleconfig/cluster2.yaml

# 节点 3
./wukongim --config exampleconfig/cluster3.yaml
```

---

## 8️⃣ API 服务器初始化（Line 265）

### **代码**

```go
s.apiServer = api.New()
```

---

### **详细解析**

#### **A. API 服务器职责**

**作用**：提供 HTTP RESTful API

**实现**：`internal/api/server.go` + `internal/api/server_http.go`

```go
// Server 结构（internal/api/server.go）
type Server struct {
    requset       *request
    client        *ingress.Client
    timingWheel   *timingwheel.TimingWheel
    apiServer     *apiServer     // HTTP API服务器
    managerServer *managerServer // 管理API服务器
    migrateTask   *MigrateTask   // 数据迁移任务
}

func New() *Server {
    s := &Server{
        Log:         wklog.NewWKLog("ApiServer"),
        requset:     newRequset(),
        timingWheel: timingwheel.NewTimingWheel(...),
        client:      ingress.NewClient(),
    }
    s.apiServer = newApiServer(s)        // 创建API服务器
    s.managerServer = newManagerServer(s) // 创建管理服务器
    s.migrateTask = NewMigrateTask(s)     // 创建迁移任务
    return s
}

// 路由注册（internal/api/server_http.go:setRoutes）
func (s *apiServer) setRoutes() {
    // 健康检查
    s.r.GET("/health", ...)

    // 各模块路由注册
    newRoute(s.s).route(s.r)         // 路由模块
    newConnz(s.s).route(s.r)         // 连接监控
    newVarz(s.s).route(s.r)          // 服务器状态
    newUser(s.s).route(s.r)          // 用户模块
    newConnApi(s.s).route(s.r)       // 连接管理
    newChannel(s.s).route(s.r)       // 频道模块
    newMessage(s.s).route(s.r)       // 消息模块 ⭐
    newConversation(s.s).route(s.r)  // 会话模块
    newManager(s.s).route(s.r)       // 管理模块
    newStream(s.s).route(s.r)        // 流式消息
    newEvent(s.s).route(s.r)         // 事件模块
    newTag(s.s).route(s.r)           // 标签模块
    newDocs(s.s).route(s.r)          // API文档(Swagger)
}
```

---

#### **B. 消息模块核心 API**（`internal/api/message.go:route` ⭐）

**注册路由**：

```go
func (m *message) route(r *wkhttp.WKHttp) {
    // 消息发送
    r.POST("/message/send", m.send)           // 发送消息
    r.POST("/message/sendbatch", m.sendBatch) // 批量发送消息

    // 消息同步（将废弃）
    r.POST("/message/sync", m.sync)           // 消息同步(写模式)
    r.POST("/message/syncack", m.syncack)     // 消息同步回执

    // 消息查询
    r.POST("/messages", m.searchMessages)     // 批量查询消息
    r.POST("/message", m.searchMessage)       // 搜索单条消息

    // 频道消息相关（从 channel.go 移动过来）
    r.POST("/channel/messagesync", m.syncMessages)               // 同步频道消息 ⭐
    r.GET("/channel/max_message_seq", m.getChannelMaxMessageSeq) // 获取频道最大消息序号
}
```

---

#### **C. 核心 API 列表**

| 模块 | API | 方法 | 作用 |
|------|-----|------|------|
| **消息** | `/message/send` | POST | 发送消息 ⭐ |
| | `/message/sendbatch` | POST | 批量发送消息 |
| | `/messages` | POST | 批量查询消息 |
| | `/message` | POST | 查询单条消息 |
| **频道消息** | `/channel/messagesync` | POST | 同步频道消息 ⭐⭐ |
| | `/channel/max_message_seq` | GET | 获取频道最大序号 |
| **频道管理** | `/channel` | POST | 创建/更新频道 |
| | `/channel/info` | POST | 更新频道信息 |
| | `/channel/subscriber_add` | POST | 添加订阅者 |
| **会话** | `/conversation/sync` | POST | 同步最近会话 |
| **用户** | `/user/online` | GET | 获取在线用户 |
| **系统** | `/varz` | GET | 服务器状态 ⭐ |
| | `/health` | GET | 健康检查 |

**API 分布说明**：
- 消息API：`internal/api/message.go`
- 频道API：`internal/api/channel.go`
- 会话API：`internal/api/conversation.go`
- 用户API：`internal/api/user.go`
- 系统API：`internal/api/varz.go`

---

#### **D. API 使用示例**

##### **1. 发送消息**（`/message/send`）

```bash
curl -X POST http://127.0.0.1:5001/message/send \
  -H "Content-Type: application/json" \
  -d '{
    "header": {
      "no_persist": 0,
      "red_dot": 1,
      "sync_once": 0
    },
    "from_uid": "user001",
    "channel_id": "user002",
    "channel_type": 1,
    "payload": "SGVsbG8gV3VLb25nSU0h"
  }'

# 返回
{
  "message_id": 123456789,
  "client_msg_no": "uuid-123-0"
}
```

##### **2. 同步频道消息**（`/channel/messagesync` ⭐）

```bash
curl -X POST http://127.0.0.1:5001/channel/messagesync \
  -H "Content-Type: application/json" \
  -d '{
    "login_uid": "user002",
    "channel_id": "user001",
    "channel_type": 1,
    "start_message_seq": 0,
    "pull_mode": 1,
    "limit": 10
  }'

# 返回
{
  "start_message_seq": 0,
  "end_message_seq": 0,
  "more": 0,
  "messages": [
    {
      "message_id": 123456789,
      "message_seq": 1,
      "from_uid": "user001",
      "channel_id": "user002",
      "channel_type": 1,
      "payload": "SGVsbG8gV3VLb25nSU0h",
      "timestamp": 1735689600
    }
  ]
}
```

##### **3. 服务器状态**（`/varz`）

```bash
curl http://127.0.0.1:5001/varz

# 返回
{
  "server_id": "1001",
  "version": "v1.0.0",
  "uptime": "2h15m30s",
  "connections": 1250,
  "in_msgs": 156789,
  "out_msgs": 234567,
  "in_bytes": 15678900,
  "out_bytes": 23456700
}
```

---

## 9️⃣ 插件服务器初始化（Lines 268-275）

### **代码**

```go
s.pluginServer = plugin.NewServer(
    plugin.WithAddr(opts.Plugin.HTTPAddr),
)
```

---

### **详细解析**

#### **A. 插件系统**

**作用**：扩展 WuKongIM 功能

**架构**：

```
┌─────────────────────────────────────────────┐
│          WuKongIM 核心                      │
├─────────────────────────────────────────────┤
│                                             │
│  ┌───────────────────────────────────────┐ │
│  │       Plugin Server                   │ │
│  │  ├─ HTTP API（插件调用）              │ │
│  │  └─ gRPC API（高性能调用）            │ │
│  └───────────────────────────────────────┘ │
│                  ↓                          │
│  ┌───────────────────────────────────────┐ │
│  │         Plugin Manager                │ │
│  │  ├─ 加载插件                          │ │
│  │  ├─ 生命周期管理                      │ │
│  │  └─ 插件间通信                        │ │
│  └───────────────────────────────────────┘ │
│                  ↓                          │
│  ┌───────────────────────────────────────┐ │
│  │         插件实例                       │ │
│  │  ├─ 自定义消息处理                    │ │
│  │  ├─ 自定义存储                        │ │
│  │  └─ 自定义推送                        │ │
│  └───────────────────────────────────────┘ │
│                                             │
└─────────────────────────────────────────────┘
```

---

#### **B. 插件类型**

| 类型 | 作用 | 示例 |
|------|------|------|
| **消息处理插件** | 自定义消息格式、内容审核 | 敏感词过滤 |
| **存储插件** | 自定义存储后端 | MySQL、MongoDB |
| **推送插件** | 自定义推送渠道 | APNs、FCM |
| **认证插件** | 自定义认证逻辑 | OAuth、LDAP |

---

#### **C. 插件示例**

**敏感词过滤插件**：

```go
package main

import (
    "github.com/WuKongIM/WuKongIM/pkg/plugin"
)

type SensitiveWordPlugin struct{}

func (p *SensitiveWordPlugin) OnMessage(msg *plugin.Message) error {
    // 检查敏感词
    if containsSensitiveWord(msg.Content) {
        return errors.New("message contains sensitive word")
    }
    return nil
}

func main() {
    plugin.Register(&SensitiveWordPlugin{})
}
```

---

## 🎯 初始化顺序总结

### **为什么是这个顺序？**

```
1. 配置检查
   ↓ （必须先验证配置）
2. 事件池
   ↓ （核心，其他组件依赖它）
3. 监控追踪
   ↓ （越早启动越好，监控所有组件）
4. 网络引擎
   ↓ （需要事件池来分发网络事件）
5. 流式消息缓存
   ↓ （独立组件，无依赖）
6. 管理器
   ↓ （业务逻辑组件）
7. 集群服务器
   ↓ （依赖存储、网络）
8. API 服务器
   ↓ （依赖所有业务组件）
9. 插件服务器
   ↓ （扩展，最后初始化）
```

---

### **依赖关系图**

```
配置选项 (Options)
    ↓
┌───────────────────────────────────────────┐
│           事件池（EventPool）              │ ← 核心
└───────────────────────────────────────────┘
    ↓                      ↓
网络引擎                管理器
(wknet.Engine)         (Managers)
    ↓                      ↓
集群服务器 ←───────────────┘
(ClusterServer)
    ↓
API 服务器
(APIServer)
    ↓
插件服务器
(PluginServer)
```

---

## 📝 本节要点

✅ `Server.New()` 负责初始化所有核心组件
✅ 初始化顺序：配置 → 事件池 → 网络 → 管理器 → 集群 → API → 插件
✅ 三大事件池是核心设计，所有业务逻辑通过事件驱动
✅ 网络引擎使用 Reactor 模式，通过回调函数与事件池对接
✅ 标签管理器（TagManager）用于优化订阅者查询性能
✅ 集群服务器采用三层 Raft 架构
✅ 组件通过依赖注入实现解耦

---

## 🎯 思考题

1. **为什么事件池必须最先初始化？**
   - 提示：其他组件如何与事件池交互？

2. **TagManager 的分片设计有什么好处？**
   - 提示：锁竞争、并发性能

3. **集群模式下，Slot 和 Channel 应用回调的作用是什么？**
   - 提示：Raft 共识 → 应用日志

---

**下一节预告**：**2.3 启动流程 - Server.Start()** - 深入 `Server.Start()` 函数，看看如何启动所有子系统、注册路由、开始监听端口。🚀
