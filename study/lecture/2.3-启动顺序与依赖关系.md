# 2.3 启动顺序与依赖关系

> **本节目标**：深入理解 WuKongIM 各组件的启动顺序、依赖关系以及优雅关闭机制

---

## 📋 目录
1. [启动顺序概览](#启动顺序概览)
2. [启动流程详解](#启动流程详解)
3. [依赖关系分析](#依赖关系分析)
4. [优雅关闭机制](#优雅关闭机制)
5. [启动优化技巧](#启动优化技巧)

---

## 1️⃣ 启动顺序概览

### **完整启动序列**

> **代码位置**：`internal/server/server.go:287-380`

```
Start() 方法执行顺序：
├─ 1. printEnhancedBanner()           # 打印启动横幅
├─ 2. commonService.Start()           # 通用服务（分布式锁、消息ID生成器等）
├─ 3. StreamCache 自动启动            # 流式消息缓存（无需显式启动）
├─ 4. ingress.SetRoutes()             # 设置内部路由（节点间通信）
├─ 5. retryManager.Start()            # 重试管理器
├─ 6. tagManager.Start()              # 标签管理器
├─ 7. trace.Start()                   # 追踪系统
├─ 8. clusterServer.Start()           # 集群服务器 ⭐⭐⭐
├─ 9. engine 回调注册                  # 网络引擎回调（onConnect、onData、onClose）
├─ 10. engine.Start()                 # 网络引擎启动 ⭐⭐
├─ 11. demoServer.Start()             # Demo服务器（可选）
├─ 12. conversationManager.Start()    # 会话管理器（可选）
├─ 13. webhook.Start()                # Webhook服务
├─ 14. apiServer.Start()              # API服务器 ⭐
├─ 15. userEventPool.Start()          # 用户事件池 ⭐
├─ 16. channelEventPool.Start()       # 频道事件池 ⭐
├─ 17. pushEventPool.Start()          # 推送事件池 ⭐
└─ 18. pluginServer.Start()           # 插件服务器
```

---

## 2️⃣ 启动流程详解

### **A. 通用服务启动**（Line 300）

```go
err = s.commonService.Start()
```

**职责**：
- 分布式消息ID生成器
- 分布式锁服务
- 通用工具服务

**为什么最先启动？**
- 其他组件可能依赖消息ID生成
- 分布式锁是基础设施服务

---

### **B. StreamCache 初始化**（Line 306）

```go
s.Debug("StreamCache initialized and ready")
```

**特点**：
- **自动启动**：在创建时已经启动，无需显式调用 Start()
- **用途**：缓存流式消息（如 AI 对话）
- **实现**：`pkg/wkcache/`

**为什么自动启动？**
- 流式消息需要立即可用
- 避免启动顺序依赖问题

---

### **C. Ingress 路由设置**（Line 308）

```go
s.ingress.SetRoutes()
```

**作用**：注册节点间通信路由

**路由类型**：
```go
// internal/ingress/ingress.go
func (i *Ingress) SetRoutes() {
    i.r.POST("/sync", i.handleSync)           // 同步请求
    i.r.POST("/forward", i.handleForward)     // 转发请求
    i.r.POST("/propose", i.handlePropose)     // Raft提议
    i.r.POST("/apply", i.handleApply)         // Raft应用
    // ... 更多内部路由
}
```

**为什么在集群启动前设置？**
- 集群启动后可能立即产生节点间通信
- 路由必须提前就绪

---

### **D. 管理器启动**（Lines 311-318）

#### **1. 重试管理器**

```go
if err = s.retryManager.Start(); err != nil {
    return err
}
```

**职责**：
- 管理消息发送失败重试队列
- 定时扫描并重新发送失败消息

**启动内容**：
- 启动定时器（Ticker）
- 启动重试工作协程

---

#### **2. 标签管理器**

```go
if err = s.tagManager.Start(); err != nil {
    return err
}
```

**职责**：
- 管理订阅者标签（用于消息分发优化）
- 启动缓存清理定时器

**启动内容**：
- 初始化分片锁
- 启动过期缓存清理任务

---

### **E. 追踪系统启动**（Line 320）

```go
err = s.trace.Start()
```

**职责**：
- 性能追踪
- 指标收集
- Prometheus 暴露

**启动内容**：
- 启动 Prometheus HTTP 服务器
- 初始化指标收集器
- 启动追踪数据刷新协程

---

### **F. 集群服务器启动** ⭐⭐⭐（Line 326）

```go
err = s.clusterServer.Start()
```

**职责**：启动分布式集群核心功能

**启动内容**：
1. **ConfigServer 启动**（Node Raft）
   - 加载集群配置
   - 启动 Node Raft 组
   - 选举或加入集群

2. **SlotServer 启动**（Slot Raft）
   - 创建槽位 Raft 组（1024个）
   - 加载槽位数据
   - 启动槽位管理协程

3. **ChannelServer 启动**（Channel Raft）
   - 准备就绪，等待频道激活
   - 动态创建频道 Raft 组

**为什么在网络引擎启动前？**
- 集群元数据需要先加载
- 节点角色需要先确定
- 避免客户端连接时集群未就绪

---

### **G. 网络引擎启动** ⭐⭐（Lines 331-338）

#### **1. 注册回调函数**（Lines 331-333）

```go
s.engine.OnConnect(s.onConnect)  // 连接建立回调
s.engine.OnData(s.onData)        // 数据到达回调
s.engine.OnClose(s.onClose)      // 连接关闭回调
```

**为什么先注册回调再启动？**
- 启动后可能立即有连接进来
- 回调函数必须提前注册好

---

#### **2. 启动网络引擎**（Line 335）

```go
err = s.engine.Start()
```

**启动内容**：
1. 启动 **MainReactor**（Accept 新连接）
2. 启动 **SubReactor 数组**（处理 I/O 事件）
3. 绑定监听端口（TCP、WebSocket）
4. 启动时间轮定时器（TimingWheel）

**关键日志**：
```
[wknet] MainReactor started
[wknet] SubReactor[0] started
[wknet] SubReactor[1] started
...
[wknet] Listening on tcp://0.0.0.0:5100
[wknet] Listening on ws://0.0.0.0:5200
```

---

### **H. Demo 服务器启动**（Lines 340-342）

```go
if s.opts.Demo.On {
    s.demoServer.Start()
}
```

**职责**：
- 提供演示聊天界面
- 用于快速体验和测试

**默认地址**：`http://localhost:5172/chatdemo`

**可选启动**：通过配置控制

---

### **I. 会话管理器启动**（Lines 344-349）

```go
if s.opts.Conversation.On {
    err = s.conversationManager.Start()
}
```

**职责**：
- 维护用户最近会话列表
- 更新未读数
- 同步会话状态

**启动内容**：
- 启动会话更新协程
- 启动会话缓存清理定时器

**可选启动**：通过配置 `conversation.on` 控制

---

### **J. Webhook 服务启动**（Lines 351-354）

```go
err = s.webhook.Start()
if err != nil {
    s.Panic("webhook start error", zap.Error(err))
}
```

**职责**：
- 回调业务服务器（如消息发送前、发送后）
- 扩展点机制

**启动内容**：
- 启动 HTTP 客户端池
- 启动回调队列处理协程
- 加载 Webhook 配置

**注意**：Webhook 启动失败会导致整个服务 Panic

---

### **K. API 服务器启动**（Line 356）

```go
if err = s.apiServer.Start(); err != nil {
    return err
}
```

**职责**：
- 提供 HTTP RESTful API
- 注册所有模块路由

**启动内容**：
- 启动 HTTP 服务器（默认端口 5001）
- 注册路由（消息、频道、用户等）
- 启动 Swagger 文档服务

**关键日志**：
```
[ApiServer] started, addr=0.0.0.0:5001
```

---

### **L. 事件池启动** ⭐（Lines 360-373）

#### **1. 用户事件池**

```go
err = s.userEventPool.Start()
```

**职责**：处理用户连接相关事件

**启动内容**：
- 启动事件处理协程（Pool Worker）
- 启动事件队列消费者

---

#### **2. 频道事件池**

```go
err = s.channelEventPool.Start()
```

**职责**：处理频道消息相关事件

**启动内容**：
- 启动事件处理协程
- 启动频道队列消费者

---

#### **3. 推送事件池**

```go
err = s.pushEventPool.Start()
```

**职责**：处理消息推送相关事件

**启动内容**：
- 启动推送处理协程
- 启动推送队列消费者

**为什么事件池最后启动？**
- 依赖网络引擎（需要连接已建立）
- 依赖集群服务（需要路由信息）
- 依赖 API 服务（需要 Webhook 回调）

---

### **M. 插件服务器启动**（Lines 375-378）

```go
err = s.pluginServer.Start()
```

**职责**：
- 加载和管理插件
- 提供插件调用接口

**启动内容**：
- 扫描插件目录
- 加载插件配置
- 启动插件生命周期管理

**为什么最后启动？**
- 插件可能依赖所有服务已就绪
- 插件是扩展功能，不影响核心启动

---

## 3️⃣ 依赖关系分析

### **依赖层次图**

```
┌─────────────────────────────────────────────────┐
│  Layer 5: 扩展层                                 │
│  ├─ pluginServer                                │
│  └─ demoServer                                  │
└─────────────────────────────────────────────────┘
                      ↑ 依赖
┌─────────────────────────────────────────────────┐
│  Layer 4: 事件处理层                             │
│  ├─ userEventPool                               │
│  ├─ channelEventPool                            │
│  └─ pushEventPool                               │
└─────────────────────────────────────────────────┘
                      ↑ 依赖
┌─────────────────────────────────────────────────┐
│  Layer 3: 服务层                                 │
│  ├─ apiServer                                   │
│  ├─ webhook                                     │
│  └─ conversationManager                         │
└─────────────────────────────────────────────────┘
                      ↑ 依赖
┌─────────────────────────────────────────────────┐
│  Layer 2: 核心层                                 │
│  ├─ engine（网络引擎）                           │
│  └─ clusterServer（集群服务）                    │
└─────────────────────────────────────────────────┘
                      ↑ 依赖
┌─────────────────────────────────────────────────┐
│  Layer 1: 基础设施层                             │
│  ├─ commonService                               │
│  ├─ retryManager                                │
│  ├─ tagManager                                  │
│  ├─ trace                                       │
│  └─ ingress（内部路由）                          │
└─────────────────────────────────────────────────┘
```

---

### **关键依赖关系**

| 组件 | 依赖的组件 | 依赖原因 |
|------|----------|---------|
| **engine** | clusterServer | 需要知道节点角色和路由信息 |
| **apiServer** | engine, clusterServer | API需要查询集群状态、转发请求 |
| **userEventPool** | engine, clusterServer | 处理连接事件需要网络和集群信息 |
| **channelEventPool** | clusterServer, webhook | 消息处理需要集群共识和业务回调 |
| **pushEventPool** | engine, channelEventPool | 推送依赖连接管理和消息处理 |
| **webhook** | 无 | 独立的回调服务 |
| **pluginServer** | 所有服务 | 插件可能访问任何服务 |

---

### **启动顺序的必要性分析**

#### **为什么 clusterServer 要在 engine 之前？**

```
场景：客户端连接进来
├─ engine.onConnect() 触发
├─ 查询用户所在节点（需要集群路由信息）
└─ 如果集群未就绪 → 连接失败 ❌
```

**结论**：集群必须先启动，网络引擎才能正确路由请求

---

#### **为什么事件池最后启动？**

```
场景：消息发送
├─ userEventPool 接收 EventOnSend
├─ 需要调用 Webhook → webhook 必须已启动
├─ 需要 Raft 共识 → clusterServer 必须已启动
├─ 需要推送消息 → engine 必须已启动
└─ 所有依赖都就绪，才能正常处理
```

**结论**：事件池依赖几乎所有服务，必须最后启动

---

## 4️⃣ 优雅关闭机制

### **A. 停止顺序**（`server.go:390-436`）

```go
func (s *Server) Stop() error {
    // 1. 取消上下文（通知所有协程退出）
    s.cancel()

    // 2. 停止扩展层
    s.pluginServer.Stop()

    // 3. 停止事件处理层
    s.userEventPool.Stop()
    s.channelEventPool.Stop()
    s.pushEventPool.Stop()

    // 4. 停止服务层
    s.apiServer.Stop()
    s.retryManager.Stop()
    s.commonService.Stop()

    // 5. 关闭缓存
    if s.streamCache != nil {
        s.streamCache.Close()
    }

    // 6. 停止会话管理
    if s.opts.Conversation.On {
        s.conversationManager.Stop()
    }

    // 7. 停止集群服务
    s.clusterServer.Stop()

    // 8. 停止Demo服务
    if s.opts.Demo.On {
        s.demoServer.Stop()
    }

    // 9. 停止网络引擎
    err := s.engine.Stop()

    // 10. 停止追踪系统
    s.trace.Stop()

    // 11. 停止标签管理
    s.tagManager.Stop()

    // 12. 停止Webhook
    s.webhook.Stop()

    s.Info("Server is stopped")
    return nil
}
```

---

### **B. 停止顺序原则**

**原则**：**与启动顺序相反**

```
启动：基础设施 → 核心层 → 服务层 → 事件处理层 → 扩展层
停止：扩展层 → 事件处理层 → 服务层 → 核心层 → 基础设施
```

**为什么倒序停止？**

1. **先停止消费者，再停止生产者**
   - 先停止事件池（消费者）
   - 再停止网络引擎（生产者）
   - 避免新事件产生但无法处理

2. **先停止外部服务，再停止内部服务**
   - 先停止 API 服务器（拒绝新请求）
   - 再停止内部业务逻辑
   - 避免请求进来但无法处理

3. **先停止业务逻辑，再停止基础设施**
   - 先停止业务处理
   - 最后停止集群、存储等基础设施
   - 确保业务数据安全落盘

---

### **C. 优雅关闭示例：网络引擎**

```go
// pkg/wknet/engine.go
func (e *Engine) Stop() error {
    e.Info("Stopping engine...")

    // 1. 停止接受新连接
    e.mainReactor.Stop()

    // 2. 等待现有连接处理完成
    e.waitExistingConnections()

    // 3. 停止所有 SubReactor
    for _, sub := range e.subReactors {
        sub.Stop()
    }

    // 4. 关闭所有连接
    e.closeAllConnections()

    // 5. 停止时间轮
    e.timingWheel.Stop()

    e.Info("Engine stopped")
    return nil
}
```

**关键点**：
- 先拒绝新连接
- 等待现有连接优雅关闭
- 最后清理资源

---

### **D. Context 取消机制**

```go
// 创建可取消的上下文
s.ctx, s.cancel = context.WithCancel(context.Background())

// 各组件监听取消信号
func (w *Worker) Run(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
            // 收到取消信号，退出
            return
        case event := <-w.queue:
            // 处理事件
            w.handle(event)
        }
    }
}

// 停止时调用 cancel()
s.cancel()  // 通知所有协程退出
```

**优点**：
- 统一的退出信号
- 协程可以感知停止请求
- 避免暴力杀死协程

---

## 5️⃣ 启动优化技巧

### **A. 并行启动优化**

**当前实现**（串行）：
```go
err = s.userEventPool.Start()    // 等待完成
err = s.channelEventPool.Start() // 等待完成
err = s.pushEventPool.Start()    // 等待完成
```

**优化方案**（并行）：
```go
var wg sync.WaitGroup
errChan := make(chan error, 3)

// 并行启动三个事件池
wg.Add(3)
go func() {
    defer wg.Done()
    if err := s.userEventPool.Start(); err != nil {
        errChan <- err
    }
}()
go func() {
    defer wg.Done()
    if err := s.channelEventPool.Start(); err != nil {
        errChan <- err
    }
}()
go func() {
    defer wg.Done()
    if err := s.pushEventPool.Start(); err != nil {
        errChan <- err
    }
}()

wg.Wait()
close(errChan)

// 检查错误
for err := range errChan {
    if err != nil {
        return err
    }
}
```

**收益**：
- 启动时间缩短 30%-50%
- 适用于无依赖关系的组件

---

### **B. 延迟加载优化**

**场景**：某些组件可能不会立即使用

**示例**：
```go
// ❌ 立即启动所有插件
for _, plugin := range s.plugins {
    plugin.Start()  // 可能很慢
}

// ✅ 延迟加载
for _, plugin := range s.plugins {
    go plugin.LazyStart()  // 后台异步启动
}
```

---

### **C. 健康检查优化**

**启动健康检查**：
```go
func (s *Server) WaitReady(timeout time.Duration) error {
    ctx, cancel := context.WithTimeout(context.Background(), timeout)
    defer cancel()

    ticker := time.NewTicker(100 * time.Millisecond)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            return errors.New("startup timeout")
        case <-ticker.C:
            if s.isReady() {
                return nil
            }
        }
    }
}

func (s *Server) isReady() bool {
    return s.engine.IsRunning() &&
           s.clusterServer.IsReady() &&
           s.apiServer.IsRunning()
}
```

**用途**：
- 等待所有组件就绪后再对外服务
- 避免半启动状态接受请求

---

### **D. 启动超时机制**

```go
func (s *Server) StartWithTimeout(timeout time.Duration) error {
    done := make(chan error, 1)

    go func() {
        done <- s.Start()
    }()

    select {
    case err := <-done:
        return err
    case <-time.After(timeout):
        return fmt.Errorf("startup timeout after %v", timeout)
    }
}
```

**用途**：
- 防止某个组件卡住导致整体无法启动
- 快速失败，便于排查问题

---

## 6️⃣ 启动失败处理

### **A. 错误传播**

```go
func (s *Server) Start() error {
    // 每一步都检查错误
    if err := s.commonService.Start(); err != nil {
        return fmt.Errorf("commonService start failed: %w", err)
    }

    if err := s.clusterServer.Start(); err != nil {
        return fmt.Errorf("clusterServer start failed: %w", err)
    }

    // ... 其他组件
}
```

**优点**：
- 明确知道哪个组件启动失败
- 便于日志排查

---

### **B. 回滚机制**

```go
func (s *Server) Start() error {
    started := []string{}

    defer func() {
        if r := recover(); r != nil {
            // 启动失败，回滚已启动的组件
            s.rollback(started)
        }
    }()

    if err := s.commonService.Start(); err != nil {
        return err
    }
    started = append(started, "commonService")

    if err := s.clusterServer.Start(); err != nil {
        s.rollback(started)  // 回滚已启动的组件
        return err
    }
    started = append(started, "clusterServer")

    // ... 其他组件
}

func (s *Server) rollback(started []string) {
    for i := len(started) - 1; i >= 0; i-- {
        switch started[i] {
        case "commonService":
            s.commonService.Stop()
        case "clusterServer":
            s.clusterServer.Stop()
        // ... 其他组件
        }
    }
}
```

**用途**：
- 启动失败时清理已启动的组件
- 避免资源泄漏

---

### **C. 重试机制**

```go
func (s *Server) StartWithRetry(maxRetries int) error {
    for i := 0; i < maxRetries; i++ {
        err := s.Start()
        if err == nil {
            return nil
        }

        s.Warn("Start failed, retrying...",
            zap.Int("attempt", i+1),
            zap.Error(err))

        time.Sleep(time.Second * time.Duration(i+1))
    }
    return fmt.Errorf("start failed after %d retries", maxRetries)
}
```

**适用场景**：
- 临时性网络问题
- 依赖服务未就绪

---

## 7️⃣ 启动性能分析

### **启动耗时统计**

```go
func (s *Server) Start() error {
    startTime := time.Now()

    // 各组件启动耗时统计
    componentTimes := make(map[string]time.Duration)

    t := time.Now()
    s.commonService.Start()
    componentTimes["commonService"] = time.Since(t)

    t = time.Now()
    s.clusterServer.Start()
    componentTimes["clusterServer"] = time.Since(t)

    // ... 其他组件

    // 打印耗时统计
    s.printStartupStats(componentTimes, time.Since(startTime))
}

func (s *Server) printStartupStats(times map[string]time.Duration, total time.Duration) {
    s.Info("=== Startup Time Statistics ===")
    for name, duration := range times {
        percentage := float64(duration) / float64(total) * 100
        s.Info(fmt.Sprintf("  %s: %v (%.1f%%)", name, duration, percentage))
    }
    s.Info(fmt.Sprintf("Total: %v", total))
}
```

**输出示例**：
```
=== Startup Time Statistics ===
  commonService: 50ms (2.5%)
  clusterServer: 800ms (40.0%)
  engine: 100ms (5.0%)
  apiServer: 150ms (7.5%)
  userEventPool: 300ms (15.0%)
  ...
Total: 2s
```

**用途**：
- 识别启动瓶颈
- 指导优化方向

---

## 8️⃣ 实战练习

### **练习1：添加启动日志**

**目标**：在每个组件启动前后添加日志

```go
func (s *Server) Start() error {
    s.Info("Starting commonService...")
    if err := s.commonService.Start(); err != nil {
        return err
    }
    s.Info("✓ commonService started")

    s.Info("Starting clusterServer...")
    if err := s.clusterServer.Start(); err != nil {
        return err
    }
    s.Info("✓ clusterServer started")

    // ... 其他组件
}
```

**验证**：观察启动日志，理解启动流程

---

### **练习2：模拟启动失败**

**目标**：理解错误处理和回滚机制

```go
// 修改配置，使某个组件启动失败
config.yaml:
  cluster:
    addr: "invalid-address"  # 无效地址

# 观察日志
clusterServer start failed: listen tcp: address invalid-address: ...
```

**验证**：
- 查看错误日志
- 确认其他组件是否正确回滚

---

### **练习3：优化启动性能**

**目标**：并行启动无依赖关系的组件

**步骤**：
1. 识别无依赖关系的组件
2. 修改为并行启动
3. 对比启动时间

**验证**：
- 记录优化前后的启动时间
- 计算性能提升百分比

---

## 9️⃣ 总结

### **核心要点**

1. **启动顺序**
   - 基础设施 → 核心层 → 服务层 → 事件处理层 → 扩展层
   - 遵循依赖关系，由底向上启动

2. **停止顺序**
   - 与启动顺序相反
   - 先停止消费者，再停止生产者
   - 确保优雅关闭，避免数据丢失

3. **关键依赖**
   - clusterServer 必须在 engine 之前启动
   - 事件池必须在所有依赖服务之后启动
   - Webhook 启动失败会导致 Panic

4. **优化方向**
   - 并行启动无依赖组件
   - 延迟加载非核心功能
   - 添加健康检查和超时机制

---

### **下一节预告**

**第三章：Reactor 网络模型**
- Reactor 模式原理
- MainReactor 与 SubReactor
- 连接处理流程
- 性能优化技术

---

> **🔗 相关代码**：
> - 启动流程：`internal/server/server.go:287-380`
> - 停止流程：`internal/server/server.go:390-436`
> - 依赖关系：各组件的 `Start()` 和 `Stop()` 方法
