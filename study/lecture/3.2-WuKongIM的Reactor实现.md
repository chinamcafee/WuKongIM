# 3.2 WuKongIM 的 Reactor 实现

> **本节目标**：深入理解WuKongIM基于wknet库的Reactor实现，掌握Engine、MainReactor、SubReactor的设计与交互

---

## 📋 目录
1. [架构总览](#架构总览)
2. [Engine引擎设计](#engine引擎设计)
3. [MainReactor实现](#mainreactor实现)
4. [SubReactor实现](#subreactor实现)
5. [连接管理](#连接管理)
6. [事件处理流程](#事件处理流程)

---

## 1️⃣ 架构总览

### **A. WuKongIM的Reactor架构**

```
┌─────────────────────────────────────────────────────────┐
│                      Engine 引擎                         │
│  ├─ connMatrix (连接矩阵)                                │
│  ├─ eventHandler (事件处理器)                            │
│  ├─ timingWheel (时间轮)                                │
│  └─ reactorMain (主Reactor)                             │
└─────────────────────────────────────────────────────────┘
                          │
                          ↓
┌─────────────────────────────────────────────────────────┐
│                   ReactorMain (主Reactor)                │
│  └─ acceptor (接受器)                                    │
│      ├─ listenPoller (TCP监听)                           │
│      ├─ listenWSPoller (WebSocket监听)                   │
│      ├─ listenWSSPoller (WebSocket SSL监听)              │
│      └─ reactorSubs[] (SubReactor数组)                  │
└─────────────────────────────────────────────────────────┘
                          │
          ┌───────────────┼───────────────┬───────────┐
          ↓               ↓               ↓           ↓
┌──────────────┐  ┌──────────────┐  ┌──────────────┐ ...
│ ReactorSub-0 │  │ ReactorSub-1 │  │ ReactorSub-2 │
│ ├─ poller    │  │ ├─ poller    │  │ ├─ poller    │
│ ├─ connCount │  │ ├─ connCount │  │ ├─ connCount │
│ └─ conns[]   │  │ └─ conns[]   │  │ └─ conns[]   │
└──────────────┘  └──────────────┘  └──────────────┘
```

---

### **B. 核心组件职责**

| 组件 | 职责 | 文件位置 |
|------|------|---------|
| **Engine** | 总控引擎，管理所有Reactor和连接 | `pkg/wknet/engine.go:13-22` |
| **ReactorMain** | 主Reactor，负责接受新连接 | `pkg/wknet/reactor_main.go:5-18` |
| **Acceptor** | 连接接受器，包含监听和分发逻辑 | `pkg/wknet/acceptor.go:21-34` |
| **ReactorSub** | 子Reactor，负责I/O事件处理 | `pkg/wknet/reactor_sub.go:19-29` |
| **connMatrix** | 连接矩阵，快速查找连接 | `pkg/wknet/conn.go:872-875` |
| **Poller** | I/O多路复用封装（epoll/kqueue） | `pkg/wknet/netpoll/epoll_default_poller.go:21-27` |

---

## 2️⃣ Engine 引擎设计

### **A. Engine结构定义**

**代码位置**：`pkg/wknet/engine.go:13-22`

```go
type Engine struct {
    connMatrix      *connMatrix              // 在线连接矩阵 ⭐
    connsUnixLock   deadlock.RWMutex         // 连接锁
    options         *Options                 // 配置选项
    eventHandler    *EventHandler            // 事件处理器
    reactorMain     *ReactorMain             // 主Reactor
    timingWheel     *timingwheel.TimingWheel // 时间轮（延迟任务）
    defaultConnPool *sync.Pool               // 连接对象池
    clientIDGen     atomic.Int64             // 客户端ID生成器
}
```

---

### **B. Engine初始化**

**代码位置**：`pkg/wknet/engine.go:24-47`

```go
func NewEngine(opts ...Option) *Engine {
    // 1. 创建默认配置
    options := NewOptions()
    for _, opt := range opts {
        opt(options)  // 应用用户配置
    }

    // 2. 创建Engine实例
    eg := &Engine{
        connMatrix:   newConnMatrix(),        // 连接矩阵
        options:      options,
        eventHandler: NewEventHandler(),      // 事件处理器
        timingWheel:  timingwheel.NewTimingWheel(
            time.Millisecond*10,  // tick间隔：10ms
            1000,                 // 时间轮槽位数：1000
        ),
        defaultConnPool: &sync.Pool{         // 连接对象池
            New: func() any {
                return &DefaultConn{}
            },
        },
    }

    // 3. 创建主Reactor
    eg.reactorMain = NewReactorMain(eg)

    return eg
}
```

---

### **C. 默认配置**

**代码位置**：`pkg/wknet/options.go:46-55`

```go
func NewOptions() *Options {
    return &Options{
        Addr:               "tcp://127.0.0.1:5100",
        MaxOpenFiles:       GetMaxOpenFiles(),     // 系统最大文件数
        SubReactorNum:      runtime.NumCPU(),      // SubReactor数量 = CPU核心数 ⭐
        ReadBufferSize:     1024 * 32,             // 32KB
        MaxWriteBufferSize: 1024 * 1024 * 50,      // 50MB
        MaxReadBufferSize:  1024 * 1024 * 50,      // 50MB
    }
}
```

**为什么SubReactor数量等于CPU核心数？**
```
原因：
1. 充分利用多核CPU
2. 避免线程过多导致调度开销
3. 每个SubReactor独占一个CPU核心，无竞争

示例：
├─ 16核CPU → 16个SubReactor
├─ 每个SubReactor处理约6万连接（100万/16）
└─ 每个SubReactor绑定一个CPU核心，性能最优
```

---

### **D. Engine启动**

**代码位置**：`pkg/wknet/engine.go:49-52`

```go
func (e *Engine) Start() error {
    // 1. 启动时间轮
    e.timingWheel.Start()

    // 2. 启动主Reactor
    return e.reactorMain.Start()
}
```

**启动顺序**：
```
1. 时间轮启动（处理超时任务）
2. 主Reactor启动
   ├─ 创建并启动所有SubReactor
   ├─ 初始化TCP监听
   ├─ 初始化WebSocket监听
   └─ 开始接受连接
```

---

### **E. 连接管理方法**

```go
// 添加连接到连接矩阵
func (e *Engine) AddConn(conn Conn) {
    e.connsUnixLock.Lock()
    e.connMatrix.addConn(conn)
    e.connsUnixLock.Unlock()
}

// 移除连接
func (e *Engine) RemoveConn(conn Conn) {
    e.connsUnixLock.Lock()
    e.connMatrix.delConn(conn)
    e.connsUnixLock.Unlock()
}

// 根据fd查找连接（O(1)复杂度）
func (e *Engine) GetConn(fd int) Conn {
    e.connsUnixLock.RLock()
    defer e.connsUnixLock.RUnlock()
    return e.connMatrix.getConn(fd)
}

// 获取所有连接
func (e *Engine) GetAllConn() []Conn {
    e.connsUnixLock.RLock()
    defer e.connsUnixLock.RUnlock()
    conns := make([]Conn, 0, e.connMatrix.loadCount())
    e.connMatrix.iterate(func(conn Conn) bool {
        conns = append(conns, conn)
        return true
    })
    return conns
}
```

---

### **F. 事件回调注册**

**代码位置**：`pkg/wknet/engine.go:120-141`

```go
// 连接建立回调
func (e *Engine) OnConnect(onConnect OnConnect) {
    e.eventHandler.OnConnect = onConnect
}

// 数据到达回调
func (e *Engine) OnData(onData OnData) {
    e.eventHandler.OnData = onData
}

// 连接关闭回调
func (e *Engine) OnClose(onClose OnClose) {
    e.eventHandler.OnClose = onClose
}
```

**使用示例**（WuKongIM）：
```go
// internal/server/server.go:331-333
s.engine.OnConnect(s.onConnect)
s.engine.OnData(s.onData)
s.engine.OnClose(s.onClose)
```

---

## 3️⃣ MainReactor 实现

### **A. ReactorMain结构**

**代码位置**：`pkg/wknet/reactor_main.go:5-18`

```go
type ReactorMain struct {
    acceptor *acceptor        // 连接接受器
    eg       *Engine          // Engine引用
    wklog.Log                 // 日志
}

func NewReactorMain(eg *Engine) *ReactorMain {
    return &ReactorMain{
        acceptor: newAcceptor(eg),
        eg:       eg,
        Log:      wklog.NewWKLog("ReactorMain"),
    }
}
```

**职责**：
- 启动Acceptor
- 管理连接接受流程
- 不直接处理I/O，而是分发给SubReactor

---

### **B. Acceptor结构**

**代码位置**：`pkg/wknet/acceptor.go:21-34`

```go
type acceptor struct {
    reactorSubs       []*ReactorSub      // SubReactor数组 ⭐
    eg                *Engine            // Engine引用
    listenPoller      *netpoll.Poller    // TCP监听Poller
    listenWSPoller    *netpoll.Poller    // WebSocket监听Poller
    listenWSSPoller   *netpoll.Poller    // WebSocket SSL监听Poller
    listen            *listener          // TCP监听器
    listenWS          *listener          // WebSocket监听器
    listenWSS         *listener          // WebSocket SSL监听器
    tcpRealListenAddr net.Addr           // TCP真实监听地址
    wsRealListenAddr  net.Addr           // WebSocket真实监听地址
    wklog.Log
}
```

---

### **C. Acceptor初始化**

**代码位置**：`pkg/wknet/acceptor.go:36-51`

```go
func newAcceptor(eg *Engine) *acceptor {
    // 1. 创建SubReactor数组
    reactorSubs := make([]*ReactorSub, eg.options.SubReactorNum)
    for i := 0; i < eg.options.SubReactorNum; i++ {
        reactorSubs[i] = NewReactorSub(eg, i)
    }

    // 2. 创建Acceptor实例
    a := &acceptor{
        eg:              eg,
        reactorSubs:     reactorSubs,
        listenPoller:    netpoll.NewPoller(0, "listenerPoller"),     // TCP监听
        listenWSPoller:  netpoll.NewPoller(0, "listenWSPoller"),     // WS监听
        listenWSSPoller: netpoll.NewPoller(0, "listenWSSPoller"),    // WSS监听
        Log:             wklog.NewWKLog("Acceptor"),
    }

    return a
}
```

**为什么需要三个Poller？**
```
原因：
1. TCP、WebSocket、WebSocket SSL 是不同的监听socket
2. 每个监听socket需要独立的epoll实例
3. 并行监听，提高接受连接的效率

架构：
listenPoller      → 监听 tcp://0.0.0.0:5100
listenWSPoller    → 监听 ws://0.0.0.0:5200
listenWSSPoller   → 监听 wss://0.0.0.0:5300
```

---

### **D. Acceptor启动流程**

**代码位置**：`pkg/wknet/acceptor.go:58-98`

```go
func (a *acceptor) start() error {

    // 1. 启动所有SubReactor
    for _, reactorSub := range a.reactorSubs {
        err := reactorSub.Start()
        if err != nil {
            return err
        }
    }

    var wg = &sync.WaitGroup{}

    // 2. 并行初始化三个监听器
    wg.Add(1)
    go func() {
        err := a.initTCPListener(wg)   // TCP监听
        if err != nil {
            a.Panic("initTCPListener() failed", zap.Error(err))
        }
    }()

    if strings.TrimSpace(a.eg.options.WsAddr) != "" {
        wg.Add(1)
        go func() {
            err := a.initWSListener(wg)   // WebSocket监听
            if err != nil {
                a.Panic("initWSListener() failed", zap.Error(err))
            }
        }()
    }

    if strings.TrimSpace(a.eg.options.WssAddr) != "" {
        wg.Add(1)
        go func() {
            err := a.initWSSListener(wg)  // WebSocket SSL监听
            if err != nil {
                a.Panic("initWSSListener() failed", zap.Error(err))
            }
        }()
    }

    wg.Wait()  // 等待所有监听器初始化完成
    return nil
}
```

**启动顺序图**：
```
Acceptor.Start()
    ↓
1. 启动所有SubReactor
    ├─ SubReactor-0.Start()
    ├─ SubReactor-1.Start()
    └─ ...
    ↓
2. 并行初始化监听器
    ├─ initTCPListener()  (goroutine 1)
    ├─ initWSListener()   (goroutine 2)
    └─ initWSSListener()  (goroutine 3)
    ↓
3. 等待所有监听器就绪
    ↓
4. 开始接受连接
```

---

### **E. TCP监听初始化**

**代码位置**：`pkg/wknet/acceptor.go:150-168`

```go
func (a *acceptor) initTCPListener(wg *sync.WaitGroup) error {
    // 1. 创建监听器
    a.listen = newListener(a.eg.options.Addr, a.eg.options)
    err := a.listen.init()
    if err != nil {
        return err
    }
    a.tcpRealListenAddr = a.listen.realAddr

    // 2. 将监听socket的fd注册到Poller
    if err := a.listenPoller.AddRead(a.listen.fd); err != nil {
        return fmt.Errorf("add listener fd to poller failed %s", err)
    }

    wg.Done()  // 通知初始化完成

    // 3. 阻塞轮询，接受连接
    err = a.listenPoller.Polling(func(fd int, ev netpoll.PollEvent) error {
        return a.acceptConn(fd, false, false)  // ws=false, wss=false
    })
    return err
}
```

**关键点**：
```
1. newListener() 创建监听socket并bind + listen
2. AddRead() 将监听socket注册到epoll（监听EPOLLIN事件）
3. Polling() 阻塞等待新连接到达
4. acceptConn() 接受新连接并分发到SubReactor
```

---

### **F. 接受连接详解** ⭐

**代码位置**：`pkg/wknet/acceptor.go:204-253`

```go
func (a *acceptor) acceptConn(listenFd int, ws bool, wss bool) error {
    // 1. 调用系统调用Accept接受连接
    connFd, sa, err := unix.Accept(listenFd)
    if err != nil {
        if err == unix.EAGAIN {
            return nil  // 暂时无连接，继续等待
        }
        return perrors.ErrAcceptSocket
    }

    // 2. 设置非阻塞模式
    if err = unix.SetNonblock(connFd, true); err != nil {
        return err
    }

    // 3. 获取远程地址
    remoteAddr := socket.SockaddrToTCPOrUnixAddr(sa)

    // 4. 设置TCP KeepAlive（如果配置）
    if a.eg.options.TCPKeepAlive > 0 && a.listen.customNetwork == "tcp" {
        socket.SetKeepAlivePeriod(connFd,
            int(a.eg.options.TCPKeepAlive.Seconds()))
    }

    // 5. 选择SubReactor（负载均衡）⭐
    subReactor := a.reactorSubByConnFd(connFd)

    // 6. 生成客户端ID
    clientId := a.eg.GenClientID()

    // 7. 创建连接对象
    var conn Conn
    if wss {
        conn, err = a.eg.eventHandler.OnNewWSSConn(
            clientId, newNetFd(connFd),
            a.wssRealAddr(), remoteAddr, a.eg, subReactor)
    } else if ws {
        conn, err = a.eg.eventHandler.OnNewWSConn(
            clientId, newNetFd(connFd),
            a.wsRealAddr(), remoteAddr, a.eg, subReactor)
    } else {
        conn, err = a.eg.eventHandler.OnNewConn(
            clientId, newNetFd(connFd),
            a.tcpRealAddr(), remoteAddr, a.eg, subReactor)
    }

    // 8. 将连接添加到SubReactor
    err = subReactor.AddConn(conn)
    if err != nil {
        a.Warn("subReactor.AddConn() failed", zap.Error(err))
    }

    // 9. 触发OnConnect回调
    err = a.eg.eventHandler.OnConnect(conn)
    if err != nil {
        a.Warn("OnConnect() failed", zap.Error(err))
    }

    return nil
}
```

---

### **G. SubReactor选择策略** ⭐

**代码位置**：`pkg/wknet/acceptor.go:255-258`

```go
func (a *acceptor) reactorSubByConnFd(connfd int) *ReactorSub {
    // 简单取模：fd % SubReactor数量
    return a.reactorSubs[connfd%len(a.reactorSubs)]
}
```

**为什么用fd取模？**
```
优点：
✅ 简单高效（O(1)）
✅ 分布均匀（fd是递增的）
✅ 无需维护额外状态

示例：
SubReactor数量 = 8
fd = 100 → SubReactor-4 (100 % 8 = 4)
fd = 101 → SubReactor-5 (101 % 8 = 5)
fd = 102 → SubReactor-6 (102 % 8 = 6)
...

结果：连接均匀分布到8个SubReactor
```

**其他策略对比**：
| 策略 | 优点 | 缺点 |
|------|------|------|
| **fd取模** ⭐ | 简单、快速、均匀 | 无 |
| **轮询（Round Robin）** | 均匀 | 需要维护计数器 |
| **最少连接** | 负载最均衡 | 需要遍历所有SubReactor |
| **随机** | 简单 | 可能不均匀 |

---

## 4️⃣ SubReactor 实现

### **A. ReactorSub结构**

**代码位置**：`pkg/wknet/reactor_sub.go:19-29`

```go
type ReactorSub struct {
    poller    *netpoll.Poller    // epoll/kqueue实例
    eg        *Engine            // Engine引用
    idx       int                // SubReactor索引
    connCount atomic.Int32       // 连接计数 ⭐
    wklog.Log
    ReadBuffer []byte            // 读缓冲区（复用）
    cache      bytes.Buffer      // 临时缓冲区
    stopped    atomic.Bool       // 停止标志
}
```

---

### **B. ReactorSub初始化**

**代码位置**：`pkg/wknet/reactor_sub.go:32-42`

```go
func NewReactorSub(eg *Engine, index int) *ReactorSub {
    poller := netpoll.NewPoller(index, "connPoller")

    return &ReactorSub{
        eg:         eg,
        poller:     poller,
        idx:        index,
        Log:        wklog.NewWKLog(fmt.Sprintf("ReactorSub-%d", index)),
        ReadBuffer: make([]byte, eg.options.ReadBufferSize),  // 32KB
    }
}
```

---

### **C. ReactorSub启动**

**代码位置**：`pkg/wknet/reactor_sub.go:52-55`

```go
func (r *ReactorSub) Start() error {
    go r.run()  // 启动独立goroutine
    return nil
}
```

---

### **D. ReactorSub事件循环** ⭐⭐⭐

**代码位置**：`pkg/wknet/reactor_sub.go:94-121`

```go
func (r *ReactorSub) run() {
    defer func() {
        if err := recover(); err != nil {
            r.Panic("reactorSub panic",
                zap.Any("err", err),
                zap.Stack("stack"))
        }
    }()

    // 核心事件循环
    err := r.poller.Polling(func(fd int, event netpoll.PollEvent) error {
        // 1. 根据fd查找连接
        conn := r.eg.GetConn(fd)
        if conn == nil {
            return nil  // 连接已关闭
        }

        // 2. 根据事件类型分发
        switch event {
        case netpoll.PollEventClose:
            // 连接关闭事件
            r.Debug("conn 连接关闭！",
                zap.Int64("id", conn.ID()),
                zap.Int("fd", fd))
            _ = r.CloseConn(conn, unix.ECONNRESET)

        case netpoll.PollEventRead:
            // 可读事件
            err = r.read(conn)

        case netpoll.PollEventWrite:
            // 可写事件
            err = r.write(conn)
        }

        return err
    })

    if err != nil && !r.stopped.Load() {
        r.Panic("poller error",
            zap.Error(err),
            zap.Int("idx", r.idx))
    }
}
```

**事件循环解析**：
```
SubReactor事件循环
    ↓
1. epoll_wait() 等待I/O事件
    ↓
2. 获取就绪的fd列表
    ↓
3. 对每个fd：
    ├─ 根据fd查找Conn对象
    ├─ 判断事件类型
    ├─ 分发到对应处理函数
    │   ├─ PollEventRead → read()
    │   ├─ PollEventWrite → write()
    │   └─ PollEventClose → CloseConn()
    └─ 继续下一个fd
    ↓
4. 处理完所有事件，继续epoll_wait()
```

---

### **E. 读事件处理**

**代码位置**：`pkg/wknet/reactor_sub.go:128-154`

```go
func (r *ReactorSub) read(c Conn) error {
    // 1. 读取数据到连接的InboundBuffer
    var n int
    var err error
    if n, err = c.ReadToInboundBuffer(); err != nil {
        if err == unix.EAGAIN {
            return nil  // 暂时无数据，等待下次
        }
        // 读取错误，关闭连接
        if err1 := r.CloseConn(c, err); err1 != nil {
            r.Warn("failed to close conn", zap.Error(err1))
        }
        return nil
    }

    // 2. 读到0字节，表示连接关闭
    if n == 0 {
        return r.CloseConn(c, os.NewSyscallError("read", unix.ECONNRESET))
    }

    // 3. 触发OnData回调（业务处理）
    if err = r.eg.eventHandler.OnData(c); err != nil {
        if err == unix.EAGAIN {
            return nil
        }
        if err1 := r.CloseConn(c, err); err1 != nil {
            r.Warn("failed to close conn", zap.Error(err1))
        }
        r.Warn("failed to call OnData", zap.Error(err))
        return nil
    }

    return nil
}
```

**读取流程图**：
```
epoll通知fd可读
    ↓
ReactorSub.read()
    ↓
1. c.ReadToInboundBuffer()
    ├─ 调用系统调用read()
    ├─ 读取数据到连接缓冲区
    └─ 返回读取的字节数
    ↓
2. OnData(c)
    ├─ 解析协议（WuKongIM协议）
    ├─ 业务处理
    └─ 返回
    ↓
3. 继续等待下次可读事件
```

---

### **F. 写事件处理**

**代码位置**：`pkg/wknet/reactor_sub.go:156-166`

```go
func (r *ReactorSub) write(c Conn) error {
    // 刷新发送缓冲区
    err := c.Flush()
    switch err {
    case nil:
        // 发送成功，继续
    case unix.EAGAIN:
        // 内核缓冲区满，等待下次
        return nil
    default:
        // 发送错误，关闭连接
        return r.CloseConn(c, os.NewSyscallError("write", err))
    }
    return nil
}
```

**写入流程图**：
```
业务层调用 conn.Write(data)
    ↓
数据写入 OutboundBuffer
    ↓
注册写事件（如果未注册）
    ↓
epoll通知fd可写
    ↓
ReactorSub.write()
    ↓
c.Flush()
    ├─ 调用系统调用write()
    ├─ 从OutboundBuffer发送数据
    └─ 如果缓冲区清空，移除写事件监听
```

---

### **G. 添加连接到SubReactor**

**代码位置**：`pkg/wknet/reactor_sub.go:45-49`

```go
func (r *ReactorSub) AddConn(conn Conn) error {
    // 1. 添加到Engine的连接矩阵
    r.eg.AddConn(conn)

    // 2. 增加连接计数
    r.connCount.Inc()

    // 3. 将fd注册到epoll（监听读事件）
    return r.poller.AddRead(conn.Fd().fd)
}
```

**为什么只注册读事件？**
```
原因：
1. 大部分时间连接是空闲的，只需监听读
2. 写事件按需注册（有数据要发送时才注册）
3. 减少epoll事件数量，提高性能

写事件注册时机：
├─ conn.Write(data) 被调用
├─ OutboundBuffer有数据
└─ 调用 AddWrite() 注册写事件

写事件移除时机：
├─ OutboundBuffer清空
└─ 调用 RemoveWrite() 移除写事件
```

---

## 5️⃣ 连接管理

### **A. connMatrix（连接矩阵）**

**代码位置**：`pkg/wknet/conn.go:872-911`

```go
type connMatrix struct {
    connCount atomic.Int32       // 连接计数（原子操作）
    conns     map[int]Conn       // fd → Conn 映射
}

func newConnMatrix() *connMatrix {
    return &connMatrix{
        conns: make(map[int]Conn),
    }
}

// 添加连接
func (cm *connMatrix) addConn(c Conn) {
    cm.conns[c.Fd().Fd()] = c
    cm.countAdd(1)
}

// 删除连接
func (cm *connMatrix) delConn(c Conn) {
    delete(cm.conns, c.Fd().Fd())
    cm.countAdd(-1)
}

// 根据fd查找连接（O(1)复杂度）
func (cm *connMatrix) getConn(fd int) Conn {
    return cm.conns[fd]
}

// 获取连接总数
func (cm *connMatrix) loadCount() (n int32) {
    return cm.connCount.Load()
}

// 遍历所有连接
func (cm *connMatrix) iterate(f func(Conn) bool) {
    for _, c := range cm.conns {
        if c != nil {
            if !f(c) {
                return  // 如果回调返回false，停止遍历
            }
        }
    }
}
```

---

### **B. 为什么用connMatrix？**

**传统方案**：遍历数组/切片查找连接

```go
// ❌ 低效方案
type ConnectionManager struct {
    conns []Conn
}

func (cm *ConnectionManager) GetConn(fd int) Conn {
    for _, conn := range cm.conns {
        if conn.Fd().Fd() == fd {
            return conn  // O(n) 复杂度
        }
    }
    return nil
}
```

**connMatrix方案**：使用map直接查找

```go
// ✅ 高效方案
type connMatrix struct {
    conns map[int]Conn  // key = fd
}

func (cm *connMatrix) getConn(fd int) Conn {
    return cm.conns[fd]  // O(1) 复杂度
}
```

**性能对比**：
| 操作 | 数组方案 | connMatrix | 提升 |
|------|---------|-----------|------|
| 查找连接 | O(n) | O(1) | 100万倍+ |
| 添加连接 | O(1) | O(1) | 相同 |
| 删除连接 | O(n) | O(1) | 100万倍+ |

**实际影响**：
```
场景：100万连接，每秒10万次查找

数组方案：
├─ 每次查找平均遍历50万个连接
├─ 总计：10万 × 50万 = 500亿次比较/秒
└─ CPU占用：100% 💥

connMatrix方案：
├─ 每次查找：hash查找
├─ 总计：10万次hash查找/秒
└─ CPU占用：<1% ✅
```

---

### **C. 客户端ID生成**

**代码位置**：`pkg/wknet/engine.go:143-151`

```go
func (e *Engine) GenClientID() int64 {
    cid := e.clientIDGen.Load()

    // 如果超过int32最大值，从0重新开始
    if cid >= 1<<32-1 {
        e.clientIDGen.Store(0)
    }

    return e.clientIDGen.Inc()  // 原子递增
}
```

**为什么从0重新开始？**
```
原因：
1. int32最大值：2,147,483,647（21亿）
2. 如果每秒建立1000个连接，需要248万天才会重置
3. 重置时原来的连接早已关闭，不会冲突

优点：
✅ 原子操作，无锁
✅ 性能极高
✅ ID用完自动循环
```

---

## 6️⃣ 事件处理流程

### **A. 完整连接处理流程**

```
┌────────────────────────────────────────────────────┐
│  1. 新连接到达                                      │
│     tcp://0.0.0.0:5100 收到连接请求                 │
└────────────────────────────────────────────────────┘
                        ↓
┌────────────────────────────────────────────────────┐
│  2. MainReactor.Acceptor                           │
│     ├─ listenPoller.Polling() 检测到可读事件       │
│     ├─ 调用 unix.Accept() 接受连接                 │
│     ├─ 获取connFd = 1024                           │
│     └─ 设置非阻塞：unix.SetNonblock(connFd, true)  │
└────────────────────────────────────────────────────┘
                        ↓
┌────────────────────────────────────────────────────┐
│  3. 选择SubReactor                                 │
│     subReactor = reactorSubs[1024 % 8] = Sub-0    │
└────────────────────────────────────────────────────┘
                        ↓
┌────────────────────────────────────────────────────┐
│  4. 创建连接对象                                    │
│     ├─ 生成clientId = 12345                        │
│     ├─ 创建Conn对象                                │
│     └─ 关联 SubReactor-0                          │
└────────────────────────────────────────────────────┘
                        ↓
┌────────────────────────────────────────────────────┐
│  5. 注册到SubReactor                               │
│     ├─ engine.AddConn(conn)                        │
│     │   └─ connMatrix[1024] = conn                 │
│     ├─ subReactor.connCount.Inc()                  │
│     └─ poller.AddRead(1024)                        │
│         └─ epoll_ctl(EPOLL_CTL_ADD, 1024, EPOLLIN) │
└────────────────────────────────────────────────────┘
                        ↓
┌────────────────────────────────────────────────────┐
│  6. 触发OnConnect回调                              │
│     eventHandler.OnConnect(conn)                   │
│     └─ WuKongIM: s.onConnect(conn)                 │
└────────────────────────────────────────────────────┘
                        ↓
┌────────────────────────────────────────────────────┐
│  7. 等待数据到达                                    │
│     SubReactor-0持续监听fd=1024                    │
└────────────────────────────────────────────────────┘
```

---

### **B. 数据接收处理流程**

```
┌────────────────────────────────────────────────────┐
│  1. 客户端发送数据                                  │
│     send("Hello WuKongIM")                         │
└────────────────────────────────────────────────────┘
                        ↓
┌────────────────────────────────────────────────────┐
│  2. epoll检测到可读事件                            │
│     epoll_wait() 返回：                            │
│     events[0] = {fd=1024, events=EPOLLIN}         │
└────────────────────────────────────────────────────┘
                        ↓
┌────────────────────────────────────────────────────┐
│  3. SubReactor-0处理                               │
│     ├─ conn = engine.GetConn(1024)                 │
│     └─ reactorSub.read(conn)                       │
└────────────────────────────────────────────────────┘
                        ↓
┌────────────────────────────────────────────────────┐
│  4. 读取数据                                       │
│     n = conn.ReadToInboundBuffer()                 │
│     ├─ 调用 read(1024, buf, 32768)                 │
│     └─ 读取16字节："Hello WuKongIM"                │
└────────────────────────────────────────────────────┘
                        ↓
┌────────────────────────────────────────────────────┐
│  5. 触发OnData回调                                 │
│     eventHandler.OnData(conn)                      │
│     └─ WuKongIM: s.onData(conn, data)              │
│         ├─ 解析WuKongIM协议                        │
│         ├─ 分发到UserEventPool                     │
│         └─ 业务处理                                │
└────────────────────────────────────────────────────┘
                        ↓
┌────────────────────────────────────────────────────┐
│  6. 继续监听                                       │
│     SubReactor-0继续 epoll_wait()                  │
└────────────────────────────────────────────────────┘
```

---

### **C. 数据发送处理流程**

```
┌────────────────────────────────────────────────────┐
│  1. 业务层发送数据                                  │
│     conn.Write([]byte("Response"))                 │
└────────────────────────────────────────────────────┘
                        ↓
┌────────────────────────────────────────────────────┐
│  2. 写入OutboundBuffer                             │
│     conn.OutboundBuffer.Write(data)                │
│     └─ 数据暂存在发送缓冲区                        │
└────────────────────────────────────────────────────┘
                        ↓
┌────────────────────────────────────────────────────┐
│  3. 注册写事件（如果未注册）                        │
│     subReactor.AddWrite(conn)                      │
│     └─ epoll_ctl(EPOLL_CTL_MOD, 1024,             │
│                  EPOLLIN|EPOLLOUT)                 │
└────────────────────────────────────────────────────┘
                        ↓
┌────────────────────────────────────────────────────┐
│  4. epoll检测到可写事件                            │
│     epoll_wait() 返回：                            │
│     events[0] = {fd=1024, events=EPOLLOUT}        │
└────────────────────────────────────────────────────┘
                        ↓
┌────────────────────────────────────────────────────┐
│  5. SubReactor-0处理                               │
│     reactorSub.write(conn)                         │
│     └─ conn.Flush()                                │
└────────────────────────────────────────────────────┘
                        ↓
┌────────────────────────────────────────────────────┐
│  6. 发送数据                                       │
│     write(1024, OutboundBuffer, len)               │
│     └─ 将OutboundBuffer数据发送到socket            │
└────────────────────────────────────────────────────┘
                        ↓
┌────────────────────────────────────────────────────┐
│  7. 移除写事件（如果缓冲区清空）                    │
│     subReactor.RemoveWrite(conn)                   │
│     └─ epoll_ctl(EPOLL_CTL_MOD, 1024, EPOLLIN)    │
└────────────────────────────────────────────────────┘
```

---

### **D. 连接关闭处理流程**

```
┌────────────────────────────────────────────────────┐
│  1. 检测到关闭事件                                  │
│     epoll_wait() 返回：                            │
│     events[0] = {fd=1024, events=EPOLLHUP}        │
└────────────────────────────────────────────────────┘
                        ↓
┌────────────────────────────────────────────────────┐
│  2. SubReactor-0处理                               │
│     reactorSub.CloseConn(conn, unix.ECONNRESET)    │
└────────────────────────────────────────────────────┘
                        ↓
┌────────────────────────────────────────────────────┐
│  3. 从epoll移除                                    │
│     poller.Delete(1024)                            │
│     └─ epoll_ctl(EPOLL_CTL_DEL, 1024, NULL)       │
└────────────────────────────────────────────────────┘
                        ↓
┌────────────────────────────────────────────────────┐
│  4. 从connMatrix移除                               │
│     engine.RemoveConn(conn)                        │
│     └─ delete(connMatrix.conns, 1024)             │
└────────────────────────────────────────────────────┘
                        ↓
┌────────────────────────────────────────────────────┐
│  5. 触发OnClose回调                                │
│     eventHandler.OnClose(conn)                     │
│     └─ WuKongIM: s.onClose(conn)                   │
│         ├─ 清理用户状态                            │
│         ├─ 触发离线事件                            │
│         └─ 释放资源                                │
└────────────────────────────────────────────────────┘
                        ↓
┌────────────────────────────────────────────────────┐
│  6. 关闭socket                                     │
│     close(1024)                                    │
│     └─ 释放文件描述符                              │
└────────────────────────────────────────────────────┘
```

---

## 7️⃣ 性能优化技术

### **A. 对象池（sync.Pool）**

**代码位置**：`pkg/wknet/engine.go:39-44`

```go
defaultConnPool: &sync.Pool{
    New: func() any {
        return &DefaultConn{}
    },
},
```

**作用**：
- 复用连接对象，减少内存分配
- 降低GC压力
- 提高性能

**使用流程**：
```
1. 获取连接对象
   conn := pool.Get().(*DefaultConn)

2. 初始化连接
   conn.init(fd, addr, ...)

3. 使用连接
   ...

4. 关闭连接后，归还对象池
   conn.reset()
   pool.Put(conn)
```

---

### **B. 读缓冲区复用**

**代码位置**：`pkg/wknet/reactor_sub.go:25`

```go
ReadBuffer []byte  // 每个SubReactor一个读缓冲区（32KB）
```

**优点**：
- 减少内存分配
- 缓冲区在SubReactor的整个生命周期内复用
- 读取性能提升

---

### **C. 原子操作**

**连接计数**：
```go
connCount atomic.Int32  // 原子计数，无锁
```

**客户端ID生成**：
```go
clientIDGen atomic.Int64  // 原子递增，无锁
```

**优点**：
- 无锁操作，性能极高
- 避免锁竞争
- 适合高并发场景

---

### **D. 非阻塞I/O**

**所有socket设置为非阻塞**：
```go
unix.SetNonblock(connFd, true)
```

**好处**：
- read()不会阻塞，立即返回
- write()不会阻塞，立即返回
- 配合epoll实现真正的异步I/O

---

## 8️⃣ 总结

### **核心要点**

1. **三层架构**：
   - Engine：总控引擎
   - MainReactor：负责Accept
   - SubReactor：负责I/O处理

2. **连接分发**：
   - 使用fd取模分配SubReactor
   - 简单高效，分布均匀

3. **连接查找**：
   - connMatrix使用map实现O(1)查找
   - 性能比数组方案提升100万倍

4. **事件驱动**：
   - epoll监听所有连接的I/O事件
   - 事件就绪才处理，无阻塞等待

5. **性能优化**：
   - 对象池复用
   - 缓冲区复用
   - 原子操作
   - 非阻塞I/O

---

### **设计亮点**

| 亮点 | 说明 |
|------|------|
| **SubReactor数量** | 等于CPU核心数，充分利用多核 |
| **fd取模分配** | 简单高效，分布均匀 |
| **connMatrix** | O(1)查找，性能极佳 |
| **按需注册写事件** | 减少epoll事件数量 |
| **对象池** | 减少内存分配，降低GC压力 |
| **原子操作** | 无锁高并发 |

---

### **下一节预告**

**3.3 连接处理流程**
- 完整连接生命周期
- 协议解析流程
- 心跳与超时管理
- 优雅关闭机制

---

> **🔗 相关代码**：
> - Engine：`pkg/wknet/engine.go:13-22`
> - ReactorMain：`pkg/wknet/reactor_main.go:5-18`
> - Acceptor：`pkg/wknet/acceptor.go:21-34`
> - ReactorSub：`pkg/wknet/reactor_sub.go:19-29`
> - connMatrix：`pkg/wknet/conn.go:872-911`
> - Poller：`pkg/wknet/netpoll/epoll_default_poller.go:21-52`
