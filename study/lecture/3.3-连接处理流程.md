# 3.3 连接处理流程

> **本节目标**：深入理解连接的完整生命周期，掌握连接建立、数据收发、心跳保活、优雅关闭的完整流程

---

## 📋 目录
1. [连接生命周期概览](#连接生命周期概览)
2. [连接建立流程](#连接建立流程)
3. [数据读取流程](#数据读取流程)
4. [数据发送流程](#数据发送流程)
5. [心跳与超时管理](#心跳与超时管理)
6. [连接关闭流程](#连接关闭流程)

---

## 1️⃣ 连接生命周期概览

### **A. 完整生命周期**

```
┌─────────────────────────────────────────────────────┐
│  连接生命周期（从建立到关闭）                         │
└─────────────────────────────────────────────────────┘

1. 连接建立（Establish）
   ├─ Accept接受连接
   ├─ 创建Conn对象
   ├─ 注册到epoll
   └─ 触发OnConnect回调

2. 认证阶段（Authentication）
   ├─ 客户端发送CONNECT包
   ├─ 服务端验证token
   ├─ 设置UID和DeviceID
   └─ 标记为已认证（SetAuthed）

3. 活跃阶段（Active）
   ├─ 数据收发
   ├─ 心跳保持
   ├─ 更新活跃时间
   └─ 超时检测

4. 关闭阶段（Close）
   ├─ 检测关闭条件
   ├─ 触发OnClose回调
   ├─ 清理资源
   └─ 释放fd
```

---

### **B. 连接状态转换**

```
  [新建]
    │
    ↓
  Accept() ────────────→ [已连接]
    │                        │
    │                        ↓
    │                   OnConnect()
    │                        │
    │                        ↓
    │                   等待CONNECT包
    │                        │
    │                        ↓
    │                   认证成功
    │                        │
    │                        ↓
    │                   [已认证] ←────┐
    │                        │         │
    │                        ↓         │
    │                   活跃状态       │ 心跳保持
    │                        │         │
    │                        ↓         │
    │                   数据收发 ──────┘
    │                        │
    ↓                        ↓
超时/错误/主动关闭 ────→ [已关闭]
    │                        │
    │                        ↓
    │                   OnClose()
    │                        │
    │                        ↓
    └─────────────────→ 资源释放
```

---

## 2️⃣ 连接建立流程

### **A. Accept连接**

**代码位置**：`pkg/wknet/acceptor.go:204-253`

```go
func (a *acceptor) acceptConn(listenFd int, ws bool, wss bool) error {
    // 1. 系统调用Accept
    connFd, sa, err := unix.Accept(listenFd)
    if err != nil {
        if err == unix.EAGAIN {
            return nil  // 暂无连接
        }
        return perrors.ErrAcceptSocket
    }

    // 2. 设置非阻塞
    if err = unix.SetNonblock(connFd, true); err != nil {
        return err
    }

    // 3. 获取远程地址
    remoteAddr := socket.SockaddrToTCPOrUnixAddr(sa)

    // 4. 设置TCP KeepAlive
    if a.eg.options.TCPKeepAlive > 0 {
        socket.SetKeepAlivePeriod(connFd,
            int(a.eg.options.TCPKeepAlive.Seconds()))
    }

    // 5. 选择SubReactor（负载均衡）
    subReactor := a.reactorSubByConnFd(connFd)

    // 6. 生成客户端ID
    clientId := a.eg.GenClientID()

    // 7. 创建Conn对象
    var conn Conn
    if ws {
        conn, err = a.eg.eventHandler.OnNewWSConn(...)
    } else {
        conn, err = a.eg.eventHandler.OnNewConn(...)
    }

    // 8. 添加到SubReactor
    err = subReactor.AddConn(conn)

    // 9. 触发OnConnect回调
    err = a.eg.eventHandler.OnConnect(conn)

    return nil
}
```

---

### **B. Conn对象初始化**

**代码位置**：`pkg/wknet/conn.go:152-187`

```go
func (d *DefaultConn) init(
    fd NetFd,
    localAddr, remoteAddr net.Addr,
    eg *Engine,
    reactorSub *ReactorSub,
    id int64,
) {
    // 基本属性
    d.fd = fd
    d.localAddr = localAddr
    d.remoteAddr = remoteAddr
    d.eg = eg
    d.reactorSub = reactorSub
    d.id.Store(id)

    // 缓冲区初始化
    d.inboundBuffer = ring.New(eg.options.ReadBufferSize)
    d.outboundBuffer = ring.New(eg.options.MaxWriteBufferSize)

    // 时间初始化
    now := time.Now()
    d.uptime.Store(now)
    d.lastActivity.Store(now)

    // 状态初始化
    d.closed.Store(false)
    d.authed.Store(false)
    d.isWAdded = false

    d.Log = wklog.NewWKLog(fmt.Sprintf("Conn[%d]", id))
}
```

**初始化的关键要素**：
```
1. fd：文件描述符（socket）
2. 地址：localAddr、remoteAddr
3. 缓冲区：
   ├─ inboundBuffer：接收缓冲区（ring buffer）
   └─ outboundBuffer：发送缓冲区（ring buffer）
4. 时间：
   ├─ uptime：连接建立时间
   └─ lastActivity：最后活跃时间
5. 状态：
   ├─ closed：是否已关闭
   └─ authed：是否已认证
```

---

### **C. 注册到SubReactor**

**代码位置**：`pkg/wknet/reactor_sub.go:45-49`

```go
func (r *ReactorSub) AddConn(conn Conn) error {
    // 1. 添加到Engine的connMatrix
    r.eg.AddConn(conn)

    // 2. 增加SubReactor的连接计数
    r.connCount.Inc()

    // 3. 注册到epoll（只监听读事件）
    return r.poller.AddRead(conn.Fd().fd)
}
```

**epoll注册**：
```go
// pkg/wknet/netpoll/epoll_default_poller.go:122-125
func (p *Poller) AddRead(fd int) error {
    return unix.EpollCtl(p.fd, unix.EPOLL_CTL_ADD, fd,
        &unix.EpollEvent{
            Fd: int32(fd),
            Events: unix.EPOLLIN | unix.EPOLLET,  // 读事件 + 边缘触发
        })
}
```

---

### **D. OnConnect回调**

**WuKongIM的实现**：`internal/server/server.go:576-617`

```go
func (s *Server) onConnect(conn wknet.Conn) error {
    // 1. 记录连接日志
    s.Info("new connection",
        zap.Int64("id", conn.ID()),
        zap.String("remoteAddr", conn.RemoteAddr().String()))

    // 2. 设置最大空闲时间
    conn.SetMaxIdle(s.opts.ConnIdleTime)  // 默认5分钟

    // 3. 触发连接建立事件
    s.userEventPool.AddEvent(&eventbus.UserContext{
        EventType: eventbus.EventConnect,
        Conn:      conn,
    })

    return nil
}
```

**EventConnect事件处理**：`internal/user/handler/event_connect.go`

```go
func (h *ConnectHandler) Handle(ctx *eventbus.UserContext) error {
    conn := ctx.Conn

    // 等待客户端发送CONNECT包
    // 如果30秒内未收到，连接会因超时被关闭
    conn.SetReadDeadline(time.Now().Add(30 * time.Second))

    return nil
}
```

---

## 3️⃣ 数据读取流程

### **A. 读事件触发**

```
epoll_wait()检测到fd可读
    ↓
SubReactor.run() → callback(fd, PollEventRead)
    ↓
SubReactor.read(conn)
    ↓
conn.ReadToInboundBuffer()
    ↓
eventHandler.OnData(conn)
```

---

### **B. ReadToInboundBuffer实现** ⭐

**代码位置**：`pkg/wknet/conn.go:209-224`

```go
func (d *DefaultConn) ReadToInboundBuffer() (int, error) {
    // 1. 使用SubReactor的共享读缓冲区
    readBuffer := d.reactorSub.ReadBuffer  // 32KB

    // 2. 调用系统调用read
    n, err := d.fd.Read(readBuffer)
    if err != nil || n == 0 {
        return 0, err
    }

    // 3. 统计读取字节数（可选）
    if d.eg.options.Event.OnReadBytes != nil {
        d.eg.options.Event.OnReadBytes(n)
    }

    // 4. 检查InboundBuffer是否溢出
    if d.overflowForInbound(n) {
        return 0, fmt.Errorf("inbound buffer overflow, fd: %d currentSize: %d maxSize: %d",
            d.fd, d.inboundBuffer.BoundBufferSize()+n, d.eg.options.MaxReadBufferSize)
    }

    // 5. 更新最后活跃时间
    d.KeepLastActivity()

    // 6. 写入InboundBuffer
    _, err = d.inboundBuffer.Write(readBuffer[:n])
    return n, err
}
```

---

### **C. InboundBuffer（Ring Buffer）**

**设计**：
```
Ring Buffer（环形缓冲区）

  head                tail
    ↓                  ↓
┌───┬───┬───┬───┬───┬───┬───┬───┐
│ 1 │ 2 │ 3 │ 4 │   │   │   │   │
└───┴───┴───┴───┴───┴───┴───┴───┘
    ↑           ↑
  已读取      待读取

特点：
✅ 无需移动数据，只需移动指针
✅ 自动循环使用，无浪费
✅ O(1)复杂度的读写操作
```

**代码位置**：`pkg/ring/ring.go`

```go
type RingBuffer struct {
    buf  []byte  // 缓冲区
    head int     // 读指针
    tail int     // 写指针
    size int     // 数据大小
    cap  int     // 容量
}

// 写入数据
func (r *RingBuffer) Write(p []byte) (n int, err error) {
    // 写入到tail位置
    // tail自动循环
}

// 读取数据
func (r *RingBuffer) Read(p []byte) (n int, err error) {
    // 从head位置读取
    // head自动前进
}
```

---

### **D. OnData回调**

**WuKongIM的实现**：`internal/server/server.go:619-652`

```go
func (s *Server) onData(conn wknet.Conn) error {
    // 1. 读取InboundBuffer中的数据
    for {
        // 检查缓冲区是否为空
        if conn.InboundBuffer().IsEmpty() {
            break
        }

        // 2. 解析协议帧
        frame, err := s.protocol.Decode(conn)
        if err != nil {
            if err == io.ErrShortBuffer {
                break  // 数据不完整，等待更多数据
            }
            return err
        }

        // 3. 根据帧类型分发事件
        switch frame.FrameType {
        case wkproto.CONNECT:
            // 连接包
            s.userEventPool.AddEvent(&eventbus.UserContext{
                EventType: eventbus.EventOnConnect,
                Conn:      conn,
                Frame:     frame,
            })

        case wkproto.SEND:
            // 发送消息包
            s.userEventPool.AddEvent(&eventbus.UserContext{
                EventType: eventbus.EventOnSend,
                Conn:      conn,
                Frame:     frame,
            })

        case wkproto.PING:
            // 心跳包
            conn.Write(wkproto.EncodePong())

        case wkproto.RECVACK:
            // 接收确认包
            s.userEventPool.AddEvent(&eventbus.UserContext{
                EventType: eventbus.EventRecvAck,
                Conn:      conn,
                Frame:     frame,
            })

        // ... 其他帧类型
        }
    }

    return nil
}
```

---

### **E. 协议解析（粘包/半包处理）**

**粘包问题**：
```
客户端发送：
├─ 消息1：10字节
└─ 消息2：20字节

TCP接收可能：
情况1：一次性收到30字节（粘包）
情况2：第一次10字节，第二次20字节（正常）
情况3：第一次5字节，第二次25字节（半包）
```

**解决方案**：协议头包含长度字段

```
WuKongIM协议格式：
┌────────┬────────┬────────┬──────────┐
│  类型  │  标志  │  长度  │  数据    │
│ 1字节  │ 1字节  │ 4字节  │ N字节    │
└────────┴────────┴────────┴──────────┘

解析流程：
1. 读取6字节包头（类型+标志+长度）
2. 根据长度字段知道数据部分有N字节
3. 读取N字节数据
4. 完整帧解析完成

半包处理：
├─ 如果数据不足，返回 io.ErrShortBuffer
├─ 数据保留在InboundBuffer中
└─ 等待下次读事件，继续解析
```

---

## 4️⃣ 数据发送流程

### **A. 发送API**

**两种发送方式**：

```go
// 方式1：直接发送（非线程安全）
conn.Write(data)

// 方式2：写入OutboundBuffer（线程安全）
conn.WriteToOutboundBuffer(data)
conn.WakeWrite()  // 唤醒写事件
```

---

### **B. Write实现**

**代码位置**：`pkg/wknet/conn.go:241-253`

```go
func (d *DefaultConn) Write(b []byte) (int, error) {
    if d.closed.Load() {
        return -1, net.ErrClosed
    }

    n, err := d.write(b)
    if err != nil {
        return 0, err
    }
    return n, nil
}

func (d *DefaultConn) write(b []byte) (int, error) {
    // 1. 先尝试直接写入socket
    n, err := d.fd.Write(b)
    if err != nil {
        if err == unix.EAGAIN {
            // 内核缓冲区满，写入OutboundBuffer
            _, err = d.outboundBuffer.Write(b)
            if err != nil {
                return 0, err
            }
            // 注册写事件
            return len(b), d.addWriteIfNotExist()
        }
        return 0, err
    }

    // 2. 如果只写入了部分数据
    if n < len(b) {
        // 剩余数据写入OutboundBuffer
        _, err = d.outboundBuffer.Write(b[n:])
        if err != nil {
            return 0, err
        }
        // 注册写事件
        return len(b), d.addWriteIfNotExist()
    }

    return n, nil
}
```

---

### **C. WriteToOutboundBuffer实现**

**代码位置**：`pkg/wknet/conn.go:256-267`

```go
func (d *DefaultConn) WriteToOutboundBuffer(b []byte) (int, error) {
    if len(b) == 0 {
        return 0, nil
    }
    if d.closed.Load() {
        return -1, net.ErrClosed
    }

    d.mu.Lock()
    defer d.mu.Unlock()

    // 直接写入OutboundBuffer
    return d.outboundBuffer.Write(b)
}

// 唤醒写事件
func (d *DefaultConn) WakeWrite() error {
    d.mu.Lock()
    defer d.mu.Unlock()

    if d.closed.Load() {
        return net.ErrClosed
    }

    // 注册写事件（如果未注册）
    return d.addWriteIfNotExist()
}
```

---

### **D. 注册写事件**

```go
func (d *DefaultConn) addWriteIfNotExist() error {
    if d.isWAdded {
        return nil  // 已注册，无需重复
    }

    // 将fd修改为监听读写事件
    err := d.reactorSub.AddWrite(d)
    if err != nil {
        return err
    }

    d.isWAdded = true
    return nil
}
```

**epoll修改**：
```go
// pkg/wknet/netpoll/epoll_default_poller.go:127-130
func (p *Poller) AddWrite(fd int) error {
    return unix.EpollCtl(p.fd, unix.EPOLL_CTL_MOD, fd,
        &unix.EpollEvent{
            Fd: int32(fd),
            Events: unix.EPOLLIN | unix.EPOLLOUT | unix.EPOLLET,  // 读+写事件
        })
}
```

---

### **E. Flush实现（写事件回调）**

**代码位置**：`pkg/wknet/conn.go:283-288`

```go
func (d *DefaultConn) Flush() error {
    if d.closed.Load() {
        return net.ErrClosed
    }
    return d.flush()
}

func (d *DefaultConn) flush() error {
    // 1. 如果OutboundBuffer为空，移除写事件
    if d.outboundBuffer.IsEmpty() {
        if d.isWAdded {
            err := d.reactorSub.RemoveWrite(d)
            if err != nil {
                return err
            }
            d.isWAdded = false
        }
        return nil
    }

    // 2. 从OutboundBuffer读取数据并发送
    for {
        // 获取可读数据
        data, _ := d.outboundBuffer.Peek(d.outboundBuffer.BoundBufferSize())
        if len(data) == 0 {
            break
        }

        // 调用系统调用write
        n, err := d.fd.Write(data)
        if err != nil {
            if err == unix.EAGAIN {
                break  // 内核缓冲区满，等待下次
            }
            return err
        }

        // 丢弃已发送的数据
        d.outboundBuffer.Discard(n)

        // 统计发送字节数
        if d.eg.options.Event.OnWirteBytes != nil {
            d.eg.options.Event.OnWirteBytes(n)
        }
    }

    // 3. 如果缓冲区清空，移除写事件
    if d.outboundBuffer.IsEmpty() && d.isWAdded {
        err := d.reactorSub.RemoveWrite(d)
        if err != nil {
            return err
        }
        d.isWAdded = false
    }

    return nil
}
```

---

### **F. 发送流程总结**

```
业务层调用 conn.Write(data)
    ↓
1. 尝试直接写入socket
    ├─ 成功 → 返回
    └─ EAGAIN或部分写入 → 继续
    ↓
2. 剩余数据写入OutboundBuffer
    ↓
3. 注册写事件（EPOLLOUT）
    ↓
4. epoll通知fd可写
    ↓
5. SubReactor.write(conn) → conn.Flush()
    ↓
6. 从OutboundBuffer读取数据并发送
    ├─ 全部发送 → 移除写事件
    └─ 部分发送 → 保留写事件，等待下次
```

---

## 5️⃣ 心跳与超时管理

### **A. 心跳机制**

**客户端发送心跳**：
```
客户端每30秒发送一次PING包
    ↓
服务端收到PING
    ↓
服务端回复PONG包
    ↓
更新连接的lastActivity时间
```

**代码实现**：`internal/server/server.go:onData`

```go
case wkproto.PING:
    // 收到心跳包，直接回复PONG
    conn.Write(wkproto.EncodePong())
    // lastActivity会在ReadToInboundBuffer中自动更新
```

---

### **B. 超时检测**

**SetMaxIdle设置最大空闲时间**：

**代码位置**：`pkg/wknet/conn.go`

```go
func (d *DefaultConn) SetMaxIdle(duration time.Duration) {
    d.maxIdleLock.Lock()
    defer d.maxIdleLock.Unlock()

    d.maxIdle = duration

    // 取消旧的定时器
    if d.idleTimer != nil {
        d.idleTimer.Stop()
    }

    // 创建新的空闲检测定时器
    d.idleTimer = d.eg.Schedule(duration, func() {
        // 检查是否超时
        if time.Since(d.lastActivity.Load()) > d.maxIdle {
            // 超时，关闭连接
            d.Close()
        } else {
            // 未超时，继续下一轮检测
            d.SetMaxIdle(d.maxIdle)
        }
    })
}
```

---

### **C. 时间轮（TimingWheel）**

**作用**：高效管理大量定时任务

**传统方案问题**：
```go
// ❌ 为每个连接创建一个定时器
for _, conn := range conns {
    time.AfterFunc(5*time.Minute, func() {
        checkTimeout(conn)
    })
}

问题：
- 100万连接 = 100万个timer
- 内存占用大
- 调度开销高
```

**时间轮方案**：
```
时间轮结构：
┌───┬───┬───┬───┬───┬───┬───┬───┐
│ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ ... 1000个槽位
└───┴───┴───┴───┴───┴───┴───┴───┘
  ↑
指针每10ms转动一次

优点：
✅ 100万连接共享一个时间轮
✅ 内存占用低
✅ O(1)插入和删除
```

**代码位置**：`pkg/wknet/engine.go:38`

```go
timingWheel: timingwheel.NewTimingWheel(
    time.Millisecond*10,  // tick间隔：10ms
    1000,                 // 槽位数：1000
)
```

---

### **D. 最后活跃时间更新**

**KeepLastActivity自动更新**：

```go
// pkg/wknet/conn.go:226-228
func (d *DefaultConn) KeepLastActivity() {
    d.lastActivity.Store(time.Now())
}
```

**调用时机**：
```
1. ReadToInboundBuffer() 读取数据时
2. OnData() 处理数据时
3. 心跳包到达时

效果：
- 只要有数据交互，连接就不会超时
- 如果5分钟无任何数据，连接关闭
```

---

## 6️⃣ 连接关闭流程

### **A. 关闭触发条件**

```
1. 客户端主动关闭
   └─ epoll检测到EPOLLHUP事件

2. 服务端主动关闭
   └─ 调用 conn.Close()

3. 超时关闭
   └─ 空闲时间超过maxIdle

4. 错误关闭
   └─ 读写错误、协议错误
```

---

### **B. Close实现**

**代码位置**：`pkg/wknet/conn.go:295-350`

```go
func (d *DefaultConn) close(closeErr error) error {
    d.mu.Lock()
    defer d.mu.Unlock()

    // 1. 检查是否已关闭
    if d.closed.Load() {
        return nil
    }
    d.closed.Store(true)

    // 2. 从epoll移除
    if closeErr != nil && !errors.Is(closeErr, syscall.ECONNRESET) {
        err := d.reactorSub.DeleteFd(d)
        if err != nil {
            d.Debug("delete fd from poller error", zap.Error(err))
        }
    }

    // 3. 停止空闲检测定时器
    if d.idleTimer != nil {
        d.idleTimer.Stop()
        d.idleTimer = nil
    }

    // 4. 从connMatrix移除
    d.eg.RemoveConn(d)

    // 5. SubReactor连接计数减1
    d.reactorSub.ConnDec()

    // 6. 触发OnClose回调
    if d.eg.eventHandler.OnClose != nil {
        err := d.eg.eventHandler.OnClose(d, closeErr)
        if err != nil {
            d.Warn("OnClose error", zap.Error(err))
        }
    }

    // 7. 清理缓冲区
    d.inboundBuffer.Reset()
    d.outboundBuffer.Reset()

    // 8. 关闭socket
    err := d.fd.Close()
    if err != nil {
        d.Debug("close fd error", zap.Error(err))
    }

    return nil
}
```

---

### **C. OnClose回调**

**WuKongIM的实现**：`internal/server/server.go:654-680`

```go
func (s *Server) onClose(conn wknet.Conn, err error) error {
    // 1. 记录关闭日志
    s.Info("connection closed",
        zap.Int64("id", conn.ID()),
        zap.String("uid", conn.UID()),
        zap.String("remoteAddr", conn.RemoteAddr().String()),
        zap.Error(err))

    // 2. 如果连接未认证，直接返回
    if !conn.IsAuthed() {
        return nil
    }

    // 3. 触发连接关闭事件
    s.userEventPool.AddEvent(&eventbus.UserContext{
        EventType: eventbus.EventConnClose,
        Conn:      conn,
    })

    return nil
}
```

**EventConnClose事件处理**：`internal/user/handler/event_close.go`

```go
func (h *CloseHandler) Handle(ctx *eventbus.UserContext) error {
    conn := ctx.Conn

    // 1. 清理用户在线状态
    s.connManager.RemoveConn(conn.UID(), conn.ID())

    // 2. 如果用户所有设备都离线，触发离线事件
    if s.connManager.GetConnCount(conn.UID()) == 0 {
        s.eventBus.Publish(&eventbus.Event{
            Type: eventbus.EventUserOffline,
            Data: conn.UID(),
        })
    }

    // 3. 清理订阅关系（如果需要）
    // ...

    return nil
}
```

---

### **D. 优雅关闭**

**什么是优雅关闭？**
```
优雅关闭（Graceful Shutdown）：
1. 停止接受新连接
2. 等待现有连接处理完成
3. 发送关闭通知
4. 清理资源
5. 关闭服务
```

**WuKongIM的实现**：`pkg/wknet/engine.go:54-61`

```go
func (e *Engine) Stop() error {
    // 1. 停止时间轮
    e.timingWheel.Stop()

    // 2. 停止MainReactor（停止接受新连接）
    err := e.reactorMain.Stop()
    if err != nil {
        return err
    }

    return nil
}
```

**Acceptor停止**：`pkg/wknet/acceptor.go:100-148`

```go
func (a *acceptor) Stop() error {
    // 1. 关闭监听Poller
    a.listenPoller.Close()
    a.listenWSPoller.Close()
    a.listenWSSPoller.Close()

    // 2. 关闭监听socket
    if a.listen != nil {
        a.listen.Close()
    }
    if a.listenWS != nil {
        a.listenWS.Close()
    }
    if a.listenWSS != nil {
        a.listenWSS.Close()
    }

    // 3. 停止所有SubReactor
    for _, reactorSub := range a.reactorSubs {
        reactorSub.Stop()
    }

    return nil
}
```

**SubReactor停止**：`pkg/wknet/reactor_sub.go:58-61`

```go
func (r *ReactorSub) Stop() error {
    // 设置停止标志
    r.stopped.Store(true)

    // 关闭Poller（会退出事件循环）
    return r.poller.Close()
}
```

---

## 7️⃣ 总结

### **核心要点**

1. **连接生命周期**：
   - 建立 → 认证 → 活跃 → 关闭
   - 每个阶段都有明确的状态和处理逻辑

2. **数据读取**：
   - ReadToInboundBuffer()读取到Ring Buffer
   - OnData()解析协议并分发事件
   - 自动处理粘包/半包问题

3. **数据发送**：
   - 优先直接发送（减少拷贝）
   - 发不出去写OutboundBuffer
   - 按需注册写事件
   - Flush()时批量发送

4. **心跳保活**：
   - 客户端30秒发一次PING
   - 服务端回复PONG
   - 更新lastActivity时间
   - 5分钟无数据自动关闭

5. **优雅关闭**：
   - 停止接受新连接
   - 等待现有连接处理完
   - 清理资源
   - 触发回调

---

### **设计亮点**

| 特性 | 说明 |
|------|------|
| **Ring Buffer** | 无需移动数据，高效读写 |
| **按需写事件** | 减少epoll事件数量 |
| **时间轮** | 高效管理100万+连接的超时 |
| **原子操作** | 无锁更新状态和时间 |
| **优雅关闭** | 不丢失数据，完整清理 |

---

### **下一节预告**

**3.4 性能优化技术**
- TimingWheel时间轮详解
- ConnMatrix连接矩阵优化
- 对象池技术
- 零拷贝技术

---

> **🔗 相关代码**：
> - 连接对象：`pkg/wknet/conn.go:124-149`
> - 读取实现：`pkg/wknet/conn.go:209-224`
> - 发送实现：`pkg/wknet/conn.go:241-288`
> - 关闭实现：`pkg/wknet/conn.go:295-350`
> - Ring Buffer：`pkg/ring/ring.go`
