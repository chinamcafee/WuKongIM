# 4.2 Frame è§£ææµç¨‹

> **æœ¬èŠ‚ç›®æ ‡**ï¼šæ·±å…¥ç†è§£ä»å­—èŠ‚æµåˆ°Frameçš„å®Œæ•´è§£æè¿‡ç¨‹ï¼ŒæŒæ¡ç²˜åŒ…/åŠåŒ…å¤„ç†çš„æ ¸å¿ƒæŠ€æœ¯

---

## ğŸ“‹ ç›®å½•
1. [è§£ææµç¨‹æ¦‚è§ˆ](#è§£ææµç¨‹æ¦‚è§ˆ)
2. [å­—èŠ‚æµå¤„ç†](#å­—èŠ‚æµå¤„ç†)
3. [ç²˜åŒ…åŠåŒ…å¤„ç†](#ç²˜åŒ…åŠåŒ…å¤„ç†)
4. [åè®®è§£ç å™¨å®ç°](#åè®®è§£ç å™¨å®ç°)
5. [é”™è¯¯å¤„ç†ä¸æ¢å¤](#é”™è¯¯å¤„ç†ä¸æ¢å¤)
6. [æ€§èƒ½ä¼˜åŒ–æŠ€å·§](#æ€§èƒ½ä¼˜åŒ–æŠ€å·§)

---

## 1ï¸âƒ£ è§£ææµç¨‹æ¦‚è§ˆ

### **A. å®Œæ•´è§£æé“¾è·¯**

```
TCPå­—èŠ‚æµ
    â†“
SubReactoræ£€æµ‹åˆ°å¯è¯»äº‹ä»¶
    â†“
conn.ReadToInboundBuffer()  â† è¯»å–æ•°æ®åˆ°Ring Buffer
    â†“
Server.onData(conn)  â† æ•°æ®åˆ°è¾¾å›è°ƒ
    â†“
protocol.Decode(conn)  â† åè®®è§£æ
    â†“
æ ¹æ®FrameTypeåˆ†å‘äº‹ä»¶
    â†“
ä¸šåŠ¡Handlerå¤„ç†
```

---

### **B. è§£æå±‚æ¬¡**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Layer 4: ä¸šåŠ¡å±‚                             â”‚
â”‚  â””â”€ EventHandlerå¤„ç†å…·ä½“ä¸šåŠ¡é€»è¾‘              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†‘ Frameå¯¹è±¡
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Layer 3: åè®®è§£æå±‚                          â”‚
â”‚  â””â”€ Protocol.Decode() è§£æFrame              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†‘ å®Œæ•´åŒ…æ•°æ®
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Layer 2: åˆ†å¸§å±‚                             â”‚
â”‚  â””â”€ ç²˜åŒ…/åŠåŒ…å¤„ç†ï¼Œæå–å®Œæ•´åŒ…                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†‘ å­—èŠ‚æµ
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Layer 1: ä¼ è¾“å±‚                             â”‚
â”‚  â””â”€ TCPè¯»å–å­—èŠ‚æµåˆ°InboundBuffer             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2ï¸âƒ£ å­—èŠ‚æµå¤„ç†

### **A. TCPæ•°æ®è¯»å–**

**ä»£ç ä½ç½®**ï¼š`pkg/wknet/conn.go:209-224`

```go
func (d *DefaultConn) ReadToInboundBuffer() (int, error) {
    // 1. ä½¿ç”¨SubReactorçš„å…±äº«è¯»ç¼“å†²åŒº
    readBuffer := d.reactorSub.ReadBuffer  // 32KB

    // 2. è°ƒç”¨ç³»ç»Ÿè°ƒç”¨read
    n, err := d.fd.Read(readBuffer)
    if err != nil || n == 0 {
        return 0, err
    }

    // 3. ç»Ÿè®¡è¯»å–å­—èŠ‚æ•°
    if d.eg.options.Event.OnReadBytes != nil {
        d.eg.options.Event.OnReadBytes(n)
    }

    // 4. æ£€æŸ¥InboundBufferæ˜¯å¦æº¢å‡º
    if d.overflowForInbound(n) {
        return 0, fmt.Errorf("inbound buffer overflow")
    }

    // 5. æ›´æ–°æœ€åæ´»è·ƒæ—¶é—´
    d.KeepLastActivity()

    // 6. å†™å…¥InboundBufferï¼ˆRing Bufferï¼‰
    _, err = d.inboundBuffer.Write(readBuffer[:n])
    return n, err
}
```

**å…³é”®ç‚¹**ï¼š
- ä½¿ç”¨32KBå…±äº«ç¼“å†²åŒºï¼ˆå‡å°‘å†…å­˜åˆ†é…ï¼‰
- å†™å…¥Ring Bufferï¼ˆé›¶æ‹·è´è®¾è®¡ï¼‰
- æ›´æ–°æ´»è·ƒæ—¶é—´ï¼ˆè¶…æ—¶ç®¡ç†ï¼‰

---

### **B. InboundBufferç®¡ç†**

**Ring Bufferç»“æ„**ï¼š
```
InboundBufferï¼ˆç¯å½¢ç¼“å†²åŒºï¼‰ï¼š

åˆå§‹çŠ¶æ€ï¼š
  head=0, tail=0, size=0
  â†“
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
  â†‘
 head/tail

è¯»å–100å­—èŠ‚åï¼š
  head=0, tail=100, size=100
  â†“
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚ D â”‚ D â”‚ D â”‚ D â”‚   â”‚   â”‚   â”‚   â”‚
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
  â†‘               â†‘
 head            tail

è§£æ50å­—èŠ‚åï¼š
  head=50, tail=100, size=50
  â†“
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚   â”‚   â”‚ D â”‚ D â”‚   â”‚   â”‚   â”‚   â”‚
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
          â†‘       â†‘
         head    tail

ç»§ç»­è¯»å–80å­—èŠ‚ï¼š
  head=50, tail=180, size=130
  â†“
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚ D â”‚ D â”‚ D â”‚ D â”‚ D â”‚ D â”‚ D â”‚ D â”‚
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
          â†‘                   â†‘
         head                tailï¼ˆç¯ç»•ï¼‰
```

---

### **C. æ•°æ®åˆ°è¾¾å›è°ƒ**

**ä»£ç ä½ç½®**ï¼š`internal/server/server.go:619-652`

```go
func (s *Server) onData(conn wknet.Conn) error {
    // å¾ªç¯å¤„ç†InboundBufferä¸­çš„æ‰€æœ‰å®Œæ•´å¸§
    for {
        // 1. æ£€æŸ¥ç¼“å†²åŒºæ˜¯å¦ä¸ºç©º
        if conn.InboundBuffer().IsEmpty() {
            break
        }

        // 2. å°è¯•è§£æä¸€ä¸ªå®Œæ•´å¸§
        frame, err := s.protocol.Decode(conn)
        if err != nil {
            if err == io.ErrShortBuffer {
                // æ•°æ®ä¸å®Œæ•´ï¼Œç­‰å¾…æ›´å¤šæ•°æ®
                break
            }
            // å…¶ä»–é”™è¯¯ï¼ˆåè®®é”™è¯¯ç­‰ï¼‰ï¼Œå…³é—­è¿æ¥
            return err
        }

        // 3. æ ¹æ®å¸§ç±»å‹åˆ†å‘
        err = s.dispatchFrame(conn, frame)
        if err != nil {
            return err
        }

        // 4. ç»§ç»­è§£æä¸‹ä¸€ä¸ªå¸§ï¼ˆå¤„ç†ç²˜åŒ…ï¼‰
    }

    return nil
}
```

**å¤„ç†é€»è¾‘**ï¼š
- å¾ªç¯è§£æï¼ˆå¤„ç†ç²˜åŒ…ï¼‰
- é‡åˆ°åŠåŒ…åˆ™ç­‰å¾…ï¼ˆè¿”å›ErrShortBufferï¼‰
- é‡åˆ°é”™è¯¯åˆ™å…³é—­è¿æ¥

---

## 3ï¸âƒ£ ç²˜åŒ…åŠåŒ…å¤„ç†

### **A. ç²˜åŒ…é—®é¢˜**

**åœºæ™¯1ï¼šå¤šä¸ªåŒ…ç²˜åœ¨ä¸€èµ·**
```
å®¢æˆ·ç«¯å‘é€ï¼š
â”œâ”€ PINGåŒ…ï¼ˆ6å­—èŠ‚ï¼‰
â”œâ”€ SENDåŒ…ï¼ˆ100å­—èŠ‚ï¼‰
â””â”€ PINGåŒ…ï¼ˆ6å­—èŠ‚ï¼‰

TCPå¯èƒ½ä¸€æ¬¡æ€§æ¥æ”¶ï¼š
[PINGåŒ…][SENDåŒ…][PINGåŒ…]
 6å­—èŠ‚   100å­—èŠ‚  6å­—èŠ‚

æ€»å…±112å­—èŠ‚åœ¨ä¸€ä¸ªTCPåŒ…ä¸­
```

**è§£å†³æ–¹æ¡ˆ**ï¼šå¾ªç¯è§£æ
```go
for {
    frame, err := protocol.Decode(conn)
    if err == io.ErrShortBuffer {
        break  // æ— å®Œæ•´åŒ…ï¼Œç­‰å¾…
    }
    handleFrame(frame)  // å¤„ç†å®Œæ•´åŒ…
}
```

---

### **B. åŠåŒ…é—®é¢˜**

**åœºæ™¯2ï¼šä¸€ä¸ªåŒ…è¢«æ‹†åˆ†**
```
å®¢æˆ·ç«¯å‘é€ï¼š
SENDåŒ…ï¼ˆ100å­—èŠ‚ï¼‰

TCPå¯èƒ½åˆ†ä¸¤æ¬¡æ¥æ”¶ï¼š
ç¬¬1æ¬¡ï¼šå‰50å­—èŠ‚
ç¬¬2æ¬¡ï¼šå50å­—èŠ‚

é—®é¢˜ï¼š
â”œâ”€ ç¬¬1æ¬¡åªæ”¶åˆ°ä¸€åŠï¼Œæ— æ³•è§£æ
â””â”€ éœ€è¦ç­‰å¾…ç¬¬2æ¬¡æ•°æ®åˆ°è¾¾
```

**è§£å†³æ–¹æ¡ˆ**ï¼šåŸºäºé•¿åº¦åˆ¤æ–­
```go
// 1. å…ˆPeekåŒ…å¤´ï¼ˆä¸ç§»åŠ¨è¯»æŒ‡é’ˆï¼‰
header, _ := buf.Peek(6)
if len(header) < 6 {
    return nil, io.ErrShortBuffer  // åŒ…å¤´ä¸å®Œæ•´
}

// 2. è§£æé•¿åº¦
length := binary.BigEndian.Uint32(header[2:6])

// 3. æ£€æŸ¥å®Œæ•´åŒ…æ˜¯å¦åˆ°è¾¾
if buf.Length() < int(6+length) {
    return nil, io.ErrShortBuffer  // åŒ…ä½“ä¸å®Œæ•´
}

// 4. å®Œæ•´åŒ…å·²åˆ°è¾¾ï¼Œå¼€å§‹è§£æ
```

---

### **C. å¤æ‚åœºæ™¯å¤„ç†**

**åœºæ™¯3ï¼šç²˜åŒ…+åŠåŒ…æ··åˆ**
```
ç¬¬1æ¬¡æ¥æ”¶ï¼š
[PINGå®Œæ•´åŒ…][SENDåŒ…çš„ä¸€åŠ]
 6å­—èŠ‚       50å­—èŠ‚

ç¬¬2æ¬¡æ¥æ”¶ï¼š
[SENDåŒ…çš„å¦ä¸€åŠ][PONGå®Œæ•´åŒ…]
 50å­—èŠ‚          6å­—èŠ‚

å¤„ç†æµç¨‹ï¼š
ç¬¬1æ¬¡onDataï¼š
â”œâ”€ è§£æPINGåŒ… â†’ æˆåŠŸï¼Œå¤„ç†
â”œâ”€ å°è¯•è§£æSENDåŒ… â†’ å¤±è´¥ï¼ˆåŠåŒ…ï¼‰ï¼Œè¿”å›ErrShortBuffer
â””â”€ SENDçš„ä¸€åŠä¿ç•™åœ¨InboundBufferä¸­

ç¬¬2æ¬¡onDataï¼š
â”œâ”€ InboundBufferä¸­æœ‰50å­—èŠ‚ï¼ˆä¸Šæ¬¡å‰©ä½™ï¼‰
â”œâ”€ æ–°è¯»å–56å­—èŠ‚ï¼Œæ€»å…±106å­—èŠ‚
â”œâ”€ è§£æSENDåŒ… â†’ æˆåŠŸï¼ˆ50+50=100ï¼‰ï¼Œå¤„ç†
â”œâ”€ è§£æPONGåŒ… â†’ æˆåŠŸï¼Œå¤„ç†
â””â”€ InboundBufferæ¸…ç©º
```

---

### **D. è¾¹ç•Œæ¡ä»¶**

**1. åˆšå¥½ä¸€ä¸ªå®Œæ•´åŒ…**
```
æ¥æ”¶ï¼š[PINGåŒ…] 6å­—èŠ‚

å¤„ç†ï¼š
â”œâ”€ Decode() â†’ æˆåŠŸ
â”œâ”€ Discard(6) â†’ InboundBufferæ¸…ç©º
â””â”€ breakï¼ˆIsEmpty()ä¸ºtrueï¼‰
```

---

**2. åªæ”¶åˆ°åŒ…å¤´**
```
æ¥æ”¶ï¼š[FrameType][Flag][Lengthçš„2å­—èŠ‚] 4å­—èŠ‚

å¤„ç†ï¼š
â”œâ”€ Peek(6) â†’ å¤±è´¥ï¼ˆåªæœ‰4å­—èŠ‚ï¼‰
â”œâ”€ è¿”å› ErrShortBuffer
â””â”€ ç­‰å¾…æ›´å¤šæ•°æ®
```

---

**3. æ”¶åˆ°åŒ…å¤´+éƒ¨åˆ†åŒ…ä½“**
```
æ¥æ”¶ï¼š
[FrameType][Flag][Length=100][Payloadå‰30å­—èŠ‚] 36å­—èŠ‚

å¤„ç†ï¼š
â”œâ”€ Peek(6) â†’ æˆåŠŸï¼ˆåŒ…å¤´å®Œæ•´ï¼‰
â”œâ”€ è§£æLength=100
â”œâ”€ Peek(106) â†’ å¤±è´¥ï¼ˆåªæœ‰36å­—èŠ‚ï¼‰
â”œâ”€ è¿”å› ErrShortBuffer
â””â”€ ç­‰å¾…æ›´å¤šæ•°æ®
```

---

**4. è¶…å¤§åŒ…å¤„ç†**
```
æ¥æ”¶ï¼š
Lengthå­—æ®µæ˜¾ç¤ºåŒ…ä½“æœ‰10MB

å¤„ç†ï¼š
â”œâ”€ æ£€æŸ¥Lengthæ˜¯å¦è¶…è¿‡é™åˆ¶
â”‚   if length > MaxPacketSize {
â”‚       return ErrPacketTooLarge
â”‚   }
â”œâ”€ å¦‚æœè¶…è¿‡ï¼Œæ‹’ç»å¤„ç†ï¼Œå…³é—­è¿æ¥
â””â”€ é˜²æ­¢æ¶æ„æ”»å‡»ï¼ˆå†…å­˜è€—å°½ï¼‰
```

---

## 4ï¸âƒ£ åè®®è§£ç å™¨å®ç°

### **A. Protocolç»“æ„**

**ä»£ç ä½ç½®**ï¼š`pkg/wkproto/protocol.go`

```go
type Protocol struct {
    MaxPacketSize uint32  // æœ€å¤§åŒ…å¤§å°ï¼ˆé»˜è®¤10MBï¼‰
}

func NewProtocol() *Protocol {
    return &Protocol{
        MaxPacketSize: 1024 * 1024 * 10,  // 10MB
    }
}
```

---

### **B. Decodeä¸»æµç¨‹** â­

```go
func (p *Protocol) Decode(conn Conn) (*Frame, error) {
    buf := conn.InboundBuffer()

    // ========== æ­¥éª¤1ï¼šè¯»å–åŒ…å¤´ ==========
    header, _ := buf.Peek(6)
    if len(header) < 6 {
        return nil, io.ErrShortBuffer
    }

    // ========== æ­¥éª¤2ï¼šè§£æåŒ…å¤´ ==========
    frameType := FrameType(header[0])
    flag := header[1]
    length := binary.BigEndian.Uint32(header[2:6])

    // ========== æ­¥éª¤3ï¼šæ ¡éªŒé•¿åº¦ ==========
    if length > p.MaxPacketSize {
        return nil, fmt.Errorf("packet too large: %d", length)
    }

    // ========== æ­¥éª¤4ï¼šæ£€æŸ¥å®Œæ•´åŒ… ==========
    totalLen := int(6 + length)
    if buf.Length() < totalLen {
        return nil, io.ErrShortBuffer
    }

    // ========== æ­¥éª¤5ï¼šè¯»å–å®Œæ•´åŒ… ==========
    fullPacket, _ := buf.Peek(totalLen)
    payload := fullPacket[6:]

    // ========== æ­¥éª¤6ï¼šæ ¹æ®ç±»å‹è§£ç åŒ…ä½“ ==========
    frame, err := p.decodePayload(frameType, flag, payload)
    if err != nil {
        return nil, err
    }

    // ========== æ­¥éª¤7ï¼šä¸¢å¼ƒå·²è§£ææ•°æ® ==========
    buf.Discard(totalLen)

    return frame, nil
}
```

---

### **C. åŒ…ä½“è§£ç åˆ†å‘**

```go
func (p *Protocol) decodePayload(
    frameType FrameType,
    flag uint8,
    payload []byte,
) (*Frame, error) {
    var frame *Frame
    var err error

    switch frameType {
    case CONNECT:
        frame, err = p.decodeConnect(payload)

    case CONNACK:
        frame, err = p.decodeConnack(payload)

    case SEND:
        frame, err = p.decodeSend(payload)

    case SENDACK:
        frame, err = p.decodeSendack(payload)

    case RECV:
        frame, err = p.decodeRecv(payload)

    case RECVACK:
        frame, err = p.decodeRecvack(payload)

    case PING:
        // PINGåŒ…æ— åŒ…ä½“
        frame = &Frame{
            FrameType: PING,
            Flag:      flag,
        }

    case PONG:
        // PONGåŒ…æ— åŒ…ä½“
        frame = &Frame{
            FrameType: PONG,
            Flag:      flag,
        }

    case SUB:
        frame, err = p.decodeSub(payload)

    case SUBACK:
        frame, err = p.decodeSuback(payload)

    case UNSUB:
        frame, err = p.decodeUnsub(payload)

    case UNSUBACK:
        frame, err = p.decodeUnsuback(payload)

    case DISCONNECT:
        frame, err = p.decodeDisconnect(payload)

    default:
        return nil, fmt.Errorf("unknown frame type: %d", frameType)
    }

    if err != nil {
        return nil, err
    }

    // è®¾ç½®é€šç”¨å­—æ®µ
    frame.FrameType = frameType
    frame.Flag = flag

    return frame, nil
}
```

---

### **D. å…·ä½“åŒ…ä½“è§£ç ç¤ºä¾‹**

#### **1. SENDåŒ…è§£ç **

**ä»£ç ä½ç½®**ï¼š`pkg/wkproto/send.go:decode()`

```go
func (p *Protocol) decodeSend(payload []byte) (*Frame, error) {
    if len(payload) < 4 {
        return nil, ErrInvalidPacket
    }

    pos := 0
    frame := &Frame{}

    // 1. è¯»å–Settingï¼ˆ1å­—èŠ‚ï¼‰
    setting := payload[pos]
    pos++

    // 2. è¯»å–ClientMsgNo
    clientMsgNoLen := int(payload[pos])
    pos++
    if len(payload) < pos+clientMsgNoLen {
        return nil, ErrInvalidPacket
    }
    clientMsgNo := string(payload[pos : pos+clientMsgNoLen])
    pos += clientMsgNoLen

    // 3. è¯»å–ChannelID
    channelIDLen := int(payload[pos])
    pos++
    if len(payload) < pos+channelIDLen {
        return nil, ErrInvalidPacket
    }
    channelID := string(payload[pos : pos+channelIDLen])
    pos += channelIDLen

    // 4. è¯»å–ChannelType
    channelType := payload[pos]
    pos++

    // 5. å‰©ä½™æ•°æ®ä¸ºPayload
    messagePayload := payload[pos:]

    // 6. æ„é€ Frame
    frame.Setting = setting
    frame.ClientMsgNo = clientMsgNo
    frame.ChannelID = channelID
    frame.ChannelType = channelType
    frame.Payload = messagePayload

    return frame, nil
}
```

**è§£ææ­¥éª¤**ï¼š
```
Payloadç»“æ„ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Setting â”‚ ClientMsgNoLenâ”‚ ClientMsgNoâ”‚ ChannelIDLen â”‚ ChannelID    â”‚ChannelTypeâ”‚ Payload
â”‚ 1å­—èŠ‚   â”‚ 1å­—èŠ‚         â”‚ Nå­—èŠ‚      â”‚ 1å­—èŠ‚        â”‚ Må­—èŠ‚        â”‚ 1å­—èŠ‚    â”‚ å‰©ä½™å­—èŠ‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  pos=0      pos=1          pos=2        pos=2+N        pos=3+N        pos=4+N+M

è§£ææµç¨‹ï¼š
1. pos=0: è¯»å–Setting
2. pos=1: è¯»å–ClientMsgNoLen=N
3. pos=2: è¯»å–ClientMsgNoï¼ˆNå­—èŠ‚ï¼‰
4. pos=2+N: è¯»å–ChannelIDLen=M
5. pos=3+N: è¯»å–ChannelIDï¼ˆMå­—èŠ‚ï¼‰
6. pos=4+N+M: è¯»å–ChannelType
7. pos=5+N+M: å‰©ä½™å­—èŠ‚ä¸ºPayload
```

---

#### **2. CONNECTåŒ…è§£ç **

```go
func (p *Protocol) decodeConnect(payload []byte) (*Frame, error) {
    if len(payload) < 15 {  // æœ€å°é•¿åº¦
        return nil, ErrInvalidPacket
    }

    pos := 0
    frame := &Frame{}

    // 1. ç‰ˆæœ¬å·ï¼ˆ1å­—èŠ‚ï¼‰
    version := payload[pos]
    pos++

    // 2. DeviceID
    deviceIDLen := int(binary.BigEndian.Uint16(payload[pos : pos+2]))
    pos += 2
    if len(payload) < pos+deviceIDLen {
        return nil, ErrInvalidPacket
    }
    deviceID := string(payload[pos : pos+deviceIDLen])
    pos += deviceIDLen

    // 3. UID
    uidLen := int(binary.BigEndian.Uint16(payload[pos : pos+2]))
    pos += 2
    if len(payload) < pos+uidLen {
        return nil, ErrInvalidPacket
    }
    uid := string(payload[pos : pos+uidLen])
    pos += uidLen

    // 4. Token
    tokenLen := int(binary.BigEndian.Uint16(payload[pos : pos+2]))
    pos += 2
    if len(payload) < pos+tokenLen {
        return nil, ErrInvalidPacket
    }
    token := string(payload[pos : pos+tokenLen])
    pos += tokenLen

    // 5. ClientTimestampï¼ˆ8å­—èŠ‚ï¼‰
    if len(payload) < pos+8 {
        return nil, ErrInvalidPacket
    }
    clientTimestamp := int64(binary.BigEndian.Uint64(payload[pos : pos+8]))

    // 6. æ„é€ Frame
    frame.Version = version
    frame.DeviceID = deviceID
    frame.UID = uid
    frame.Token = token
    frame.ClientTimestamp = clientTimestamp

    return frame, nil
}
```

---

## 5ï¸âƒ£ é”™è¯¯å¤„ç†ä¸æ¢å¤

### **A. é”™è¯¯ç±»å‹**

**1. æ•°æ®ä¸å®Œæ•´ï¼ˆå¯æ¢å¤ï¼‰**
```go
var ErrShortBuffer = errors.New("short buffer")

å¤„ç†ï¼š
â”œâ”€ ä¸ç§»åŠ¨è¯»æŒ‡é’ˆ
â”œâ”€ ç­‰å¾…æ›´å¤šæ•°æ®
â””â”€ ä¸‹æ¬¡onDataæ—¶ç»§ç»­è§£æ
```

---

**2. åè®®é”™è¯¯ï¼ˆä¸å¯æ¢å¤ï¼‰**
```go
var (
    ErrInvalidPacket   = errors.New("invalid packet")
    ErrPacketTooLarge  = errors.New("packet too large")
    ErrUnknownFrameType = errors.New("unknown frame type")
)

å¤„ç†ï¼š
â”œâ”€ è®°å½•é”™è¯¯æ—¥å¿—
â”œâ”€ å…³é—­è¿æ¥
â””â”€ è§¦å‘OnCloseå›è°ƒ
```

---

**3. å†…å­˜æº¢å‡ºï¼ˆé˜²æŠ¤ï¼‰**
```go
func (d *DefaultConn) overflowForInbound(n int) bool {
    currentSize := d.inboundBuffer.Length()
    maxSize := d.eg.options.MaxReadBufferSize  // 50MB

    if currentSize+n > maxSize {
        return true  // æº¢å‡º
    }
    return false
}

å¤„ç†ï¼š
â”œâ”€ æ‹’ç»è¯»å–
â”œâ”€ å…³é—­è¿æ¥
â””â”€ é˜²æ­¢å†…å­˜æ”»å‡»
```

---

### **B. é”™è¯¯æ¢å¤ç­–ç•¥**

**ç­–ç•¥1ï¼šè·³è¿‡é”™è¯¯åŒ…**
```go
// âŒ ä¸æ¨èï¼šå¯èƒ½å¯¼è‡´åç»­åŒ…é”™ä½
func skipInvalidPacket(buf *RingBuffer) {
    // è·³è¿‡å½“å‰å­—èŠ‚ï¼Œå°è¯•æ‰¾ä¸‹ä¸€ä¸ªæœ‰æ•ˆåŒ…å¤´
    buf.Discard(1)
}
```

---

**ç­–ç•¥2ï¼šå…³é—­è¿æ¥**
```go
// âœ… æ¨èï¼šåè®®é”™è¯¯æ—¶ç›´æ¥å…³é—­
func (s *Server) onData(conn Conn) error {
    frame, err := s.protocol.Decode(conn)
    if err != nil {
        if err == io.ErrShortBuffer {
            return nil  // ç­‰å¾…æ›´å¤šæ•°æ®
        }
        // åè®®é”™è¯¯ï¼Œå…³é—­è¿æ¥
        s.Error("decode error", zap.Error(err))
        return err  // å¯¼è‡´è¿æ¥å…³é—­
    }
    // ...
}
```

---

**ç­–ç•¥3ï¼šé™åˆ¶é‡è¯•æ¬¡æ•°**
```go
type Conn struct {
    decodeErrorCount atomic.Int32
    maxDecodeErrors  int  // é»˜è®¤3æ¬¡
}

func (s *Server) onData(conn Conn) error {
    frame, err := s.protocol.Decode(conn)
    if err != nil {
        if err == io.ErrShortBuffer {
            return nil
        }

        // å¢åŠ é”™è¯¯è®¡æ•°
        count := conn.decodeErrorCount.Add(1)
        if count > conn.maxDecodeErrors {
            // é”™è¯¯æ¬¡æ•°è¿‡å¤šï¼Œå…³é—­è¿æ¥
            return fmt.Errorf("too many decode errors")
        }

        // è·³è¿‡å½“å‰åŒ…ï¼Œå°è¯•æ¢å¤
        conn.InboundBuffer().Discard(1)
        return nil
    }

    // è§£ç æˆåŠŸï¼Œé‡ç½®é”™è¯¯è®¡æ•°
    conn.decodeErrorCount.Store(0)
    return s.handleFrame(conn, frame)
}
```

---

### **C. é˜²å¾¡æ€§ç¼–ç¨‹**

**1. é•¿åº¦æ ¡éªŒ**
```go
// æ¯æ¬¡è¯»å–å‰éƒ½æ£€æŸ¥é•¿åº¦
if len(payload) < expectedLen {
    return nil, ErrInvalidPacket
}
```

---

**2. è¾¹ç•Œæ£€æŸ¥**
```go
// è¯»å–å¯å˜é•¿åº¦å­—æ®µæ—¶
strLen := int(payload[pos])
pos++

// âŒ ä¸å®‰å…¨
str := string(payload[pos : pos+strLen])

// âœ… å®‰å…¨
if len(payload) < pos+strLen {
    return nil, ErrInvalidPacket
}
str := string(payload[pos : pos+strLen])
pos += strLen
```

---

**3. ç±»å‹æšä¸¾æ ¡éªŒ**
```go
func isValidFrameType(ft FrameType) bool {
    switch ft {
    case CONNECT, CONNACK, SEND, SENDACK,
         RECV, RECVACK, PING, PONG,
         SUB, SUBACK, UNSUB, UNSUBACK,
         DISCONNECT:
        return true
    default:
        return false
    }
}

// ä½¿ç”¨
if !isValidFrameType(frameType) {
    return nil, ErrUnknownFrameType
}
```

---

## 6ï¸âƒ£ æ€§èƒ½ä¼˜åŒ–æŠ€å·§

### **A. é›¶æ‹·è´è¯»å–**

**ä½¿ç”¨Peekè€Œä¸æ˜¯Read**
```go
// âŒ ä½æ•ˆï¼šæ‹·è´æ•°æ®
data := make([]byte, 6)
buf.Read(data)  // æ‹·è´6å­—èŠ‚

// âœ… é«˜æ•ˆï¼šé›¶æ‹·è´
data, _ := buf.Peek(6)  // è¿”å›åˆ‡ç‰‡ï¼Œæ— æ‹·è´
```

**Peekå®ç°**ï¼š
```go
func (r *RingBuffer) Peek(n int) ([]byte, []byte) {
    if r.size == 0 || n == 0 {
        return nil, nil
    }

    if r.head < r.tail {
        // æ•°æ®è¿ç»­
        end := r.head + n
        if end > r.tail {
            end = r.tail
        }
        return r.buf[r.head:end], nil  // ç›´æ¥è¿”å›åˆ‡ç‰‡
    }

    // æ•°æ®åˆ†ä¸¤æ®µ
    first := r.buf[r.head:]
    if len(first) >= n {
        return first[:n], nil
    }
    second := r.buf[:r.tail]
    return first, second  // è¿”å›ä¸¤ä¸ªåˆ‡ç‰‡
}
```

---

### **B. é¿å…å†…å­˜åˆ†é…**

**å¤ç”¨ç¼“å†²åŒº**
```go
type Protocol struct {
    // å¤ç”¨çš„ä¸´æ—¶ç¼“å†²åŒºï¼ˆå‡å°‘åˆ†é…ï¼‰
    tempBuf []byte
}

func (p *Protocol) decodeSend(payload []byte) (*Frame, error) {
    // ä½¿ç”¨ä¸´æ—¶ç¼“å†²åŒº
    if cap(p.tempBuf) < len(payload) {
        p.tempBuf = make([]byte, len(payload))
    }
    // ... ä½¿ç”¨tempBuf
}
```

---

**å­—ç¬¦ä¸²é›¶æ‹·è´è½¬æ¢**
```go
// âŒ æ‹·è´
str := string(payload[pos : pos+len])

// âœ… é›¶æ‹·è´ï¼ˆunsafeï¼Œéœ€è°¨æ…ï¼‰
import "unsafe"

func bytesToString(b []byte) string {
    return *(*string)(unsafe.Pointer(&b))
}

str := bytesToString(payload[pos : pos+len])
```

---

### **C. æ‰¹é‡è§£æ**

```go
func (s *Server) onData(conn Conn) error {
    frames := make([]*Frame, 0, 10)  // é¢„åˆ†é…

    // æ‰¹é‡è§£æ
    for {
        frame, err := s.protocol.Decode(conn)
        if err == io.ErrShortBuffer {
            break
        }
        if err != nil {
            return err
        }
        frames = append(frames, frame)

        // è¾¾åˆ°æ‰¹é‡å¤§å°ï¼Œæ‰¹é‡å¤„ç†
        if len(frames) >= 10 {
            s.handleFrames(frames)
            frames = frames[:0]  // é‡ç½®ï¼ˆå¤ç”¨åˆ‡ç‰‡ï¼‰
        }
    }

    // å¤„ç†å‰©ä½™å¸§
    if len(frames) > 0 {
        s.handleFrames(frames)
    }

    return nil
}
```

---

### **D. å¿«é€Ÿè·¯å¾„ä¼˜åŒ–**

```go
func (p *Protocol) Decode(conn Conn) (*Frame, error) {
    buf := conn.InboundBuffer()

    // ===== å¿«é€Ÿè·¯å¾„ï¼šPING/PONG =====
    // PINGå’ŒPONGæœ€å¸¸è§ï¼Œä¼˜å…ˆåˆ¤æ–­
    if buf.Length() >= 6 {
        header, _ := buf.Peek(6)
        frameType := FrameType(header[0])
        length := binary.BigEndian.Uint32(header[2:6])

        if length == 0 {  // æ— åŒ…ä½“
            if frameType == PING {
                buf.Discard(6)
                return &Frame{FrameType: PING}, nil
            }
            if frameType == PONG {
                buf.Discard(6)
                return &Frame{FrameType: PONG}, nil
            }
        }
    }

    // ===== æ…¢é€Ÿè·¯å¾„ï¼šå…¶ä»–åŒ…ç±»å‹ =====
    return p.decodeGeneric(conn)
}
```

---

### **E. æ€§èƒ½æµ‹è¯•**

**Benchmarkä»£ç **ï¼š
```go
func BenchmarkDecode(b *testing.B) {
    // å‡†å¤‡æµ‹è¯•æ•°æ®
    sendPacket := &SendPacket{
        ClientMsgNo: "msg001",
        ChannelID:   "channel001",
        ChannelType: 2,
        Payload:     []byte("Hello WuKongIM"),
    }
    data, _ := sendPacket.Encode()

    // åˆ›å»ºæµ‹è¯•è¿æ¥
    conn := newMockConn()
    conn.InboundBuffer().Write(data)

    protocol := NewProtocol()

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        conn.InboundBuffer().Write(data)
        protocol.Decode(conn)
    }
}
```

**æµ‹è¯•ç»“æœ**ï¼š
```
BenchmarkDecode-16    2,000,000    500 ns/op    64 B/op    2 allocs/op

æ€§èƒ½åˆ†æï¼š
â”œâ”€ è§£ç è€—æ—¶ï¼š500ns
â”œâ”€ å†…å­˜åˆ†é…ï¼š64å­—èŠ‚
â”œâ”€ åˆ†é…æ¬¡æ•°ï¼š2æ¬¡
â””â”€ ååé‡ï¼š200ä¸‡æ¬¡/ç§’
```

---

## 7ï¸âƒ£ æ€»ç»“

### **æ ¸å¿ƒè¦ç‚¹**

1. **è§£ææµç¨‹**
   - Layer 1ï¼šTCPè¯»å–å­—èŠ‚æµ
   - Layer 2ï¼šç²˜åŒ…/åŠåŒ…å¤„ç†
   - Layer 3ï¼šåè®®è§£æ
   - Layer 4ï¼šä¸šåŠ¡å¤„ç†

2. **ç²˜åŒ…/åŠåŒ…å¤„ç†**
   - åŸºäºé•¿åº¦å­—æ®µåˆ†å¸§
   - Peeké¢„è§ˆæ•°æ®ï¼ˆä¸ç§»åŠ¨æŒ‡é’ˆï¼‰
   - è¿”å›ErrShortBufferç­‰å¾…
   - å¾ªç¯è§£æå¤„ç†ç²˜åŒ…

3. **é”™è¯¯å¤„ç†**
   - æ•°æ®ä¸å®Œæ•´ï¼šç­‰å¾…æ¢å¤
   - åè®®é”™è¯¯ï¼šå…³é—­è¿æ¥
   - å†…å­˜æº¢å‡ºï¼šé˜²æŠ¤æœºåˆ¶
   - é™åˆ¶é‡è¯•ï¼šé˜²æ­¢æ”»å‡»

4. **æ€§èƒ½ä¼˜åŒ–**
   - é›¶æ‹·è´ï¼šPeek + åˆ‡ç‰‡å¼•ç”¨
   - é¿å…åˆ†é…ï¼šå¤ç”¨ç¼“å†²åŒº
   - æ‰¹é‡å¤„ç†ï¼šå‡å°‘è°ƒç”¨æ¬¡æ•°
   - å¿«é€Ÿè·¯å¾„ï¼šä¼˜åŒ–å¸¸è§case

---

### **æœ€ä½³å®è·µ**

```
âœ… ä½¿ç”¨Ring Bufferï¼ˆé«˜æ•ˆç¼“å†²ï¼‰
âœ… Peekä¸Readï¼ˆé›¶æ‹·è´ï¼‰
âœ… é•¿åº¦æ ¡éªŒï¼ˆé˜²å¾¡ç¼–ç¨‹ï¼‰
âœ… è¾¹ç•Œæ£€æŸ¥ï¼ˆå®‰å…¨ç¬¬ä¸€ï¼‰
âœ… å¾ªç¯è§£æï¼ˆå¤„ç†ç²˜åŒ…ï¼‰
âœ… è¿”å›ErrShortBufferï¼ˆå¤„ç†åŠåŒ…ï¼‰
âœ… é™åˆ¶åŒ…å¤§å°ï¼ˆé˜²æ­¢æ”»å‡»ï¼‰
âœ… è®°å½•é”™è¯¯æ—¥å¿—ï¼ˆä¾¿äºæ’æŸ¥ï¼‰
```

---

### **ä¸‹ä¸€èŠ‚é¢„å‘Š**

**4.3 WebSocketæ”¯æŒ**
- WebSocketæ¡æ‰‹æµç¨‹
- WebSocket Frameå°è£…
- JSONåè®®æ”¯æŒ
- äºŒè¿›åˆ¶ä¸æ–‡æœ¬åè®®å…¼å®¹

---

> **ğŸ”— ç›¸å…³ä»£ç **ï¼š
> - åè®®è§£æï¼š`pkg/wkproto/protocol.go`
> - æ•°æ®è¯»å–ï¼š`pkg/wknet/conn.go:209-224`
> - æ•°æ®å¤„ç†ï¼š`internal/server/server.go:619-652`
> - Ring Bufferï¼š`pkg/ring/ring.go`
> - SENDè§£ç ï¼š`pkg/wkproto/send.go:decode()`
> - CONNECTè§£ç ï¼š`pkg/wkproto/connect.go:decode()`
