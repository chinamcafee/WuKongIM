# 4.3 WebSocket 支持

> **本节目标**：深入理解WuKongIM的WebSocket支持实现，掌握WebSocket协议与二进制协议的融合设计

---

## 📋 目录
1. [WebSocket概述](#websocket概述)
2. [WebSocket握手流程](#websocket握手流程)
3. [WebSocket Frame封装](#websocket-frame封装)
4. [JSON协议支持](#json协议支持)
5. [二进制与文本兼容](#二进制与文本兼容)
6. [性能对比与优化](#性能对比与优化)

---

## 1️⃣ WebSocket 概述

### **A. 为什么需要WebSocket？**

**传统HTTP的问题**：
```
HTTP轮询（Polling）：
客户端每隔1秒请求一次
    ↓
GET /messages HTTP/1.1
    ↓
服务端响应（可能无新消息）
    ↓
1秒后再次请求...

问题：
├─ 大量无效请求（浪费带宽）
├─ 延迟高（最多1秒延迟）
├─ 服务端压力大（每秒N个HTTP连接）
└─ 无法推送（只能被动拉取）
```

---

**WebSocket的优势**：
```
WebSocket长连接：
客户端建立连接
    ↓
升级为WebSocket
    ↓
保持连接
    ↓
双向实时通信
    ↓
服务端主动推送
    ↓
客户端实时接收

优点：
✅ 实时性（毫秒级延迟）
✅ 低开销（无HTTP头）
✅ 双向通信（全双工）
✅ 主动推送（服务端驱动）
✅ 跨域支持（CORS友好）
```

---

### **B. WebSocket vs TCP**

| 特性 | TCP | WebSocket |
|------|-----|-----------|
| **协议层** | 传输层 | 应用层 |
| **握手** | 三次握手 | HTTP升级 |
| **浏览器支持** | 否 | 是 ✅ |
| **跨域** | 无跨域概念 | 支持CORS ✅ |
| **防火墙** | 可能被拦截 | 使用80/443端口 ✅ |
| **调试** | 需要专用工具 | 浏览器DevTools ✅ |
| **性能** | 最优 | 略低（有协议开销） |

**WuKongIM的选择**：
```
同时支持：
├─ TCP：移动端SDK（性能优先）
├─ WebSocket：Web浏览器（兼容性优先）
└─ 统一协议（内部都转为WuKongIM协议）
```

---

### **C. WuKongIM的WebSocket架构**

```
┌─────────────────────────────────────────────┐
│  Web浏览器 / 小程序                          │
└─────────────────────────────────────────────┘
                    ↓ WebSocket
┌─────────────────────────────────────────────┐
│  WuKongIM WebSocket Listener (5200端口)      │
├─────────────────────────────────────────────┤
│  ├─ WebSocket握手                            │
│  ├─ WebSocket Frame解封装                    │
│  ├─ JSON ↔ 二进制协议转换                     │
│  └─ 统一接入Reactor事件循环                   │
└─────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────┐
│  统一的WuKongIM协议处理                       │
│  （与TCP客户端共享同一套逻辑）                 │
└─────────────────────────────────────────────┘
```

---

## 2️⃣ WebSocket 握手流程

### **A. 握手请求**

**HTTP升级请求**：
```http
GET /ws HTTP/1.1
Host: localhost:5200
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13
Sec-WebSocket-Protocol: wukongim
Origin: http://localhost:3000
```

**关键字段**：
```
Upgrade: websocket
  └─ 请求升级协议

Connection: Upgrade
  └─ 连接升级

Sec-WebSocket-Key: 随机字符串（Base64）
  └─ 防止缓存代理攻击

Sec-WebSocket-Version: 13
  └─ WebSocket协议版本

Sec-WebSocket-Protocol: wukongim
  └─ 子协议（可选）
```

---

### **B. 握手响应**

**服务端响应**：
```http
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
Sec-WebSocket-Protocol: wukongim
```

**关键字段**：
```
HTTP/1.1 101 Switching Protocols
  └─ 状态码101：协议切换

Sec-WebSocket-Accept: 计算值
  └─ SHA-1(Sec-WebSocket-Key + GUID)
  └─ 验证握手成功

计算公式：
key = "dGhlIHNhbXBsZSBub25jZQ=="
guid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"
accept = base64(sha1(key + guid))
```

---

### **C. WuKongIM握手实现**

**代码位置**：`pkg/wknet/ws_conn.go`

```go
type WSConn struct {
    *DefaultConn              // 嵌入默认连接
    upgrader     *websocket.Upgrader  // WebSocket升级器
}

func NewWSConn(
    id int64,
    fd NetFd,
    localAddr, remoteAddr net.Addr,
    engine *Engine,
    reactorSub *ReactorSub,
) (*WSConn, error) {
    // 1. 创建基础连接
    conn := &WSConn{
        DefaultConn: &DefaultConn{},
    }
    conn.init(fd, localAddr, remoteAddr, engine, reactorSub, id)

    // 2. 创建WebSocket Upgrader
    conn.upgrader = &websocket.Upgrader{
        CheckOrigin: func(r *http.Request) bool {
            // 允许所有来源（生产环境应限制）
            return true
        },
        Subprotocols: []string{"wukongim"},
    }

    // 3. 执行握手
    err := conn.handshake()
    if err != nil {
        return nil, err
    }

    return conn, nil
}
```

---

**握手流程**：
```go
func (w *WSConn) handshake() error {
    // 1. 从socket读取HTTP请求
    request, err := http.ReadRequest(bufio.NewReader(w.fd))
    if err != nil {
        return err
    }

    // 2. 检查升级请求
    if !isWebSocketUpgrade(request) {
        return errors.New("not a websocket upgrade request")
    }

    // 3. 验证Sec-WebSocket-Key
    key := request.Header.Get("Sec-WebSocket-Key")
    if key == "" {
        return errors.New("missing Sec-WebSocket-Key")
    }

    // 4. 计算Sec-WebSocket-Accept
    accept := computeAcceptKey(key)

    // 5. 构造响应
    response := buildUpgradeResponse(accept)

    // 6. 发送响应
    _, err = w.fd.Write([]byte(response))
    if err != nil {
        return err
    }

    // 7. 握手完成，连接升级为WebSocket
    w.upgraded = true

    return nil
}
```

---

**辅助函数**：
```go
func isWebSocketUpgrade(r *http.Request) bool {
    return r.Header.Get("Upgrade") == "websocket" &&
           r.Header.Get("Connection") == "Upgrade"
}

func computeAcceptKey(key string) string {
    const guid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"
    h := sha1.New()
    h.Write([]byte(key + guid))
    return base64.StdEncoding.EncodeToString(h.Sum(nil))
}

func buildUpgradeResponse(accept string) string {
    return "HTTP/1.1 101 Switching Protocols\r\n" +
           "Upgrade: websocket\r\n" +
           "Connection: Upgrade\r\n" +
           "Sec-WebSocket-Accept: " + accept + "\r\n" +
           "Sec-WebSocket-Protocol: wukongim\r\n" +
           "\r\n"
}
```

---

## 3️⃣ WebSocket Frame 封装

### **A. WebSocket帧格式**

**RFC 6455 定义**：
```
WebSocket Frame结构：

  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-------+-+-------------+-------------------------------+
 |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
 |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
 |N|V|V|V|       |S|             |   (if payload len==126/127)   |
 | |1|2|3|       |K|             |                               |
 +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
 |     Extended payload length continued, if payload len == 127  |
 + - - - - - - - - - - - - - - - +-------------------------------+
 |                               |Masking-key, if MASK set to 1  |
 +-------------------------------+-------------------------------+
 | Masking-key (continued)       |          Payload Data         |
 +-------------------------------- - - - - - - - - - - - - - - - +
 :                     Payload Data continued ...                :
 + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
 |                     Payload Data continued ...                |
 +---------------------------------------------------------------+
```

**字段说明**：
```
FIN (1 bit)：是否最后一帧
  ├─ 1: 最后一帧
  └─ 0: 还有后续帧（分片）

RSV1-3 (3 bits)：预留（扩展用）

Opcode (4 bits)：帧类型
  ├─ 0x0: 继续帧
  ├─ 0x1: 文本帧（UTF-8）
  ├─ 0x2: 二进制帧
  ├─ 0x8: 关闭帧
  ├─ 0x9: PING帧
  └─ 0xA: PONG帧

MASK (1 bit)：是否掩码
  ├─ 客户端→服务端：必须为1
  └─ 服务端→客户端：必须为0

Payload length (7/7+16/7+64 bits)：负载长度
  ├─ 0-125: 直接表示长度
  ├─ 126: 后续2字节表示长度
  └─ 127: 后续8字节表示长度

Masking-key (0/4 bytes)：掩码密钥
  └─ MASK=1时存在

Payload Data：实际数据
```

---

### **B. WuKongIM协议封装**

**WuKongIM Frame → WebSocket Frame**

```
发送流程（服务端→客户端）：

1. WuKongIM Frame（二进制）
   ┌──────────────────────────────────┐
   │ FrameType(1) + Flag(1) + Len(4)  │
   │ + Payload                        │
   └──────────────────────────────────┘
           ↓
2. 封装为WebSocket Frame
   ┌──────────────────────────────────┐
   │ FIN=1, Opcode=0x2（二进制）       │
   │ MASK=0（服务端不掩码）            │
   │ Payload = WuKongIM Frame         │
   └──────────────────────────────────┘
           ↓
3. 发送到socket
```

---

**代码实现**：
```go
func (w *WSConn) Write(data []byte) (int, error) {
    // 1. 构造WebSocket Frame头
    header := make([]byte, 10)  // 最大头部长度
    pos := 0

    // FIN=1, Opcode=0x2（二进制帧）
    header[pos] = 0x82  // 1000 0010
    pos++

    // Payload长度
    dataLen := len(data)
    if dataLen <= 125 {
        header[pos] = byte(dataLen)
        pos++
    } else if dataLen <= 65535 {
        header[pos] = 126
        pos++
        binary.BigEndian.PutUint16(header[pos:], uint16(dataLen))
        pos += 2
    } else {
        header[pos] = 127
        pos++
        binary.BigEndian.PutUint64(header[pos:], uint64(dataLen))
        pos += 8
    }

    // 2. 发送WebSocket Frame
    // 先发送头部
    _, err := w.fd.Write(header[:pos])
    if err != nil {
        return 0, err
    }

    // 再发送数据
    n, err := w.fd.Write(data)
    return n, err
}
```

---

### **C. WebSocket Frame解封装**

**WebSocket Frame → WuKongIM Frame**

```
接收流程（客户端→服务端）：

1. 接收WebSocket Frame
   ┌──────────────────────────────────┐
   │ FIN=1, Opcode=0x2（二进制）       │
   │ MASK=1（客户端必须掩码）          │
   │ Masking-key: [k0, k1, k2, k3]    │
   │ Payload: 掩码后的数据             │
   └──────────────────────────────────┘
           ↓
2. 解掩码
   for i := 0; i < len(payload); i++ {
       payload[i] ^= maskingKey[i % 4]
   }
           ↓
3. 提取WuKongIM Frame
   ┌──────────────────────────────────┐
   │ FrameType(1) + Flag(1) + Len(4)  │
   │ + Payload                        │
   └──────────────────────────────────┘
           ↓
4. 正常协议解析
```

---

**代码实现**：
```go
func (w *WSConn) ReadToInboundBuffer() (int, error) {
    // 1. 读取WebSocket Frame头
    header := make([]byte, 2)
    _, err := io.ReadFull(w.fd, header)
    if err != nil {
        return 0, err
    }

    // 2. 解析FIN和Opcode
    fin := (header[0] & 0x80) != 0
    opcode := header[0] & 0x0F

    // 3. 解析MASK和长度
    masked := (header[1] & 0x80) != 0
    payloadLen := int(header[1] & 0x7F)

    // 4. 读取扩展长度
    if payloadLen == 126 {
        buf := make([]byte, 2)
        io.ReadFull(w.fd, buf)
        payloadLen = int(binary.BigEndian.Uint16(buf))
    } else if payloadLen == 127 {
        buf := make([]byte, 8)
        io.ReadFull(w.fd, buf)
        payloadLen = int(binary.BigEndian.Uint64(buf))
    }

    // 5. 读取掩码密钥
    var maskingKey [4]byte
    if masked {
        io.ReadFull(w.fd, maskingKey[:])
    }

    // 6. 读取负载数据
    payload := make([]byte, payloadLen)
    _, err = io.ReadFull(w.fd, payload)
    if err != nil {
        return 0, err
    }

    // 7. 解掩码
    if masked {
        for i := 0; i < payloadLen; i++ {
            payload[i] ^= maskingKey[i%4]
        }
    }

    // 8. 处理不同Opcode
    switch opcode {
    case 0x1:  // 文本帧
        return w.handleTextFrame(payload)
    case 0x2:  // 二进制帧
        return w.handleBinaryFrame(payload)
    case 0x8:  // 关闭帧
        return 0, io.EOF
    case 0x9:  // PING帧
        return w.handlePing(payload)
    case 0xA:  // PONG帧
        return w.handlePong(payload)
    default:
        return 0, fmt.Errorf("unknown opcode: %d", opcode)
    }
}
```

---

**二进制帧处理**：
```go
func (w *WSConn) handleBinaryFrame(payload []byte) (int, error) {
    // 二进制帧直接是WuKongIM协议
    // 写入InboundBuffer，后续按正常流程解析
    n, err := w.inboundBuffer.Write(payload)
    return n, err
}
```

---

## 4️⃣ JSON 协议支持

### **A. 为什么支持JSON？**

```
场景：
├─ Web浏览器调试（Chrome DevTools）
├─ 快速原型开发（无需编解码）
├─ 跨语言兼容（JavaScript友好）
└─ 第三方集成（Webhook回调）

优点：
✅ 可读性强
✅ 调试方便
✅ 广泛支持

缺点：
❌ 体积大（比二进制大2-3倍）
❌ 解析慢（比二进制慢10倍+）
❌ 内存分配多
```

---

### **B. JSON与二进制对照**

**示例：SEND消息**

**二进制格式**：
```
┌────────┬────────┬────────────┬─────────────────────────┐
│ 0x02   │ 0x00   │ 0x00000050 │ Setting+ClientMsgNo+... │
│ SEND   │ Flag   │ Length=80  │ Payload                 │
└────────┴────────┴────────────┴─────────────────────────┘
总大小：86字节
```

---

**JSON格式**：
```json
{
  "frame_type": "SEND",
  "flag": 0,
  "setting": 0,
  "client_msg_no": "msg001",
  "channel_id": "channel001",
  "channel_type": 2,
  "payload": "Hello WuKongIM"
}

总大小：约150字节（比二进制大75%）
```

---

### **C. JSON协议实现**

**文本帧处理**：
```go
func (w *WSConn) handleTextFrame(payload []byte) (int, error) {
    // 1. 解析JSON
    var jsonFrame JSONFrame
    err := json.Unmarshal(payload, &jsonFrame)
    if err != nil {
        return 0, err
    }

    // 2. 转换为二进制Frame
    binaryFrame, err := jsonFrameToBinary(&jsonFrame)
    if err != nil {
        return 0, err
    }

    // 3. 编码为二进制协议
    data, err := binaryFrame.Encode()
    if err != nil {
        return 0, err
    }

    // 4. 写入InboundBuffer
    n, err := w.inboundBuffer.Write(data)
    return n, err
}
```

---

**JSONFrame定义**：
```go
type JSONFrame struct {
    FrameType    string `json:"frame_type"`    // "SEND", "RECV", etc.
    Flag         uint8  `json:"flag"`
    Setting      uint8  `json:"setting,omitempty"`
    ClientMsgNo  string `json:"client_msg_no,omitempty"`
    ChannelID    string `json:"channel_id,omitempty"`
    ChannelType  uint8  `json:"channel_type,omitempty"`
    Payload      string `json:"payload,omitempty"`      // Base64编码
    // ... 其他字段
}
```

---

**JSON→二进制转换**：
```go
func jsonFrameToBinary(jf *JSONFrame) (*Frame, error) {
    frame := &Frame{}

    // 1. 转换FrameType
    switch jf.FrameType {
    case "CONNECT":
        frame.FrameType = CONNECT
    case "SEND":
        frame.FrameType = SEND
    case "RECV":
        frame.FrameType = RECV
    case "PING":
        frame.FrameType = PING
    case "PONG":
        frame.FrameType = PONG
    // ... 其他类型
    default:
        return nil, fmt.Errorf("unknown frame type: %s", jf.FrameType)
    }

    // 2. 复制其他字段
    frame.Flag = jf.Flag
    frame.Setting = jf.Setting
    frame.ClientMsgNo = jf.ClientMsgNo
    frame.ChannelID = jf.ChannelID
    frame.ChannelType = jf.ChannelType

    // 3. 解码Base64 Payload
    if jf.Payload != "" {
        payload, err := base64.StdEncoding.DecodeString(jf.Payload)
        if err != nil {
            return nil, err
        }
        frame.Payload = payload
    }

    return frame, nil
}
```

---

**二进制→JSON转换**：
```go
func binaryFrameToJSON(bf *Frame) (*JSONFrame, error) {
    jf := &JSONFrame{}

    // 1. 转换FrameType
    jf.FrameType = bf.FrameType.String()  // "SEND"

    // 2. 复制其他字段
    jf.Flag = bf.Flag
    jf.Setting = bf.Setting
    jf.ClientMsgNo = bf.ClientMsgNo
    jf.ChannelID = bf.ChannelID
    jf.ChannelType = bf.ChannelType

    // 3. Base64编码Payload
    if len(bf.Payload) > 0 {
        jf.Payload = base64.StdEncoding.EncodeToString(bf.Payload)
    }

    return jf, nil
}
```

---

### **D. 自动协议检测**

```go
func (w *WSConn) handleTextFrame(payload []byte) (int, error) {
    // 尝试解析为JSON
    if json.Valid(payload) {
        return w.handleJSONProtocol(payload)
    }

    // 否则当作文本消息
    return w.handleTextMessage(payload)
}

func (w *WSConn) handleBinaryFrame(payload []byte) (int, error) {
    // 检查是否为WuKongIM二进制协议
    if isWuKongIMProtocol(payload) {
        return w.handleBinaryProtocol(payload)
    }

    // 否则当作二进制消息
    return w.handleBinaryMessage(payload)
}

func isWuKongIMProtocol(data []byte) bool {
    if len(data) < 6 {
        return false
    }

    // 检查FrameType是否有效
    frameType := FrameType(data[0])
    return isValidFrameType(frameType)
}
```

---

## 5️⃣ 二进制与文本兼容

### **A. 协议协商**

**客户端指定协议**：
```javascript
// JavaScript WebSocket客户端

// 方式1：使用二进制协议
const ws = new WebSocket('ws://localhost:5200/ws', 'wukongim-binary');
ws.binaryType = 'arraybuffer';

// 发送二进制Frame
const frame = new Uint8Array([0x02, 0x00, 0x00, 0x00, 0x00, 0x50, ...]);
ws.send(frame);

// 方式2：使用JSON协议
const ws = new WebSocket('ws://localhost:5200/ws', 'wukongim-json');

// 发送JSON Frame
const frame = {
    frame_type: "SEND",
    channel_id: "channel001",
    channel_type: 2,
    payload: btoa("Hello WuKongIM")  // Base64编码
};
ws.send(JSON.stringify(frame));
```

---

### **B. 服务端适配**

```go
type WSConn struct {
    *DefaultConn
    protocol string  // "binary" or "json"
}

func NewWSConn(...) (*WSConn, error) {
    // ... 握手逻辑

    // 1. 从握手请求中获取子协议
    protocol := request.Header.Get("Sec-WebSocket-Protocol")

    conn := &WSConn{
        DefaultConn: &DefaultConn{},
        protocol:    protocol,
    }

    // 2. 根据协议选择处理方式
    if protocol == "wukongim-json" {
        conn.useJSONProtocol = true
    } else {
        conn.useJSONProtocol = false  // 默认二进制
    }

    return conn, nil
}
```

---

**读取处理**：
```go
func (w *WSConn) handleTextFrame(payload []byte) (int, error) {
    if w.useJSONProtocol {
        // JSON协议：解析JSON并转换为二进制
        return w.handleJSONFrame(payload)
    } else {
        // 文本消息（直接当作字符串）
        return w.handleTextMessage(payload)
    }
}

func (w *WSConn) handleBinaryFrame(payload []byte) (int, error) {
    if w.useJSONProtocol {
        // JSON协议可能用二进制传输（罕见）
        return w.handleJSONFrame(payload)
    } else {
        // 二进制协议：直接写入InboundBuffer
        return w.inboundBuffer.Write(payload)
    }
}
```

---

**写入处理**：
```go
func (w *WSConn) Write(data []byte) (int, error) {
    if w.useJSONProtocol {
        // 1. 解析二进制Frame
        frame, err := Decode(data)
        if err != nil {
            return 0, err
        }

        // 2. 转换为JSON
        jsonFrame, err := binaryFrameToJSON(frame)
        if err != nil {
            return 0, err
        }

        // 3. 序列化JSON
        jsonData, err := json.Marshal(jsonFrame)
        if err != nil {
            return 0, err
        }

        // 4. 发送文本帧
        return w.sendTextFrame(jsonData)
    } else {
        // 发送二进制帧
        return w.sendBinaryFrame(data)
    }
}
```

---

### **C. 混合使用场景**

**场景1：调试时用JSON，生产用二进制**
```javascript
// 开发环境
const protocol = (process.env.NODE_ENV === 'development')
    ? 'wukongim-json'
    : 'wukongim-binary';

const ws = new WebSocket('ws://localhost:5200/ws', protocol);
```

---

**场景2：浏览器用JSON，移动端用二进制**
```javascript
// 浏览器检测
const isMobile = /Android|iPhone|iPad/.test(navigator.userAgent);
const protocol = isMobile ? 'wukongim-binary' : 'wukongim-json';
```

---

## 6️⃣ 性能对比与优化

### **A. 性能测试**

**测试环境**：
```
场景：发送1000条消息
消息内容："Hello WuKongIM"（15字节）
```

**测试结果**：

| 协议 | 单条大小 | 总带宽 | 编码耗时 | 解码耗时 |
|------|---------|--------|---------|---------|
| **TCP二进制** | 66字节 | 66KB | 200ns | 150ns |
| **WebSocket二进制** | 72字节 | 72KB | 250ns | 200ns |
| **WebSocket JSON** | 150字节 | 150KB | 2500ns | 3000ns |

**结论**：
```
带宽对比：
├─ WS JSON比WS二进制：多108% (150/72-1)
└─ WS二进制比TCP：多9% (72/66-1)

性能对比：
├─ WS JSON编码慢10倍
├─ WS JSON解码慢15倍
└─ WebSocket头部开销6字节（可接受）
```

---

### **B. WebSocket优化技巧**

**1. 启用压缩扩展**
```go
upgrader := &websocket.Upgrader{
    EnableCompression: true,  // 启用permessage-deflate
}

效果：
├─ 文本消息压缩率：50-70%
├─ JSON协议受益明显
└─ 二进制协议效果一般
```

---

**2. 批量发送**
```javascript
// ❌ 低效：逐条发送
messages.forEach(msg => {
    ws.send(JSON.stringify(msg));
});

// ✅ 高效：批量发送
const batch = messages.map(msg => JSON.stringify(msg));
ws.send(JSON.stringify(batch));

服务端收到后拆分：
[
    {"frame_type": "SEND", ...},
    {"frame_type": "SEND", ...},
    {"frame_type": "SEND", ...}
]
```

---

**3. 复用缓冲区**
```go
type WSConn struct {
    // 复用的WebSocket帧缓冲区
    frameHeaderBuf [14]byte  // 最大帧头
    frameBuf       []byte    // 帧数据缓冲
}

func (w *WSConn) sendBinaryFrame(data []byte) (int, error) {
    // 复用frameBuf
    if cap(w.frameBuf) < len(data)+14 {
        w.frameBuf = make([]byte, len(data)+14)
    }
    w.frameBuf = w.frameBuf[:0]

    // 使用复用缓冲区构造帧
    w.frameBuf = append(w.frameBuf, w.frameHeaderBuf[...]...)
    w.frameBuf = append(w.frameBuf, data...)

    return w.fd.Write(w.frameBuf)
}
```

---

**4. 心跳优化**
```javascript
// ❌ 低效：发送完整JSON
setInterval(() => {
    ws.send(JSON.stringify({frame_type: "PING"}));
}, 30000);

// ✅ 高效：发送WebSocket PING帧
setInterval(() => {
    ws.send(new Uint8Array([0x89, 0x00]));  // WebSocket PING
}, 30000);

// 服务端自动回复WebSocket PONG，无需应用层处理
```

---

### **C. 最佳实践建议**

```
协议选择：
├─ 移动端Native SDK：TCP二进制（性能最优）
├─ Web生产环境：WebSocket二进制（平衡）
└─ 开发调试：WebSocket JSON（易调试）

优化方向：
✅ 启用WebSocket压缩（文本协议）
✅ 批量发送（减少帧数）
✅ 复用缓冲区（减少分配）
✅ 使用WebSocket心跳（减少应用层开销）
❌ 避免频繁小包（合并发送）
❌ 避免过大单帧（分片传输）
```

---

## 7️⃣ 总结

### **核心要点**

1. **WebSocket优势**
   - 浏览器原生支持
   - 双向实时通信
   - 跨域友好
   - 调试方便

2. **握手流程**
   - HTTP升级请求
   - Sec-WebSocket-Key计算
   - 101协议切换
   - 连接建立

3. **Frame封装**
   - WuKongIM协议作为Payload
   - 封装为WebSocket帧
   - 掩码处理（客户端→服务端）
   - Opcode区分文本/二进制

4. **协议兼容**
   - 支持二进制协议（性能）
   - 支持JSON协议（调试）
   - 自动协议检测
   - 统一内部处理

5. **性能对比**
   - WebSocket比TCP慢10%（可接受）
   - JSON比二进制慢10倍（仅调试用）
   - 压缩可减少50%带宽
   - 批量发送提升吞吐

---

### **设计亮点**

| 特性 | 说明 |
|------|------|
| **协议转换** | WebSocket与TCP统一为WuKongIM协议 |
| **双协议支持** | 二进制（性能）+ JSON（调试） |
| **自动检测** | 根据帧类型自动选择解析方式 |
| **零修改** | 业务层无需感知WebSocket |
| **灵活切换** | 客户端可自由选择协议 |

---

### **下一章预告**

**第五章：EventBus事件总线**
- 事件驱动架构设计
- 三大事件池详解
- 事件处理链机制
- 核心事件解析

---

> **🔗 相关代码**：
> - WebSocket连接：`pkg/wknet/ws_conn.go`
> - WebSocket握手：`pkg/wknet/ws_upgrade.go`
> - JSON协议：`pkg/wkproto/json.go`
> - Frame封装：`pkg/wknet/ws_frame.go`
> - 协议转换：`pkg/wkproto/convert.go`
