# 5.3 äº‹ä»¶å¤„ç†é“¾

> **æœ¬èŠ‚ç›®æ ‡**ï¼šæ·±å…¥ç†è§£äº‹ä»¶å¤„ç†é“¾çš„å·¥ä½œæœºåˆ¶ï¼ŒæŒæ¡è´£ä»»é“¾æ¨¡å¼åœ¨WuKongIMä¸­çš„åº”ç”¨

---

## ğŸ“‹ ç›®å½•
1. [äº‹ä»¶å¤„ç†é“¾æ¦‚è¿°](#äº‹ä»¶å¤„ç†é“¾æ¦‚è¿°)
2. [äº‹ä»¶ç”Ÿæˆæœºåˆ¶](#äº‹ä»¶ç”Ÿæˆæœºåˆ¶)
3. [äº‹ä»¶å…¥é˜Ÿæµç¨‹](#äº‹ä»¶å…¥é˜Ÿæµç¨‹)
4. [äº‹ä»¶è·¯ç”±æœºåˆ¶](#äº‹ä»¶è·¯ç”±æœºåˆ¶)
5. [Handlerè´£ä»»é“¾æ¨¡å¼](#handlerè´£ä»»é“¾æ¨¡å¼)
6. [äº‹ä»¶è½¬å‘ä¸è·¨èŠ‚ç‚¹é€šä¿¡](#äº‹ä»¶è½¬å‘ä¸è·¨èŠ‚ç‚¹é€šä¿¡)

---

## 1ï¸âƒ£ äº‹ä»¶å¤„ç†é“¾æ¦‚è¿°

### **A. å®Œæ•´å¤„ç†é“¾è·¯**

```
äº‹ä»¶å¤„ç†å®Œæ•´æµç¨‹ï¼š

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Step 1: äº‹ä»¶è§¦å‘                                     â”‚
â”‚  â”œâ”€ ç½‘ç»œæ•°æ®åˆ°è¾¾                                      â”‚
â”‚  â”œâ”€ ç”¨æˆ·æ“ä½œ                                         â”‚
â”‚  â””â”€ å®šæ—¶ä»»åŠ¡                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Step 2: äº‹ä»¶ç”Ÿæˆ                                     â”‚
â”‚  â”œâ”€ å°è£…äº‹ä»¶ä¸Šä¸‹æ–‡ï¼ˆUserContext/ChannelContextç­‰ï¼‰    â”‚
â”‚  â”œâ”€ è®¾ç½®äº‹ä»¶ç±»å‹ï¼ˆEventTypeï¼‰                         â”‚
â”‚  â””â”€ å¡«å……äº‹ä»¶æ•°æ®                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Step 3: äº‹ä»¶å…¥é˜Ÿ                                     â”‚
â”‚  â”œâ”€ é€‰æ‹©äº‹ä»¶æ± ï¼ˆUser/Channel/Pusherï¼‰                 â”‚
â”‚  â”œâ”€ å†™å…¥äº‹ä»¶é˜Ÿåˆ—                                      â”‚
â”‚  â””â”€ è§¦å‘å¤„ç†                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Step 4: äº‹ä»¶è·¯ç”±                                     â”‚
â”‚  â”œâ”€ æ ¹æ®EventTypeæŸ¥æ‰¾Handleråˆ—è¡¨                      â”‚
â”‚  â”œâ”€ æŒ‰æ³¨å†Œé¡ºåºæ’åˆ—                                    â”‚
â”‚  â””â”€ æ„é€ Handlerè´£ä»»é“¾                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Step 5: Handleræ‰§è¡Œ                                 â”‚
â”‚  â”œâ”€ Handler1.Handle()                                â”‚
â”‚  â”œâ”€ Handler2.Handle()                                â”‚
â”‚  â””â”€ HandlerN.Handle()                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Step 6: äº‹ä»¶å®Œæˆ/äº§ç”Ÿæ–°äº‹ä»¶                           â”‚
â”‚  â”œâ”€ å¤„ç†æˆåŠŸ                                         â”‚
â”‚  â”œâ”€ ç”Ÿæˆåç»­äº‹ä»¶                                      â”‚
â”‚  â””â”€ è¿”å›ç»“æœ                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### **B. ä¸‰å±‚äº‹ä»¶æµè½¬**

```
å®Œæ•´æ¶ˆæ¯å‘é€çš„ä¸‰å±‚äº‹ä»¶æµè½¬ï¼š

Layer 1: ç”¨æˆ·äº‹ä»¶å±‚ï¼ˆUserEventPoolï¼‰
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ wknet.onData() æ¥æ”¶å®¢æˆ·ç«¯SENDåŒ…           â”‚
â”‚         â†“                                 â”‚
â”‚ ç”Ÿæˆ UserContext{EventOnSend}            â”‚
â”‚         â†“                                 â”‚
â”‚ UserEventPool.AddEvent(uid, event)       â”‚
â”‚         â†“                                 â”‚
â”‚ OnSendHandlerè´£ä»»é“¾ï¼š                     â”‚
â”‚   â”œâ”€ PermissionHandler.Handle()          â”‚
â”‚   â”œâ”€ WebhookHandler.Handle()             â”‚
â”‚   â””â”€ MessageHandler.Handle()             â”‚
â”‚         â†“                                 â”‚
â”‚ äº§ç”Ÿ ChannelContext{EventChannelDistribute} â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
Layer 2: é¢‘é“äº‹ä»¶å±‚ï¼ˆChannelEventPoolï¼‰
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ChannelEventPool.AddEvent(channelID, event) â”‚
â”‚         â†“                                 â”‚
â”‚ DistributeHandlerè´£ä»»é“¾ï¼š                 â”‚
â”‚   â”œâ”€ PreCheckHandler.Handle()            â”‚
â”‚   â”œâ”€ StoreHandler.Handle()               â”‚
â”‚   â”œâ”€ ReplicateHandler.Handle()           â”‚
â”‚   â””â”€ PostProcessHandler.Handle()         â”‚
â”‚         â†“                                 â”‚
â”‚ äº§ç”Ÿ PushContext{EventPushOnline}        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
Layer 3: æ¨é€äº‹ä»¶å±‚ï¼ˆPusherEventPoolï¼‰
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PusherEventPool.AddEvent(event)          â”‚
â”‚         â†“                                 â”‚
â”‚ PushOnlineHandlerè´£ä»»é“¾ï¼š                 â”‚
â”‚   â”œâ”€ FilterHandler.Handle()              â”‚
â”‚   â”œâ”€ EncodeHandler.Handle()              â”‚
â”‚   â””â”€ WriteHandler.Handle()               â”‚
â”‚         â†“                                 â”‚
â”‚ è®¢é˜…è€…æ”¶åˆ°RECVåŒ…                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ç‰¹ç‚¹ï¼š
â”œâ”€ æ¯å±‚ä¸“æ³¨è‡ªå·±çš„èŒè´£
â”œâ”€ å±‚ä¸å±‚ä¹‹é—´é€šè¿‡äº‹ä»¶è§£è€¦
â”œâ”€ å¼‚æ­¥æµè½¬ï¼Œä¸é˜»å¡
â””â”€ æ•…éšœéš”ç¦»ï¼Œäº’ä¸å½±å“
```

---

## 2ï¸âƒ£ äº‹ä»¶ç”Ÿæˆæœºåˆ¶

### **A. äº‹ä»¶ä¸Šä¸‹æ–‡å®šä¹‰**

**ä»£ç ä½ç½®**ï¼š`internal/eventbus/context.go`

```go
// ç”¨æˆ·äº‹ä»¶ä¸Šä¸‹æ–‡
type UserContext struct {
	EventType EventType      // äº‹ä»¶ç±»å‹
	Conn      wknet.Conn     // è¿æ¥å¯¹è±¡
	Frame     *wkproto.Frame // åè®®å¸§
	FromUID   string         // å‘é€è€…UID
	UID       string         // ç›®æ ‡UIDï¼ˆç”¨äºè·¯ç”±ï¼‰
}

// é¢‘é“äº‹ä»¶ä¸Šä¸‹æ–‡
type ChannelContext struct {
	EventType   EventType       // äº‹ä»¶ç±»å‹
	ChannelID   string          // é¢‘é“ID
	ChannelType uint8           // é¢‘é“ç±»å‹
	Messages    []*Message      // æ¶ˆæ¯åˆ—è¡¨
	FromUID     string          // å‘é€è€…
	Subscribers []string        // è®¢é˜…è€…åˆ—è¡¨
}

// æ¨é€äº‹ä»¶ä¸Šä¸‹æ–‡
type PushContext struct {
	EventType   EventType     // äº‹ä»¶ç±»å‹
	Message     *Message      // æ¶ˆæ¯å¯¹è±¡
	Subscribers []Subscriber  // è®¢é˜…è€…åˆ—è¡¨
	NodeID      uint64        // èŠ‚ç‚¹ID
}
```

---

### **B. äº‹ä»¶ç”Ÿæˆä½ç½®**

#### **1. ç½‘ç»œå±‚è§¦å‘**

**ä»£ç ä½ç½®**ï¼š`internal/server/server.go:619-652`

```go
func (s *Server) onData(conn wknet.Conn) error {
	for {
		// 1. è§£æåè®®å¸§
		frame, err := s.protocol.Decode(conn)
		if err != nil {
			if err == io.ErrShortBuffer {
				break
			}
			return err
		}

		// 2. æ ¹æ®å¸§ç±»å‹ç”Ÿæˆäº‹ä»¶
		switch frame.FrameType {
		case wkproto.SEND:
			// ç”Ÿæˆ EventOnSend äº‹ä»¶
			event := &UserContext{
				EventType: EventOnSend,
				Conn:      conn,
				Frame:     frame,
				UID:       conn.UID(),
			}
			// 3. æäº¤åˆ°ç”¨æˆ·äº‹ä»¶æ± 
			s.userEventPool.AddEvent(conn.UID(), event)

		case wkproto.RECVACK:
			// ç”Ÿæˆ EventRecvAck äº‹ä»¶
			event := &UserContext{
				EventType: EventRecvAck,
				Conn:      conn,
				Frame:     frame,
				UID:       conn.UID(),
			}
			s.userEventPool.AddEvent(conn.UID(), event)

		case wkproto.PING:
			// ç”Ÿæˆ EventPing äº‹ä»¶
			event := &UserContext{
				EventType: EventPing,
				Conn:      conn,
				Frame:     frame,
				UID:       conn.UID(),
			}
			s.userEventPool.AddEvent(conn.UID(), event)

		// ... å…¶ä»–å¸§ç±»å‹
		}
	}
	return nil
}
```

---

#### **2. Handlerå†…éƒ¨è§¦å‘**

**ä»£ç ä½ç½®**ï¼š`internal/user/handler/event_onsend.go`

```go
func (h *OnSendHandler) Handle(ctx *UserContext) error {
	sendPacket := ctx.Frame.(*wkproto.SendPacket)

	// 1. æƒé™æ ¡éªŒ
	if err := h.checkPermission(ctx, sendPacket); err != nil {
		return err
	}

	// 2. Webhookå›è°ƒ
	if err := h.callWebhook(ctx, sendPacket); err != nil {
		return err
	}

	// 3. æ„é€ æ¶ˆæ¯å¯¹è±¡
	msg := &Message{
		MessageID:   h.genMessageID(),
		FromUID:     ctx.Conn.UID(),
		ChannelID:   sendPacket.ChannelID,
		ChannelType: sendPacket.ChannelType,
		Payload:     sendPacket.Payload,
		Timestamp:   time.Now().UnixMilli(),
	}

	// 4. ç”Ÿæˆé¢‘é“äº‹ä»¶
	channelEvent := &ChannelContext{
		EventType:   EventChannelDistribute,
		ChannelID:   sendPacket.ChannelID,
		ChannelType: sendPacket.ChannelType,
		Messages:    []*Message{msg},
		FromUID:     ctx.Conn.UID(),
	}

	// 5. æäº¤åˆ°é¢‘é“äº‹ä»¶æ± 
	h.channelEventPool.AddEvent(sendPacket.ChannelID, sendPacket.ChannelType, channelEvent)

	return nil
}
```

**äº‹ä»¶é“¾å¼è§¦å‘**ï¼š
```
EventOnSend (ç”¨æˆ·äº‹ä»¶)
    â†“ OnSendHandler.Handle()
EventChannelDistribute (é¢‘é“äº‹ä»¶)
    â†“ DistributeHandler.Handle()
EventPushOnline (æ¨é€äº‹ä»¶)
    â†“ PushOnlineHandler.Handle()
å®Œæˆ
```

---

#### **3. å®šæ—¶ä»»åŠ¡è§¦å‘**

**ä»£ç ä½ç½®**ï¼š`internal/server/cron.go`

```go
func (s *Server) startCronJobs() {
	// æ¯10ç§’æ£€æŸ¥è¶…æ—¶è¿æ¥
	s.cron.AddFunc("@every 10s", func() {
		s.checkTimeoutConnections()
	})

	// æ¯1åˆ†é’Ÿæ¸…ç†è¿‡æœŸæ•°æ®
	s.cron.AddFunc("@every 1m", func() {
		s.cleanExpiredData()
	})
}

func (s *Server) checkTimeoutConnections() {
	// éå†æ‰€æœ‰è¿æ¥
	s.connMgr.Range(func(conn wknet.Conn) bool {
		// æ£€æŸ¥è¶…æ—¶ï¼ˆ60ç§’æ— æ´»åŠ¨ï¼‰
		if time.Since(conn.LastActivity()) > 60*time.Second {
			// ç”Ÿæˆ EventConnTimeout äº‹ä»¶
			event := &UserContext{
				EventType: EventConnTimeout,
				Conn:      conn,
				UID:       conn.UID(),
			}
			s.userEventPool.AddEvent(conn.UID(), event)
		}
		return true
	})
}
```

---

### **C. äº‹ä»¶ç”Ÿæˆæœ€ä½³å®è·µ**

**1. äº‹ä»¶ä¸Šä¸‹æ–‡å¤ç”¨**
```go
var userContextPool = sync.Pool{
	New: func() any {
		return &UserContext{}
	},
}

func NewUserContext(eventType EventType, conn wknet.Conn, frame *wkproto.Frame) *UserContext {
	ctx := userContextPool.Get().(*UserContext)
	ctx.EventType = eventType
	ctx.Conn = conn
	ctx.Frame = frame
	ctx.UID = conn.UID()
	return ctx
}

func RecycleUserContext(ctx *UserContext) {
	// é‡ç½®å­—æ®µ
	ctx.EventType = 0
	ctx.Conn = nil
	ctx.Frame = nil
	ctx.UID = ""
	ctx.FromUID = ""
	userContextPool.Put(ctx)
}

ä¼˜ç‚¹ï¼š
âœ… å‡å°‘GCå‹åŠ›
âœ… å†…å­˜åˆ†é…å‡å°‘90%
```

---

**2. æ‰¹é‡ç”Ÿæˆäº‹ä»¶**
```go
func (s *Server) onBatchData(conns []wknet.Conn) {
	events := make([]*UserContext, 0, len(conns))

	// æ‰¹é‡ç”Ÿæˆäº‹ä»¶
	for _, conn := range conns {
		frame, err := s.protocol.Decode(conn)
		if err != nil {
			continue
		}

		event := NewUserContext(EventOnSend, conn, frame)
		events = append(events, event)
	}

	// æ‰¹é‡æäº¤
	for _, event := range events {
		s.userEventPool.AddEvent(event.UID, event)
	}
}

ä¼˜ç‚¹ï¼š
âœ… å‡å°‘å‡½æ•°è°ƒç”¨æ¬¡æ•°
âœ… æé«˜CPUç¼“å­˜å‘½ä¸­ç‡
```

---

## 3ï¸âƒ£ äº‹ä»¶å…¥é˜Ÿæµç¨‹

### **A. ç”¨æˆ·äº‹ä»¶å…¥é˜Ÿ**

**ä»£ç ä½ç½®**ï¼š`internal/user/reactor.go`

```go
type UserReactor struct {
	userQueues sync.Map  // map[string]*UserQueue
	workers    []*Worker
	workerCount int
	queueSize  int
}

type UserQueue struct {
	uid        string
	queue      chan *UserContext
	processing atomic.Bool
}

func (r *UserReactor) AddEvent(uid string, event *UserContext) {
	// 1. è·å–æˆ–åˆ›å»ºç”¨æˆ·é˜Ÿåˆ—
	queue := r.getOrCreateQueue(uid)

	// 2. å°è¯•å†™å…¥é˜Ÿåˆ—
	select {
	case queue.queue <- event:
		// æˆåŠŸå†™å…¥
	default:
		// é˜Ÿåˆ—æ»¡ï¼Œè®°å½•å‘Šè­¦
		log.Warn("user queue full",
			zap.String("uid", uid),
			zap.String("eventType", event.EventType.String()))
		metrics.UserQueueFullCount.Inc()
		return
	}

	// 3. å°è¯•è§¦å‘å¤„ç†
	r.tryProcess(queue)
}

func (r *UserReactor) getOrCreateQueue(uid string) *UserQueue {
	// å¿«é€Ÿè·¯å¾„ï¼šä»ç¼“å­˜è·å–
	if q, ok := r.userQueues.Load(uid); ok {
		return q.(*UserQueue)
	}

	// æ…¢é€Ÿè·¯å¾„ï¼šåˆ›å»ºæ–°é˜Ÿåˆ—
	queue := &UserQueue{
		uid:   uid,
		queue: make(chan *UserContext, r.queueSize),
	}

	// åŸå­æ“ä½œï¼šåªæœ‰ä¸€ä¸ªåç¨‹èƒ½åˆ›å»ºæˆåŠŸ
	actual, loaded := r.userQueues.LoadOrStore(uid, queue)
	if loaded {
		// å…¶ä»–åç¨‹å·²åˆ›å»ºï¼Œä½¿ç”¨å·²æœ‰çš„
		return actual.(*UserQueue)
	}

	return queue
}

func (r *UserReactor) tryProcess(queue *UserQueue) {
	// ä½¿ç”¨CASæ£€æŸ¥æ˜¯å¦å·²åœ¨å¤„ç†
	if !queue.processing.CompareAndSwap(false, true) {
		return  // å·²æœ‰åç¨‹åœ¨å¤„ç†ï¼Œç›´æ¥è¿”å›
	}

	// é€‰æ‹©Workerï¼ˆè´Ÿè½½å‡è¡¡ï¼‰
	worker := r.selectWorker(queue.uid)

	// æäº¤ä»»åŠ¡åˆ°Worker
	worker.Submit(func() {
		r.processQueue(queue)
	})
}
```

**å…¥é˜Ÿæµç¨‹å›¾**ï¼š
```
AddEvent(uid, event)
    â†“
è·å–æˆ–åˆ›å»ºUserQueue
    â†“
å†™å…¥queue chan
    â”œâ”€ æˆåŠŸ â†’ ç»§ç»­
    â””â”€ å¤±è´¥ï¼ˆæ»¡ï¼‰ â†’ è®°å½•å‘Šè­¦ï¼Œä¸¢å¼ƒ
    â†“
tryProcess()
    â†“
CASæ£€æŸ¥ processing
    â”œâ”€ falseâ†’true â†’ ç»§ç»­
    â””â”€ å·²ä¸ºtrue â†’ è¿”å›ï¼ˆé¿å…é‡å¤å¤„ç†ï¼‰
    â†“
é€‰æ‹©Worker
    â†“
æäº¤ä»»åŠ¡åˆ°Worker
    â†“
Workerå¼‚æ­¥æ‰§è¡Œ
```

---

### **B. é¢‘é“äº‹ä»¶å…¥é˜Ÿ**

**ä»£ç ä½ç½®**ï¼š`internal/channel/reactor.go`

```go
type ChannelReactor struct {
	channelQueues sync.Map  // map[string]*ChannelQueue
	workers       []*Worker
}

type ChannelQueue struct {
	channelID   string
	channelType uint8
	queue       chan *ChannelContext
	processing  atomic.Bool
}

func (r *ChannelReactor) AddEvent(channelID string, channelType uint8, event *ChannelContext) {
	// 1. æ„é€ é¢‘é“Keyï¼ˆChannelID + ChannelTypeï¼‰
	key := channelKey(channelID, channelType)

	// 2. è·å–æˆ–åˆ›å»ºé¢‘é“é˜Ÿåˆ—
	queue := r.getOrCreateQueue(key, channelID, channelType)

	// 3. å†™å…¥é˜Ÿåˆ—
	select {
	case queue.queue <- event:
		// æˆåŠŸ
	default:
		log.Warn("channel queue full",
			zap.String("channelID", channelID),
			zap.Uint8("channelType", channelType))
		return
	}

	// 4. è§¦å‘å¤„ç†
	r.tryProcess(queue)
}

func channelKey(channelID string, channelType uint8) string {
	return fmt.Sprintf("%s-%d", channelID, channelType)
}
```

**ä¸ºä»€ä¹ˆéœ€è¦ChannelID + ChannelTypeï¼Ÿ**
```
åœºæ™¯ï¼š
ç”¨æˆ·Aåœ¨ä¸¤ä¸ªé¢‘é“ï¼š
â”œâ”€ å•èŠé¢‘é“ï¼šChannelID="userB", ChannelType=1 (PERSON)
â””â”€ ç¾¤èŠé¢‘é“ï¼šChannelID="userB", ChannelType=2 (GROUP)

é—®é¢˜ï¼š
å¦‚æœåªç”¨ChannelIDï¼Œè¿™ä¸¤ä¸ªé¢‘é“ä¼šå†²çªï¼

è§£å†³ï¼š
ä½¿ç”¨ ChannelID + ChannelType ç»„åˆï¼š
â”œâ”€ Key1: "userB-1" â†’ å•èŠé¢‘é“é˜Ÿåˆ—
â””â”€ Key2: "userB-2" â†’ ç¾¤èŠé¢‘é“é˜Ÿåˆ—

ä¿è¯ï¼š
âœ… ä¸åŒç±»å‹çš„é¢‘é“ç‹¬ç«‹é˜Ÿåˆ—
âœ… æ¶ˆæ¯é¡ºåºä¸æ··ä¹±
```

---

### **C. æ¨é€äº‹ä»¶å…¥é˜Ÿ**

**ä»£ç ä½ç½®**ï¼š`internal/pusher/reactor.go`

```go
type PusherReactor struct {
	queue       chan *PushContext  // å…¨å±€é˜Ÿåˆ—
	workers     []*Worker
	workerCount int
}

func (r *PusherReactor) AddEvent(event *PushContext) {
	// ç›´æ¥å†™å…¥å…¨å±€é˜Ÿåˆ—ï¼ˆæ— éœ€åˆ†ç‰‡ï¼‰
	select {
	case r.queue <- event:
		// æˆåŠŸ
	default:
		// é˜Ÿåˆ—æ»¡ï¼Œä¸¢å¼ƒï¼ˆæ¨é€æ˜¯å°½åŠ›è€Œä¸ºï¼‰
		log.Warn("pusher queue full")
		metrics.PusherQueueFullCount.Inc()
	}
}

func (r *PusherReactor) Run() {
	for {
		select {
		case event := <-r.queue:
			// é€‰æ‹©ä¸€ä¸ªWorkerï¼ˆè½®è¯¢ï¼‰
			worker := r.workers[r.next.Add(1)%uint64(r.workerCount)]

			// æäº¤ä»»åŠ¡
			worker.Submit(func() {
				r.processEvent(event)
			})

		case <-r.stopChan:
			return
		}
	}
}
```

**ä¸ºä»€ä¹ˆæ¨é€äº‹ä»¶æ± ç”¨å…¨å±€é˜Ÿåˆ—ï¼Ÿ**
```
å¯¹æ¯”ï¼š

UserEventPoolï¼šæŒ‰UIDåˆ†ç‰‡
â”œâ”€ åŒä¸€ç”¨æˆ·çš„äº‹ä»¶å¿…é¡»é¡ºåºå¤„ç†
â”œâ”€ EventOnSend â†’ EventRecvAck é¡ºåºä¸èƒ½ä¹±
â””â”€ å¿…é¡»åˆ†ç‰‡

ChannelEventPoolï¼šæŒ‰ChannelIDåˆ†ç‰‡
â”œâ”€ åŒä¸€é¢‘é“çš„æ¶ˆæ¯å¿…é¡»é¡ºåºå¤„ç†
â”œâ”€ MessageSeqå¿…é¡»é€’å¢
â””â”€ å¿…é¡»åˆ†ç‰‡

PusherEventPoolï¼šå…¨å±€é˜Ÿåˆ—
â”œâ”€ æ¨é€äº‹ä»¶ä¹‹é—´æ— ä¾èµ–å…³ç³»
â”œâ”€ æ¨é€ç»™Aå’Œæ¨é€ç»™Bå¯ä»¥ä¹±åº
â”œâ”€ å…¨å±€é˜Ÿåˆ—+å¤šWorkerå¹¶è¡Œï¼Œååæ›´é«˜
â””â”€ æ— éœ€åˆ†ç‰‡
```

---

## 4ï¸âƒ£ äº‹ä»¶è·¯ç”±æœºåˆ¶

### **A. Handleræ³¨å†Œ**

**ä»£ç ä½ç½®**ï¼š`internal/eventbus/eventbus.go`

```go
// Handlerè·¯ç”±è¡¨
var (
	userEventRouteMap    = make(map[EventType][]UserHandlerFunc)
	channelEventRouteMap = make(map[EventType][]ChannelHandlerFunc)
	pusherEventRouteMap  = make(map[EventType][]PusherHandlerFunc)
)

// Handlerå‡½æ•°ç­¾å
type UserHandlerFunc func(*UserContext) error
type ChannelHandlerFunc func(*ChannelContext) error
type PusherHandlerFunc func(*PushContext) error

// æ³¨å†Œç”¨æˆ·äº‹ä»¶Handler
func RegisterUserHandlers(eventType EventType, handlers ...UserHandlerFunc) {
	userEventRouteMap[eventType] = append(userEventRouteMap[eventType], handlers...)
}

// æ³¨å†Œé¢‘é“äº‹ä»¶Handler
func RegisterChannelHandlers(eventType EventType, handlers ...ChannelHandlerFunc) {
	channelEventRouteMap[eventType] = append(channelEventRouteMap[eventType], handlers...)
}

// æ³¨å†Œæ¨é€äº‹ä»¶Handler
func RegisterPusherHandlers(eventType EventType, handlers ...PusherHandlerFunc) {
	pusherEventRouteMap[eventType] = append(pusherEventRouteMap[eventType], handlers...)
}
```

---

### **B. Handleræ³¨å†Œç¤ºä¾‹**

**ä»£ç ä½ç½®**ï¼š`internal/server/server.go:initHandlers()`

```go
func (s *Server) initHandlers() {
	// ========== ç”¨æˆ·äº‹ä»¶Handler ==========

	// EventConnectï¼šè¿æ¥å»ºç«‹
	RegisterUserHandlers(EventConnect,
		s.connectHandler.Authenticate,   // 1. è®¤è¯
		s.connectHandler.LoadSession,    // 2. åŠ è½½ä¼šè¯
		s.connectHandler.SendConnack,    // 3. å‘é€è¿æ¥ç¡®è®¤
	)

	// EventOnSendï¼šæ¶ˆæ¯å‘é€
	RegisterUserHandlers(EventOnSend,
		s.permissionHandler.Check,       // 1. æƒé™æ ¡éªŒ
		s.webhookHandler.OnSend,         // 2. Webhookå›è°ƒ
		s.onSendHandler.Handle,          // 3. æ ¸å¿ƒå¤„ç†
	)

	// EventRecvAckï¼šæ¥æ”¶ç¡®è®¤
	RegisterUserHandlers(EventRecvAck,
		s.recvAckHandler.UpdateOffset,   // 1. æ›´æ–°å®¢æˆ·ç«¯åç§»é‡
		s.recvAckHandler.ClearQueue,     // 2. æ¸…ç†å·²ç¡®è®¤æ¶ˆæ¯
	)

	// ========== é¢‘é“äº‹ä»¶Handler ==========

	// EventChannelDistributeï¼šæ¶ˆæ¯åˆ†å‘
	RegisterChannelHandlers(EventChannelDistribute,
		s.distributeHandler.PreCheck,    // 1. é¢„æ£€æŸ¥
		s.distributeHandler.Store,       // 2. å­˜å‚¨æ¶ˆæ¯
		s.distributeHandler.Replicate,   // 3. Raftå¤åˆ¶
		s.distributeHandler.PostProcess, // 4. åå¤„ç†
	)

	// ========== æ¨é€äº‹ä»¶Handler ==========

	// EventPushOnlineï¼šåœ¨çº¿æ¨é€
	RegisterPusherHandlers(EventPushOnline,
		s.pushHandler.FilterOnline,      // 1. è¿‡æ»¤åœ¨çº¿è®¢é˜…è€…
		s.pushHandler.Encode,            // 2. ç¼–ç RECVåŒ…
		s.pushHandler.Write,             // 3. å†™å…¥è¿æ¥
	)
}
```

**æ³¨å†Œé¡ºåºçš„é‡è¦æ€§**ï¼š
```
HandleræŒ‰æ³¨å†Œé¡ºåºæ‰§è¡Œï¼š

EventOnSend:
â”œâ”€ 1. permissionHandler.Check()      â† å…ˆæ ¡éªŒæƒé™
â”‚   â””â”€ å¤±è´¥ â†’ ç»ˆæ­¢é“¾ï¼Œè¿”å›é”™è¯¯
â”œâ”€ 2. webhookHandler.OnSend()        â† å†è°ƒç”¨Webhook
â”‚   â””â”€ å¤±è´¥ â†’ ç»ˆæ­¢é“¾
â””â”€ 3. onSendHandler.Handle()         â† æœ€åæ ¸å¿ƒå¤„ç†

é¡ºåºé”™è¯¯ç¤ºä¾‹ï¼š
âŒ å…ˆè°ƒç”¨Webhookï¼Œå†æ ¡éªŒæƒé™
   â””â”€ é—®é¢˜ï¼šæ— æƒé™çš„æ¶ˆæ¯ä¹Ÿè§¦å‘äº†Webhook

âœ… å…ˆæ ¡éªŒæƒé™ï¼Œå†è°ƒç”¨Webhook
   â””â”€ æ­£ç¡®ï¼šåªæœ‰æœ‰æƒé™çš„æ¶ˆæ¯æ‰è§¦å‘Webhook
```

---

### **C. äº‹ä»¶æ‰§è¡Œ**

**ä»£ç ä½ç½®**ï¼š`internal/eventbus/eventbus.go`

```go
// æ‰§è¡Œç”¨æˆ·äº‹ä»¶
func ExecuteUserEvent(ctx *UserContext) error {
	// 1. æŸ¥æ‰¾Handleråˆ—è¡¨
	handlers, ok := userEventRouteMap[ctx.EventType]
	if !ok {
		log.Warn("no handler for event",
			zap.String("eventType", ctx.EventType.String()))
		return nil
	}

	// 2. æ‰§è¡ŒHandleré“¾
	for i, handler := range handlers {
		// æ‰§è¡ŒHandler
		err := handler(ctx)
		if err != nil {
			// Handlerè¿”å›é”™è¯¯ï¼Œç»ˆæ­¢é“¾
			log.Error("handler error",
				zap.String("eventType", ctx.EventType.String()),
				zap.Int("handlerIndex", i),
				zap.Error(err))
			return err
		}
	}

	return nil
}

// æ‰§è¡Œé¢‘é“äº‹ä»¶
func ExecuteChannelEvent(ctx *ChannelContext) error {
	handlers, ok := channelEventRouteMap[ctx.EventType]
	if !ok {
		return nil
	}

	for _, handler := range handlers {
		if err := handler(ctx); err != nil {
			return err
		}
	}

	return nil
}

// æ‰§è¡Œæ¨é€äº‹ä»¶
func ExecutePusherEvent(ctx *PushContext) error {
	handlers, ok := pusherEventRouteMap[ctx.EventType]
	if !ok {
		return nil
	}

	for _, handler := range handlers {
		if err := handler(ctx); err != nil {
			return err
		}
	}

	return nil
}
```

---

### **D. äº‹ä»¶è·¯ç”±ä¼˜åŒ–**

**1. è·¯ç”±è¡¨é¢„ç¼–è¯‘**
```go
// âŒ ä½æ•ˆï¼šæ¯æ¬¡æŸ¥æ‰¾éƒ½éå†
func ExecuteUserEvent(ctx *UserContext) error {
	for eventType, handlers := range userEventRouteMap {
		if eventType == ctx.EventType {
			// æ‰§è¡Œ...
		}
	}
}

// âœ… é«˜æ•ˆï¼šç›´æ¥å“ˆå¸ŒæŸ¥æ‰¾
func ExecuteUserEvent(ctx *UserContext) error {
	handlers, ok := userEventRouteMap[ctx.EventType]  // O(1)
	if !ok {
		return nil
	}
	// æ‰§è¡Œ...
}
```

---

**2. Handleré“¾ç¼“å­˜**
```go
type CachedHandlerChain struct {
	eventType EventType
	handlers  []UserHandlerFunc
}

var cachedChains = make(map[EventType]*CachedHandlerChain)

func BuildHandlerChain(eventType EventType) *CachedHandlerChain {
	// æ£€æŸ¥ç¼“å­˜
	if chain, ok := cachedChains[eventType]; ok {
		return chain
	}

	// æ„é€ é“¾
	chain := &CachedHandlerChain{
		eventType: eventType,
		handlers:  userEventRouteMap[eventType],
	}

	// ç¼“å­˜
	cachedChains[eventType] = chain
	return chain
}

func (c *CachedHandlerChain) Execute(ctx *UserContext) error {
	for _, handler := range c.handlers {
		if err := handler(ctx); err != nil {
			return err
		}
	}
	return nil
}

ä¼˜ç‚¹ï¼š
âœ… é¿å…é‡å¤æŸ¥æ‰¾
âœ… Handleråˆ—è¡¨é¢„åˆ†é…
```

---

## 5ï¸âƒ£ Handlerè´£ä»»é“¾æ¨¡å¼

### **A. è´£ä»»é“¾æ¨¡å¼å®šä¹‰**

```
è´£ä»»é“¾æ¨¡å¼ï¼ˆChain of Responsibilityï¼‰ï¼š

å®šä¹‰ï¼š
ä½¿å¤šä¸ªå¯¹è±¡éƒ½æœ‰æœºä¼šå¤„ç†è¯·æ±‚ï¼Œä»è€Œé¿å…è¯·æ±‚çš„å‘é€è€…å’Œæ¥æ”¶è€…ä¹‹é—´çš„è€¦åˆå…³ç³»ã€‚
å°†è¿™äº›å¯¹è±¡è¿æˆä¸€æ¡é“¾ï¼Œå¹¶æ²¿ç€è¿™æ¡é“¾ä¼ é€’è¯¥è¯·æ±‚ï¼Œç›´åˆ°æœ‰ä¸€ä¸ªå¯¹è±¡å¤„ç†å®ƒä¸ºæ­¢ã€‚

ç»“æ„ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Handler1 â”‚â”€â”€â”€â”€â”€â†’â”‚Handler2 â”‚â”€â”€â”€â”€â”€â†’â”‚Handler3 â”‚â”€â”€â”€â”€â”€â†’â”‚Handler4 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â†“                â†“                â†“                â†“
  å¤„ç†/ä¼ é€’       å¤„ç†/ä¼ é€’       å¤„ç†/ä¼ é€’       å¤„ç†/ä¼ é€’

ç‰¹ç‚¹ï¼š
â”œâ”€ è§£è€¦ï¼šè¯·æ±‚è€…ä¸çŸ¥é“è°ä¼šå¤„ç†
â”œâ”€ çµæ´»ï¼šå¯åŠ¨æ€å¢åˆ Handler
â”œâ”€ é¡ºåºï¼šæŒ‰é“¾é¡ºåºæ‰§è¡Œ
â””â”€ ç»ˆæ­¢ï¼šä»»ä½•Handlerå¯ç»ˆæ­¢é“¾
```

---

### **B. WuKongIMçš„è´£ä»»é“¾å®ç°**

#### **ç¤ºä¾‹1ï¼šæ¶ˆæ¯å‘é€è´£ä»»é“¾**

**å®Œæ•´æµç¨‹**ï¼š
```
EventOnSend äº‹ä»¶
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Handler 1: PermissionHandler            â”‚
â”‚ èŒè´£ï¼šæƒé™æ ¡éªŒ                           â”‚
â”‚ â”œâ”€ æ£€æŸ¥ç”¨æˆ·æ˜¯å¦è¢«å°ç¦                    â”‚
â”‚ â”œâ”€ æ£€æŸ¥æ˜¯å¦æœ‰å‘é€æƒé™                    â”‚
â”‚ â””â”€ æ£€æŸ¥é¢‘é“æ˜¯å¦å­˜åœ¨                      â”‚
â”‚ ç»“æœï¼š                                   â”‚
â”‚ â”œâ”€ æˆåŠŸ â†’ ç»§ç»­ä¸‹ä¸€ä¸ªHandler              â”‚
â”‚ â””â”€ å¤±è´¥ â†’ è¿”å›é”™è¯¯ï¼Œç»ˆæ­¢é“¾                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“ï¼ˆæƒé™æ ¡éªŒé€šè¿‡ï¼‰
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Handler 2: WebhookHandler               â”‚
â”‚ èŒè´£ï¼šä¸šåŠ¡å›è°ƒ                           â”‚
â”‚ â”œâ”€ è°ƒç”¨ä¸šåŠ¡æ–¹Webhook                     â”‚
â”‚ â”œâ”€ è·å–æ‰©å±•ä¿¡æ¯                          â”‚
â”‚ â””â”€ æ•æ„Ÿè¯è¿‡æ»¤                            â”‚
â”‚ ç»“æœï¼š                                   â”‚
â”‚ â”œâ”€ æˆåŠŸ â†’ ç»§ç»­                           â”‚
â”‚ â””â”€ å¤±è´¥ â†’ ç»ˆæ­¢é“¾                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“ï¼ˆWebhookè°ƒç”¨æˆåŠŸï¼‰
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Handler 3: OnSendHandler                â”‚
â”‚ èŒè´£ï¼šæ ¸å¿ƒä¸šåŠ¡å¤„ç†                        â”‚
â”‚ â”œâ”€ ç”ŸæˆMessageID                         â”‚
â”‚ â”œâ”€ æ„é€ Messageå¯¹è±¡                       â”‚
â”‚ â”œâ”€ å‘é€SENDACKç»™å®¢æˆ·ç«¯                   â”‚
â”‚ â””â”€ ç”ŸæˆChannelEvent                      â”‚
â”‚ ç»“æœï¼š                                   â”‚
â”‚ â””â”€ æˆåŠŸ â†’ é“¾ç»“æŸ                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ä»£ç å®ç°**ï¼š

```go
// Handler 1: æƒé™æ ¡éªŒ
type PermissionHandler struct{}

func (h *PermissionHandler) Check(ctx *UserContext) error {
	sendPacket := ctx.Frame.(*wkproto.SendPacket)

	// 1. æ£€æŸ¥ç”¨æˆ·æ˜¯å¦è¢«å°ç¦
	if h.isUserBanned(ctx.Conn.UID()) {
		return errors.New("user is banned")
	}

	// 2. æ£€æŸ¥å‘é€æƒé™
	if !h.hasPermission(ctx.Conn.UID(), sendPacket.ChannelID) {
		return errors.New("no permission")
	}

	// 3. æ£€æŸ¥é¢‘é“æ˜¯å¦å­˜åœ¨
	if !h.channelExists(sendPacket.ChannelID, sendPacket.ChannelType) {
		return errors.New("channel not found")
	}

	return nil  // é€šè¿‡ï¼Œç»§ç»­ä¸‹ä¸€ä¸ªHandler
}

// Handler 2: Webhookå›è°ƒ
type WebhookHandler struct {
	httpClient *http.Client
	webhookURL string
}

func (h *WebhookHandler) OnSend(ctx *UserContext) error {
	sendPacket := ctx.Frame.(*wkproto.SendPacket)

	// 1. æ„é€ Webhookè¯·æ±‚
	req := &WebhookRequest{
		Event:   "message.send",
		FromUID: ctx.Conn.UID(),
		ChannelID: sendPacket.ChannelID,
		Payload: sendPacket.Payload,
	}

	// 2. è°ƒç”¨Webhook
	resp, err := h.callWebhook(req)
	if err != nil {
		return err
	}

	// 3. æ£€æŸ¥å“åº”
	if resp.Code != 0 {
		return fmt.Errorf("webhook reject: %s", resp.Message)
	}

	// 4. ä¿å­˜æ‰©å±•ä¿¡æ¯åˆ°Context
	ctx.Extra = resp.Extra

	return nil
}

// Handler 3: æ ¸å¿ƒå¤„ç†
type OnSendHandler struct {
	channelEventPool *ChannelEventPool
}

func (h *OnSendHandler) Handle(ctx *UserContext) error {
	sendPacket := ctx.Frame.(*wkproto.SendPacket)

	// 1. ç”ŸæˆMessageID
	messageID := h.genMessageID()

	// 2. æ„é€ Message
	msg := &Message{
		MessageID:   messageID,
		ClientMsgNo: sendPacket.ClientMsgNo,
		FromUID:     ctx.Conn.UID(),
		ChannelID:   sendPacket.ChannelID,
		ChannelType: sendPacket.ChannelType,
		Payload:     sendPacket.Payload,
		Timestamp:   time.Now().UnixMilli(),
		Extra:       ctx.Extra,  // Webhookè¿”å›çš„æ‰©å±•ä¿¡æ¯
	}

	// 3. å‘é€SENDACK
	ack := &wkproto.SendackPacket{
		ClientMsgNo: sendPacket.ClientMsgNo,
		MessageID:   messageID,
		MessageSeq:  0,  // æš‚æœªåˆ†é…
		ReasonCode:  0,  // æˆåŠŸ
	}
	ctx.Conn.WriteFrame(ack)

	// 4. ç”Ÿæˆé¢‘é“äº‹ä»¶
	channelEvent := &ChannelContext{
		EventType:   EventChannelDistribute,
		ChannelID:   sendPacket.ChannelID,
		ChannelType: sendPacket.ChannelType,
		Messages:    []*Message{msg},
		FromUID:     ctx.Conn.UID(),
	}

	// 5. æäº¤åˆ°é¢‘é“äº‹ä»¶æ± 
	h.channelEventPool.AddEvent(sendPacket.ChannelID, sendPacket.ChannelType, channelEvent)

	return nil
}
```

---

#### **ç¤ºä¾‹2ï¼šæ¶ˆæ¯åˆ†å‘è´£ä»»é“¾**

**å®Œæ•´æµç¨‹**ï¼š
```
EventChannelDistribute äº‹ä»¶
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Handler 1: PreCheckHandler              â”‚
â”‚ èŒè´£ï¼šé¢„æ£€æŸ¥                             â”‚
â”‚ â”œâ”€ æ£€æŸ¥é¢‘é“æ˜¯å¦å­˜åœ¨                      â”‚
â”‚ â”œâ”€ æ£€æŸ¥æ¶ˆæ¯æ ¼å¼                          â”‚
â”‚ â””â”€ å»é‡æ£€æŸ¥ï¼ˆClientMsgNoï¼‰               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Handler 2: StoreHandler                 â”‚
â”‚ èŒè´£ï¼šå­˜å‚¨æ¶ˆæ¯                           â”‚
â”‚ â”œâ”€ åˆ†é…MessageSeq                        â”‚
â”‚ â”œâ”€ å†™å…¥PebbleDB                          â”‚
â”‚ â””â”€ æ›´æ–°ç´¢å¼•                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Handler 3: ReplicateHandler             â”‚
â”‚ èŒè´£ï¼šRaftå¤åˆ¶                           â”‚
â”‚ â”œâ”€ æè®®åˆ°Raft                            â”‚
â”‚ â”œâ”€ ç­‰å¾…å¤šæ•°æ´¾ç¡®è®¤                        â”‚
â”‚ â””â”€ åº”ç”¨åˆ°çŠ¶æ€æœº                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Handler 4: PostProcessHandler           â”‚
â”‚ èŒè´£ï¼šåå¤„ç†                             â”‚
â”‚ â”œâ”€ æŸ¥æ‰¾è®¢é˜…è€…                            â”‚
â”‚ â”œâ”€ ç”ŸæˆPushEvent                         â”‚
â”‚ â””â”€ æ›´æ–°ç»Ÿè®¡æ•°æ®                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### **C. è´£ä»»é“¾çš„ä¼˜åŠ¿**

**1. æ˜“äºæ‰©å±•**
```go
// éœ€æ±‚ï¼šæ–°å¢æ¶ˆæ¯å®¡æ ¸åŠŸèƒ½

// åªéœ€æ·»åŠ æ–°Handler
type AuditHandler struct{}

func (h *AuditHandler) Handle(ctx *UserContext) error {
	sendPacket := ctx.Frame.(*wkproto.SendPacket)

	// å®¡æ ¸é€»è¾‘
	if containsSensitiveWords(sendPacket.Payload) {
		return errors.New("sensitive content")
	}

	return nil
}

// æ³¨å†Œåˆ°é“¾ä¸­ï¼ˆæ’å…¥åˆ°åˆé€‚ä½ç½®ï¼‰
RegisterUserHandlers(EventOnSend,
	permissionHandler.Check,  // 1. æƒé™æ ¡éªŒ
	auditHandler.Handle,      // 2. å†…å®¹å®¡æ ¸ï¼ˆæ–°å¢ï¼‰
	webhookHandler.OnSend,    // 3. Webhookå›è°ƒ
	onSendHandler.Handle,     // 4. æ ¸å¿ƒå¤„ç†
)

ä¼˜ç‚¹ï¼š
âœ… æ— éœ€ä¿®æ”¹å·²æœ‰Handler
âœ… åªéœ€æ’å…¥æ–°Handler
âœ… ç¬¦åˆå¼€é—­åŸåˆ™
```

---

**2. èŒè´£åˆ†ç¦»**
```
æ¯ä¸ªHandleråªè´Ÿè´£ä¸€ä»¶äº‹ï¼š

PermissionHandlerï¼š
â””â”€ åªåšæƒé™æ ¡éªŒ

WebhookHandlerï¼š
â””â”€ åªåšä¸šåŠ¡å›è°ƒ

OnSendHandlerï¼š
â””â”€ åªåšæ ¸å¿ƒå¤„ç†

ä¼˜ç‚¹ï¼š
âœ… ä»£ç æ¸…æ™°
âœ… æ˜“äºæµ‹è¯•
âœ… æ˜“äºç»´æŠ¤
```

---

**3. çµæ´»ç»„åˆ**
```go
// åœºæ™¯1ï¼šæ™®é€šæ¶ˆæ¯
RegisterUserHandlers(EventOnSend,
	permissionHandler.Check,
	webhookHandler.OnSend,
	onSendHandler.Handle,
)

// åœºæ™¯2ï¼šç³»ç»Ÿæ¶ˆæ¯ï¼ˆè·³è¿‡Webhookï¼‰
RegisterUserHandlers(EventOnSystemSend,
	permissionHandler.Check,
	onSendHandler.Handle,  // ç›´æ¥å¤„ç†
)

// åœºæ™¯3ï¼šæ‰¹é‡æ¶ˆæ¯ï¼ˆæ‰¹é‡å¤„ç†ï¼‰
RegisterUserHandlers(EventOnBatchSend,
	permissionHandler.Check,
	batchHandler.Handle,  // æ‰¹é‡Handler
)
```

---

## 6ï¸âƒ£ äº‹ä»¶è½¬å‘ä¸è·¨èŠ‚ç‚¹é€šä¿¡

### **A. ä¸ºä»€ä¹ˆéœ€è¦è·¨èŠ‚ç‚¹é€šä¿¡ï¼Ÿ**

```
åˆ†å¸ƒå¼åœºæ™¯ï¼š

èŠ‚ç‚¹Aï¼ˆåŒ—äº¬ï¼‰          èŠ‚ç‚¹Bï¼ˆä¸Šæµ·ï¼‰
    â”œâ”€ ç”¨æˆ·A              â”œâ”€ ç”¨æˆ·B
    â””â”€ ç”¨æˆ·C              â””â”€ ç”¨æˆ·D

åœºæ™¯ï¼šç”¨æˆ·Aå‘é€æ¶ˆæ¯åˆ°ç¾¤èŠï¼ˆåŒ…å«ç”¨æˆ·Bã€Cã€Dï¼‰

é—®é¢˜ï¼š
â”œâ”€ ç”¨æˆ·Aè¿æ¥åœ¨èŠ‚ç‚¹A
â”œâ”€ ç”¨æˆ·Bã€Dè¿æ¥åœ¨èŠ‚ç‚¹B
â””â”€ å¦‚ä½•æ¨é€æ¶ˆæ¯ç»™ç”¨æˆ·Bã€Dï¼Ÿ

è§£å†³ï¼š
èŠ‚ç‚¹Aå¤„ç†æ¶ˆæ¯åï¼Œéœ€è¦è½¬å‘æ¨é€äº‹ä»¶åˆ°èŠ‚ç‚¹B
```

---

### **B. è·¨èŠ‚ç‚¹äº‹ä»¶è½¬å‘æœºåˆ¶**

**ä»£ç ä½ç½®**ï¼š`internal/pusher/handler/push_online.go`

```go
func (h *PushOnlineHandler) Handle(ctx *PushContext) error {
	// 1. æŸ¥æ‰¾è®¢é˜…è€…
	subscribers := h.getSubscribers(ctx.Message.ChannelID, ctx.Message.ChannelType)

	// 2. æŒ‰èŠ‚ç‚¹åˆ†ç»„
	nodeGroups := h.groupByNode(subscribers)

	// 3. æœ¬åœ°æ¨é€
	localUIDs := nodeGroups[options.G.Cluster.NodeId]
	if len(localUIDs) > 0 {
		h.pushLocal(localUIDs, ctx.Message)
	}

	// 4. è·¨èŠ‚ç‚¹æ¨é€
	for nodeID, uids := range nodeGroups {
		if nodeID == options.G.Cluster.NodeId {
			continue  // è·³è¿‡æœ¬åœ°
		}

		// å‘é€RPCè¯·æ±‚åˆ°ç›®æ ‡èŠ‚ç‚¹
		h.pushRemote(nodeID, uids, ctx.Message)
	}

	return nil
}
```

**æŒ‰èŠ‚ç‚¹åˆ†ç»„**ï¼š
```go
func (h *PushOnlineHandler) groupByNode(subscribers []Subscriber) map[uint64][]string {
	groups := make(map[uint64][]string)

	for _, sub := range subscribers {
		// æŸ¥æ‰¾ç”¨æˆ·è¿æ¥åœ¨å“ªä¸ªèŠ‚ç‚¹
		nodeID := h.findNodeByUID(sub.UID)
		if nodeID == 0 {
			// ç¦»çº¿ï¼Œè·³è¿‡
			continue
		}

		// æŒ‰èŠ‚ç‚¹åˆ†ç»„
		groups[nodeID] = append(groups[nodeID], sub.UID)
	}

	return groups
}

func (h *PushOnlineHandler) findNodeByUID(uid string) uint64 {
	// ä»åˆ†å¸ƒå¼å­˜å‚¨ï¼ˆå¦‚Redisï¼‰æŸ¥æ‰¾ç”¨æˆ·åœ¨çº¿ä¿¡æ¯
	nodeID, err := h.redis.HGet(ctx, "user:online", uid).Uint64()
	if err != nil {
		return 0  // ç¦»çº¿
	}
	return nodeID
}
```

**ç¤ºä¾‹**ï¼š
```
è®¢é˜…è€…åˆ—è¡¨ï¼š
â”œâ”€ userA â†’ èŠ‚ç‚¹1
â”œâ”€ userB â†’ èŠ‚ç‚¹2
â”œâ”€ userC â†’ èŠ‚ç‚¹1
â””â”€ userD â†’ èŠ‚ç‚¹2

åˆ†ç»„ç»“æœï¼š
groups[1] = ["userA", "userC"]
groups[2] = ["userB", "userD"]

æ¨é€ï¼š
â”œâ”€ èŠ‚ç‚¹1ï¼ˆæœ¬åœ°ï¼‰ï¼šç›´æ¥æ¨é€ç»™userAã€userC
â””â”€ èŠ‚ç‚¹2ï¼ˆè¿œç¨‹ï¼‰ï¼šRPCæ¨é€ç»™userBã€userD
```

---

### **C. è·¨èŠ‚ç‚¹RPCå®ç°**

**ä»£ç ä½ç½®**ï¼š`pkg/cluster/rpc/push.go`

```go
// RPCæ¥å£å®šä¹‰
type PushService interface {
	// æ¨é€æ¶ˆæ¯
	Push(ctx context.Context, req *PushRequest) (*PushResponse, error)
}

type PushRequest struct {
	UIDs    []string  // ç›®æ ‡ç”¨æˆ·åˆ—è¡¨
	Message *Message  // æ¶ˆæ¯å¯¹è±¡
}

type PushResponse struct {
	SuccessCount int  // æˆåŠŸæ¨é€æ•°é‡
	FailedUIDs   []string  // æ¨é€å¤±è´¥çš„UID
}

// å®¢æˆ·ç«¯å®ç°
type PushClient struct {
	conns map[uint64]*grpc.ClientConn  // èŠ‚ç‚¹è¿æ¥æ± 
}

func (c *PushClient) PushRemote(nodeID uint64, uids []string, msg *Message) error {
	// 1. è·å–ç›®æ ‡èŠ‚ç‚¹è¿æ¥
	conn, err := c.getConn(nodeID)
	if err != nil {
		return err
	}

	// 2. åˆ›å»ºRPCå®¢æˆ·ç«¯
	client := pb.NewPushServiceClient(conn)

	// 3. æ„é€ è¯·æ±‚
	req := &pb.PushRequest{
		Uids:    uids,
		Message: convertMessage(msg),
	}

	// 4. å‘é€RPCè¯·æ±‚
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	resp, err := client.Push(ctx, req)
	if err != nil {
		return err
	}

	// 5. æ£€æŸ¥ç»“æœ
	if len(resp.FailedUids) > 0 {
		log.Warn("push failed",
			zap.Strings("failedUIDs", resp.FailedUids))
	}

	return nil
}
```

**æœåŠ¡ç«¯å®ç°**ï¼š
```go
// æœåŠ¡ç«¯å®ç°
type PushServer struct {
	pusher *Pusher
}

func (s *PushServer) Push(ctx context.Context, req *pb.PushRequest) (*pb.PushResponse, error) {
	// 1. è½¬æ¢æ¶ˆæ¯å¯¹è±¡
	msg := convertPBMessage(req.Message)

	successCount := 0
	failedUIDs := []string{}

	// 2. é€ä¸ªæ¨é€
	for _, uid := range req.Uids {
		// æŸ¥æ‰¾æœ¬åœ°è¿æ¥
		conns := s.pusher.connMgr.ConnsByUID(uid)
		if len(conns) == 0 {
			failedUIDs = append(failedUIDs, uid)
			continue
		}

		// ç¼–ç RECVåŒ…
		recvPacket := &wkproto.RecvPacket{
			MessageID:   msg.MessageID,
			MessageSeq:  msg.MessageSeq,
			FromUID:     msg.FromUID,
			ChannelID:   msg.ChannelID,
			ChannelType: msg.ChannelType,
			Payload:     msg.Payload,
			Timestamp:   msg.Timestamp,
		}

		// å†™å…¥è¿æ¥
		for _, conn := range conns {
			if err := conn.WriteFrame(recvPacket); err != nil {
				log.Error("write frame error", zap.Error(err))
			} else {
				successCount++
			}
		}
	}

	return &pb.PushResponse{
		SuccessCount: int32(successCount),
		FailedUids:   failedUIDs,
	}, nil
}
```

---

### **D. è·¨èŠ‚ç‚¹é€šä¿¡ä¼˜åŒ–**

**1. æ‰¹é‡RPC**
```go
// âŒ ä½æ•ˆï¼šé€ä¸ªRPC
for nodeID, uids := range nodeGroups {
	for _, uid := range uids {
		h.pushRemote(nodeID, []string{uid}, msg)  // Næ¬¡RPC
	}
}

// âœ… é«˜æ•ˆï¼šæ‰¹é‡RPC
for nodeID, uids := range nodeGroups {
	h.pushRemote(nodeID, uids, msg)  // 1æ¬¡RPC
}

ä¼˜ç‚¹ï¼š
â”œâ”€ å‡å°‘RPCæ¬¡æ•°ï¼ˆä»Næ¬¡å‡å°‘åˆ°1æ¬¡ï¼‰
â”œâ”€ å‡å°‘ç½‘ç»œå¼€é”€
â””â”€ æé«˜ååé‡
```

---

**2. å¹¶è¡ŒRPC**
```go
func (h *PushOnlineHandler) pushRemoteParallel(nodeGroups map[uint64][]string, msg *Message) {
	var wg sync.WaitGroup

	for nodeID, uids := range nodeGroups {
		wg.Add(1)

		// å¹¶è¡Œå‘é€RPC
		go func(nid uint64, us []string) {
			defer wg.Done()
			h.pushRemote(nid, us, msg)
		}(nodeID, uids)
	}

	// ç­‰å¾…æ‰€æœ‰RPCå®Œæˆ
	wg.Wait()
}

ä¼˜ç‚¹ï¼š
âœ… å¹¶è¡Œæ¨é€åˆ°å¤šä¸ªèŠ‚ç‚¹
âœ… å»¶è¿Ÿå–å†³äºæœ€æ…¢èŠ‚ç‚¹
âœ… ååé‡å¤§å¹…æå‡
```

---

**3. è¿æ¥æ± å¤ç”¨**
```go
type PushClient struct {
	conns sync.Map  // map[uint64]*grpc.ClientConn
}

func (c *PushClient) getConn(nodeID uint64) (*grpc.ClientConn, error) {
	// ä»è¿æ¥æ± è·å–
	if conn, ok := c.conns.Load(nodeID); ok {
		return conn.(*grpc.ClientConn), nil
	}

	// åˆ›å»ºæ–°è¿æ¥
	addr := c.getNodeAddr(nodeID)
	conn, err := grpc.Dial(addr,
		grpc.WithInsecure(),
		grpc.WithKeepaliveParams(keepalive.ClientParameters{
			Time:    30 * time.Second,
			Timeout: 10 * time.Second,
		}),
	)
	if err != nil {
		return nil, err
	}

	// å­˜å‚¨åˆ°è¿æ¥æ± 
	c.conns.Store(nodeID, conn)

	return conn, nil
}

ä¼˜ç‚¹ï¼š
âœ… è¿æ¥å¤ç”¨ï¼Œé¿å…é¢‘ç¹å»ºç«‹
âœ… é•¿è¿æ¥ï¼Œå‡å°‘æ¡æ‰‹å¼€é”€
âœ… Keepaliveä¿æŒè¿æ¥æ´»è·ƒ
```

---

## 7ï¸âƒ£ æ€»ç»“

### **æ ¸å¿ƒè¦ç‚¹**

1. **äº‹ä»¶å¤„ç†é“¾è·¯**
   - äº‹ä»¶ç”Ÿæˆï¼šç½‘ç»œå±‚ã€Handlerå†…éƒ¨ã€å®šæ—¶ä»»åŠ¡
   - äº‹ä»¶å…¥é˜Ÿï¼šæŒ‰UID/ChannelIDåˆ†ç‰‡ï¼Œæˆ–å…¨å±€é˜Ÿåˆ—
   - äº‹ä»¶è·¯ç”±ï¼šåŸºäºEventTypeæŸ¥æ‰¾Handleråˆ—è¡¨
   - Handleræ‰§è¡Œï¼šè´£ä»»é“¾æ¨¡å¼ï¼Œé¡ºåºæ‰§è¡Œ

2. **è´£ä»»é“¾æ¨¡å¼**
   - è§£è€¦ï¼šHandlerä¹‹é—´äº’ä¸ä¾èµ–
   - çµæ´»ï¼šå¯åŠ¨æ€å¢åˆ Handler
   - é¡ºåºï¼šæŒ‰æ³¨å†Œé¡ºåºæ‰§è¡Œ
   - ç»ˆæ­¢ï¼šä»»ä½•Handlerå¯ç»ˆæ­¢é“¾

3. **è·¨èŠ‚ç‚¹é€šä¿¡**
   - æŒ‰èŠ‚ç‚¹åˆ†ç»„è®¢é˜…è€…
   - æœ¬åœ°æ¨é€ï¼šç›´æ¥å†™å…¥è¿æ¥
   - è¿œç¨‹æ¨é€ï¼šRPCè½¬å‘
   - ä¼˜åŒ–ï¼šæ‰¹é‡RPCã€å¹¶è¡ŒRPCã€è¿æ¥æ± 

---

### **è®¾è®¡äº®ç‚¹**

| ç‰¹æ€§ | è¯´æ˜ |
|------|------|
| **äº‹ä»¶é©±åŠ¨** | å¼‚æ­¥è§£è€¦ï¼Œé«˜åå |
| **è´£ä»»é“¾æ¨¡å¼** | æ˜“æ‰©å±•ï¼ŒèŒè´£åˆ†ç¦» |
| **ä¸‰å±‚äº‹ä»¶æµè½¬** | åˆ†å±‚éš”ç¦»ï¼Œæ•…éšœéš”ç¦» |
| **è·¨èŠ‚ç‚¹è½¬å‘** | åˆ†å¸ƒå¼æ¨é€ï¼Œæ— å•ç‚¹ |
| **æ€§èƒ½ä¼˜åŒ–** | æ‰¹é‡å¤„ç†ã€å¯¹è±¡æ± ã€å¹¶è¡ŒRPC |

---

### **ä¸‹ä¸€èŠ‚é¢„å‘Š**

**5.4 æ ¸å¿ƒäº‹ä»¶è§£æ**
- EventConnectï¼šè¿æ¥å»ºç«‹æµç¨‹
- EventOnSendï¼šæ¶ˆæ¯å‘é€æµç¨‹
- EventChannelDistributeï¼šæ¶ˆæ¯åˆ†å‘æµç¨‹
- EventPushOnlineï¼šåœ¨çº¿æ¨é€æµç¨‹

---

> **ğŸ”— ç›¸å…³ä»£ç **ï¼š
> - äº‹ä»¶ä¸Šä¸‹æ–‡ï¼š`internal/eventbus/context.go`
> - äº‹ä»¶è·¯ç”±ï¼š`internal/eventbus/eventbus.go`
> - ç”¨æˆ·äº‹ä»¶æ± ï¼š`internal/user/reactor.go`
> - é¢‘é“äº‹ä»¶æ± ï¼š`internal/channel/reactor.go`
> - æ¨é€äº‹ä»¶æ± ï¼š`internal/pusher/reactor.go`
> - Handleræ³¨å†Œï¼š`internal/server/server.go:initHandlers()`
> - è·¨èŠ‚ç‚¹æ¨é€ï¼š`internal/pusher/handler/push_online.go`
> - RPCæ¥å£ï¼š`pkg/cluster/rpc/push.go`
