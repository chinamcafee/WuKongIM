# 5.3 事件处理链

> **本节目标**：深入理解事件处理链的工作机制，掌握责任链模式在WuKongIM中的应用

---

## 📋 目录
1. [事件处理链概述](#事件处理链概述)
2. [事件生成机制](#事件生成机制)
3. [事件入队流程](#事件入队流程)
4. [事件路由机制](#事件路由机制)
5. [Handler责任链模式](#handler责任链模式)
6. [事件转发与跨节点通信](#事件转发与跨节点通信)

---

## 1️⃣ 事件处理链概述

### **A. 完整处理链路**

```
事件处理完整流程：

┌─────────────────────────────────────────────────────┐
│  Step 1: 事件触发                                     │
│  ├─ 网络数据到达                                      │
│  ├─ 用户操作                                         │
│  └─ 定时任务                                         │
└─────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────┐
│  Step 2: 事件生成                                     │
│  ├─ 封装事件上下文（UserContext/ChannelContext等）    │
│  ├─ 设置事件类型（EventType）                         │
│  └─ 填充事件数据                                      │
└─────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────┐
│  Step 3: 事件入队                                     │
│  ├─ 选择事件池（User/Channel/Pusher）                 │
│  ├─ 写入事件队列                                      │
│  └─ 触发处理                                         │
└─────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────┐
│  Step 4: 事件路由                                     │
│  ├─ 根据EventType查找Handler列表                      │
│  ├─ 按注册顺序排列                                    │
│  └─ 构造Handler责任链                                 │
└─────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────┐
│  Step 5: Handler执行                                 │
│  ├─ Handler1.Handle()                                │
│  ├─ Handler2.Handle()                                │
│  └─ HandlerN.Handle()                                │
└─────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────┐
│  Step 6: 事件完成/产生新事件                           │
│  ├─ 处理成功                                         │
│  ├─ 生成后续事件                                      │
│  └─ 返回结果                                         │
└─────────────────────────────────────────────────────┘
```

---

### **B. 三层事件流转**

```
完整消息发送的三层事件流转：

Layer 1: 用户事件层（UserEventPool）
┌──────────────────────────────────────────┐
│ wknet.onData() 接收客户端SEND包           │
│         ↓                                 │
│ 生成 UserContext{EventOnSend}            │
│         ↓                                 │
│ UserEventPool.AddEvent(uid, event)       │
│         ↓                                 │
│ OnSendHandler责任链：                     │
│   ├─ PermissionHandler.Handle()          │
│   ├─ WebhookHandler.Handle()             │
│   └─ MessageHandler.Handle()             │
│         ↓                                 │
│ 产生 ChannelContext{EventChannelDistribute} │
└──────────────────────────────────────────┘
                    ↓
Layer 2: 频道事件层（ChannelEventPool）
┌──────────────────────────────────────────┐
│ ChannelEventPool.AddEvent(channelID, event) │
│         ↓                                 │
│ DistributeHandler责任链：                 │
│   ├─ PreCheckHandler.Handle()            │
│   ├─ StoreHandler.Handle()               │
│   ├─ ReplicateHandler.Handle()           │
│   └─ PostProcessHandler.Handle()         │
│         ↓                                 │
│ 产生 PushContext{EventPushOnline}        │
└──────────────────────────────────────────┘
                    ↓
Layer 3: 推送事件层（PusherEventPool）
┌──────────────────────────────────────────┐
│ PusherEventPool.AddEvent(event)          │
│         ↓                                 │
│ PushOnlineHandler责任链：                 │
│   ├─ FilterHandler.Handle()              │
│   ├─ EncodeHandler.Handle()              │
│   └─ WriteHandler.Handle()               │
│         ↓                                 │
│ 订阅者收到RECV包                          │
└──────────────────────────────────────────┘

特点：
├─ 每层专注自己的职责
├─ 层与层之间通过事件解耦
├─ 异步流转，不阻塞
└─ 故障隔离，互不影响
```

---

## 2️⃣ 事件生成机制

### **A. 事件上下文定义**

**代码位置**：`internal/eventbus/context.go`

```go
// 用户事件上下文
type UserContext struct {
	EventType EventType      // 事件类型
	Conn      wknet.Conn     // 连接对象
	Frame     *wkproto.Frame // 协议帧
	FromUID   string         // 发送者UID
	UID       string         // 目标UID（用于路由）
}

// 频道事件上下文
type ChannelContext struct {
	EventType   EventType       // 事件类型
	ChannelID   string          // 频道ID
	ChannelType uint8           // 频道类型
	Messages    []*Message      // 消息列表
	FromUID     string          // 发送者
	Subscribers []string        // 订阅者列表
}

// 推送事件上下文
type PushContext struct {
	EventType   EventType     // 事件类型
	Message     *Message      // 消息对象
	Subscribers []Subscriber  // 订阅者列表
	NodeID      uint64        // 节点ID
}
```

---

### **B. 事件生成位置**

#### **1. 网络层触发**

**代码位置**：`internal/server/server.go:619-652`

```go
func (s *Server) onData(conn wknet.Conn) error {
	for {
		// 1. 解析协议帧
		frame, err := s.protocol.Decode(conn)
		if err != nil {
			if err == io.ErrShortBuffer {
				break
			}
			return err
		}

		// 2. 根据帧类型生成事件
		switch frame.FrameType {
		case wkproto.SEND:
			// 生成 EventOnSend 事件
			event := &UserContext{
				EventType: EventOnSend,
				Conn:      conn,
				Frame:     frame,
				UID:       conn.UID(),
			}
			// 3. 提交到用户事件池
			s.userEventPool.AddEvent(conn.UID(), event)

		case wkproto.RECVACK:
			// 生成 EventRecvAck 事件
			event := &UserContext{
				EventType: EventRecvAck,
				Conn:      conn,
				Frame:     frame,
				UID:       conn.UID(),
			}
			s.userEventPool.AddEvent(conn.UID(), event)

		case wkproto.PING:
			// 生成 EventPing 事件
			event := &UserContext{
				EventType: EventPing,
				Conn:      conn,
				Frame:     frame,
				UID:       conn.UID(),
			}
			s.userEventPool.AddEvent(conn.UID(), event)

		// ... 其他帧类型
		}
	}
	return nil
}
```

---

#### **2. Handler内部触发**

**代码位置**：`internal/user/handler/event_onsend.go`

```go
func (h *OnSendHandler) Handle(ctx *UserContext) error {
	sendPacket := ctx.Frame.(*wkproto.SendPacket)

	// 1. 权限校验
	if err := h.checkPermission(ctx, sendPacket); err != nil {
		return err
	}

	// 2. Webhook回调
	if err := h.callWebhook(ctx, sendPacket); err != nil {
		return err
	}

	// 3. 构造消息对象
	msg := &Message{
		MessageID:   h.genMessageID(),
		FromUID:     ctx.Conn.UID(),
		ChannelID:   sendPacket.ChannelID,
		ChannelType: sendPacket.ChannelType,
		Payload:     sendPacket.Payload,
		Timestamp:   time.Now().UnixMilli(),
	}

	// 4. 生成频道事件
	channelEvent := &ChannelContext{
		EventType:   EventChannelDistribute,
		ChannelID:   sendPacket.ChannelID,
		ChannelType: sendPacket.ChannelType,
		Messages:    []*Message{msg},
		FromUID:     ctx.Conn.UID(),
	}

	// 5. 提交到频道事件池
	h.channelEventPool.AddEvent(sendPacket.ChannelID, sendPacket.ChannelType, channelEvent)

	return nil
}
```

**事件链式触发**：
```
EventOnSend (用户事件)
    ↓ OnSendHandler.Handle()
EventChannelDistribute (频道事件)
    ↓ DistributeHandler.Handle()
EventPushOnline (推送事件)
    ↓ PushOnlineHandler.Handle()
完成
```

---

#### **3. 定时任务触发**

**代码位置**：`internal/server/cron.go`

```go
func (s *Server) startCronJobs() {
	// 每10秒检查超时连接
	s.cron.AddFunc("@every 10s", func() {
		s.checkTimeoutConnections()
	})

	// 每1分钟清理过期数据
	s.cron.AddFunc("@every 1m", func() {
		s.cleanExpiredData()
	})
}

func (s *Server) checkTimeoutConnections() {
	// 遍历所有连接
	s.connMgr.Range(func(conn wknet.Conn) bool {
		// 检查超时（60秒无活动）
		if time.Since(conn.LastActivity()) > 60*time.Second {
			// 生成 EventConnTimeout 事件
			event := &UserContext{
				EventType: EventConnTimeout,
				Conn:      conn,
				UID:       conn.UID(),
			}
			s.userEventPool.AddEvent(conn.UID(), event)
		}
		return true
	})
}
```

---

### **C. 事件生成最佳实践**

**1. 事件上下文复用**
```go
var userContextPool = sync.Pool{
	New: func() any {
		return &UserContext{}
	},
}

func NewUserContext(eventType EventType, conn wknet.Conn, frame *wkproto.Frame) *UserContext {
	ctx := userContextPool.Get().(*UserContext)
	ctx.EventType = eventType
	ctx.Conn = conn
	ctx.Frame = frame
	ctx.UID = conn.UID()
	return ctx
}

func RecycleUserContext(ctx *UserContext) {
	// 重置字段
	ctx.EventType = 0
	ctx.Conn = nil
	ctx.Frame = nil
	ctx.UID = ""
	ctx.FromUID = ""
	userContextPool.Put(ctx)
}

优点：
✅ 减少GC压力
✅ 内存分配减少90%
```

---

**2. 批量生成事件**
```go
func (s *Server) onBatchData(conns []wknet.Conn) {
	events := make([]*UserContext, 0, len(conns))

	// 批量生成事件
	for _, conn := range conns {
		frame, err := s.protocol.Decode(conn)
		if err != nil {
			continue
		}

		event := NewUserContext(EventOnSend, conn, frame)
		events = append(events, event)
	}

	// 批量提交
	for _, event := range events {
		s.userEventPool.AddEvent(event.UID, event)
	}
}

优点：
✅ 减少函数调用次数
✅ 提高CPU缓存命中率
```

---

## 3️⃣ 事件入队流程

### **A. 用户事件入队**

**代码位置**：`internal/user/reactor.go`

```go
type UserReactor struct {
	userQueues sync.Map  // map[string]*UserQueue
	workers    []*Worker
	workerCount int
	queueSize  int
}

type UserQueue struct {
	uid        string
	queue      chan *UserContext
	processing atomic.Bool
}

func (r *UserReactor) AddEvent(uid string, event *UserContext) {
	// 1. 获取或创建用户队列
	queue := r.getOrCreateQueue(uid)

	// 2. 尝试写入队列
	select {
	case queue.queue <- event:
		// 成功写入
	default:
		// 队列满，记录告警
		log.Warn("user queue full",
			zap.String("uid", uid),
			zap.String("eventType", event.EventType.String()))
		metrics.UserQueueFullCount.Inc()
		return
	}

	// 3. 尝试触发处理
	r.tryProcess(queue)
}

func (r *UserReactor) getOrCreateQueue(uid string) *UserQueue {
	// 快速路径：从缓存获取
	if q, ok := r.userQueues.Load(uid); ok {
		return q.(*UserQueue)
	}

	// 慢速路径：创建新队列
	queue := &UserQueue{
		uid:   uid,
		queue: make(chan *UserContext, r.queueSize),
	}

	// 原子操作：只有一个协程能创建成功
	actual, loaded := r.userQueues.LoadOrStore(uid, queue)
	if loaded {
		// 其他协程已创建，使用已有的
		return actual.(*UserQueue)
	}

	return queue
}

func (r *UserReactor) tryProcess(queue *UserQueue) {
	// 使用CAS检查是否已在处理
	if !queue.processing.CompareAndSwap(false, true) {
		return  // 已有协程在处理，直接返回
	}

	// 选择Worker（负载均衡）
	worker := r.selectWorker(queue.uid)

	// 提交任务到Worker
	worker.Submit(func() {
		r.processQueue(queue)
	})
}
```

**入队流程图**：
```
AddEvent(uid, event)
    ↓
获取或创建UserQueue
    ↓
写入queue chan
    ├─ 成功 → 继续
    └─ 失败（满） → 记录告警，丢弃
    ↓
tryProcess()
    ↓
CAS检查 processing
    ├─ false→true → 继续
    └─ 已为true → 返回（避免重复处理）
    ↓
选择Worker
    ↓
提交任务到Worker
    ↓
Worker异步执行
```

---

### **B. 频道事件入队**

**代码位置**：`internal/channel/reactor.go`

```go
type ChannelReactor struct {
	channelQueues sync.Map  // map[string]*ChannelQueue
	workers       []*Worker
}

type ChannelQueue struct {
	channelID   string
	channelType uint8
	queue       chan *ChannelContext
	processing  atomic.Bool
}

func (r *ChannelReactor) AddEvent(channelID string, channelType uint8, event *ChannelContext) {
	// 1. 构造频道Key（ChannelID + ChannelType）
	key := channelKey(channelID, channelType)

	// 2. 获取或创建频道队列
	queue := r.getOrCreateQueue(key, channelID, channelType)

	// 3. 写入队列
	select {
	case queue.queue <- event:
		// 成功
	default:
		log.Warn("channel queue full",
			zap.String("channelID", channelID),
			zap.Uint8("channelType", channelType))
		return
	}

	// 4. 触发处理
	r.tryProcess(queue)
}

func channelKey(channelID string, channelType uint8) string {
	return fmt.Sprintf("%s-%d", channelID, channelType)
}
```

**为什么需要ChannelID + ChannelType？**
```
场景：
用户A在两个频道：
├─ 单聊频道：ChannelID="userB", ChannelType=1 (PERSON)
└─ 群聊频道：ChannelID="userB", ChannelType=2 (GROUP)

问题：
如果只用ChannelID，这两个频道会冲突！

解决：
使用 ChannelID + ChannelType 组合：
├─ Key1: "userB-1" → 单聊频道队列
└─ Key2: "userB-2" → 群聊频道队列

保证：
✅ 不同类型的频道独立队列
✅ 消息顺序不混乱
```

---

### **C. 推送事件入队**

**代码位置**：`internal/pusher/reactor.go`

```go
type PusherReactor struct {
	queue       chan *PushContext  // 全局队列
	workers     []*Worker
	workerCount int
}

func (r *PusherReactor) AddEvent(event *PushContext) {
	// 直接写入全局队列（无需分片）
	select {
	case r.queue <- event:
		// 成功
	default:
		// 队列满，丢弃（推送是尽力而为）
		log.Warn("pusher queue full")
		metrics.PusherQueueFullCount.Inc()
	}
}

func (r *PusherReactor) Run() {
	for {
		select {
		case event := <-r.queue:
			// 选择一个Worker（轮询）
			worker := r.workers[r.next.Add(1)%uint64(r.workerCount)]

			// 提交任务
			worker.Submit(func() {
				r.processEvent(event)
			})

		case <-r.stopChan:
			return
		}
	}
}
```

**为什么推送事件池用全局队列？**
```
对比：

UserEventPool：按UID分片
├─ 同一用户的事件必须顺序处理
├─ EventOnSend → EventRecvAck 顺序不能乱
└─ 必须分片

ChannelEventPool：按ChannelID分片
├─ 同一频道的消息必须顺序处理
├─ MessageSeq必须递增
└─ 必须分片

PusherEventPool：全局队列
├─ 推送事件之间无依赖关系
├─ 推送给A和推送给B可以乱序
├─ 全局队列+多Worker并行，吞吐更高
└─ 无需分片
```

---

## 4️⃣ 事件路由机制

### **A. Handler注册**

**代码位置**：`internal/eventbus/eventbus.go`

```go
// Handler路由表
var (
	userEventRouteMap    = make(map[EventType][]UserHandlerFunc)
	channelEventRouteMap = make(map[EventType][]ChannelHandlerFunc)
	pusherEventRouteMap  = make(map[EventType][]PusherHandlerFunc)
)

// Handler函数签名
type UserHandlerFunc func(*UserContext) error
type ChannelHandlerFunc func(*ChannelContext) error
type PusherHandlerFunc func(*PushContext) error

// 注册用户事件Handler
func RegisterUserHandlers(eventType EventType, handlers ...UserHandlerFunc) {
	userEventRouteMap[eventType] = append(userEventRouteMap[eventType], handlers...)
}

// 注册频道事件Handler
func RegisterChannelHandlers(eventType EventType, handlers ...ChannelHandlerFunc) {
	channelEventRouteMap[eventType] = append(channelEventRouteMap[eventType], handlers...)
}

// 注册推送事件Handler
func RegisterPusherHandlers(eventType EventType, handlers ...PusherHandlerFunc) {
	pusherEventRouteMap[eventType] = append(pusherEventRouteMap[eventType], handlers...)
}
```

---

### **B. Handler注册示例**

**代码位置**：`internal/server/server.go:initHandlers()`

```go
func (s *Server) initHandlers() {
	// ========== 用户事件Handler ==========

	// EventConnect：连接建立
	RegisterUserHandlers(EventConnect,
		s.connectHandler.Authenticate,   // 1. 认证
		s.connectHandler.LoadSession,    // 2. 加载会话
		s.connectHandler.SendConnack,    // 3. 发送连接确认
	)

	// EventOnSend：消息发送
	RegisterUserHandlers(EventOnSend,
		s.permissionHandler.Check,       // 1. 权限校验
		s.webhookHandler.OnSend,         // 2. Webhook回调
		s.onSendHandler.Handle,          // 3. 核心处理
	)

	// EventRecvAck：接收确认
	RegisterUserHandlers(EventRecvAck,
		s.recvAckHandler.UpdateOffset,   // 1. 更新客户端偏移量
		s.recvAckHandler.ClearQueue,     // 2. 清理已确认消息
	)

	// ========== 频道事件Handler ==========

	// EventChannelDistribute：消息分发
	RegisterChannelHandlers(EventChannelDistribute,
		s.distributeHandler.PreCheck,    // 1. 预检查
		s.distributeHandler.Store,       // 2. 存储消息
		s.distributeHandler.Replicate,   // 3. Raft复制
		s.distributeHandler.PostProcess, // 4. 后处理
	)

	// ========== 推送事件Handler ==========

	// EventPushOnline：在线推送
	RegisterPusherHandlers(EventPushOnline,
		s.pushHandler.FilterOnline,      // 1. 过滤在线订阅者
		s.pushHandler.Encode,            // 2. 编码RECV包
		s.pushHandler.Write,             // 3. 写入连接
	)
}
```

**注册顺序的重要性**：
```
Handler按注册顺序执行：

EventOnSend:
├─ 1. permissionHandler.Check()      ← 先校验权限
│   └─ 失败 → 终止链，返回错误
├─ 2. webhookHandler.OnSend()        ← 再调用Webhook
│   └─ 失败 → 终止链
└─ 3. onSendHandler.Handle()         ← 最后核心处理

顺序错误示例：
❌ 先调用Webhook，再校验权限
   └─ 问题：无权限的消息也触发了Webhook

✅ 先校验权限，再调用Webhook
   └─ 正确：只有有权限的消息才触发Webhook
```

---

### **C. 事件执行**

**代码位置**：`internal/eventbus/eventbus.go`

```go
// 执行用户事件
func ExecuteUserEvent(ctx *UserContext) error {
	// 1. 查找Handler列表
	handlers, ok := userEventRouteMap[ctx.EventType]
	if !ok {
		log.Warn("no handler for event",
			zap.String("eventType", ctx.EventType.String()))
		return nil
	}

	// 2. 执行Handler链
	for i, handler := range handlers {
		// 执行Handler
		err := handler(ctx)
		if err != nil {
			// Handler返回错误，终止链
			log.Error("handler error",
				zap.String("eventType", ctx.EventType.String()),
				zap.Int("handlerIndex", i),
				zap.Error(err))
			return err
		}
	}

	return nil
}

// 执行频道事件
func ExecuteChannelEvent(ctx *ChannelContext) error {
	handlers, ok := channelEventRouteMap[ctx.EventType]
	if !ok {
		return nil
	}

	for _, handler := range handlers {
		if err := handler(ctx); err != nil {
			return err
		}
	}

	return nil
}

// 执行推送事件
func ExecutePusherEvent(ctx *PushContext) error {
	handlers, ok := pusherEventRouteMap[ctx.EventType]
	if !ok {
		return nil
	}

	for _, handler := range handlers {
		if err := handler(ctx); err != nil {
			return err
		}
	}

	return nil
}
```

---

### **D. 事件路由优化**

**1. 路由表预编译**
```go
// ❌ 低效：每次查找都遍历
func ExecuteUserEvent(ctx *UserContext) error {
	for eventType, handlers := range userEventRouteMap {
		if eventType == ctx.EventType {
			// 执行...
		}
	}
}

// ✅ 高效：直接哈希查找
func ExecuteUserEvent(ctx *UserContext) error {
	handlers, ok := userEventRouteMap[ctx.EventType]  // O(1)
	if !ok {
		return nil
	}
	// 执行...
}
```

---

**2. Handler链缓存**
```go
type CachedHandlerChain struct {
	eventType EventType
	handlers  []UserHandlerFunc
}

var cachedChains = make(map[EventType]*CachedHandlerChain)

func BuildHandlerChain(eventType EventType) *CachedHandlerChain {
	// 检查缓存
	if chain, ok := cachedChains[eventType]; ok {
		return chain
	}

	// 构造链
	chain := &CachedHandlerChain{
		eventType: eventType,
		handlers:  userEventRouteMap[eventType],
	}

	// 缓存
	cachedChains[eventType] = chain
	return chain
}

func (c *CachedHandlerChain) Execute(ctx *UserContext) error {
	for _, handler := range c.handlers {
		if err := handler(ctx); err != nil {
			return err
		}
	}
	return nil
}

优点：
✅ 避免重复查找
✅ Handler列表预分配
```

---

## 5️⃣ Handler责任链模式

### **A. 责任链模式定义**

```
责任链模式（Chain of Responsibility）：

定义：
使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。
将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

结构：
┌─────────┐      ┌─────────┐      ┌─────────┐      ┌─────────┐
│Handler1 │─────→│Handler2 │─────→│Handler3 │─────→│Handler4 │
└─────────┘      └─────────┘      └─────────┘      └─────────┘
     ↓                ↓                ↓                ↓
  处理/传递       处理/传递       处理/传递       处理/传递

特点：
├─ 解耦：请求者不知道谁会处理
├─ 灵活：可动态增删Handler
├─ 顺序：按链顺序执行
└─ 终止：任何Handler可终止链
```

---

### **B. WuKongIM的责任链实现**

#### **示例1：消息发送责任链**

**完整流程**：
```
EventOnSend 事件
    ↓
┌─────────────────────────────────────────┐
│ Handler 1: PermissionHandler            │
│ 职责：权限校验                           │
│ ├─ 检查用户是否被封禁                    │
│ ├─ 检查是否有发送权限                    │
│ └─ 检查频道是否存在                      │
│ 结果：                                   │
│ ├─ 成功 → 继续下一个Handler              │
│ └─ 失败 → 返回错误，终止链                │
└─────────────────────────────────────────┘
    ↓（权限校验通过）
┌─────────────────────────────────────────┐
│ Handler 2: WebhookHandler               │
│ 职责：业务回调                           │
│ ├─ 调用业务方Webhook                     │
│ ├─ 获取扩展信息                          │
│ └─ 敏感词过滤                            │
│ 结果：                                   │
│ ├─ 成功 → 继续                           │
│ └─ 失败 → 终止链                         │
└─────────────────────────────────────────┘
    ↓（Webhook调用成功）
┌─────────────────────────────────────────┐
│ Handler 3: OnSendHandler                │
│ 职责：核心业务处理                        │
│ ├─ 生成MessageID                         │
│ ├─ 构造Message对象                       │
│ ├─ 发送SENDACK给客户端                   │
│ └─ 生成ChannelEvent                      │
│ 结果：                                   │
│ └─ 成功 → 链结束                         │
└─────────────────────────────────────────┘
```

**代码实现**：

```go
// Handler 1: 权限校验
type PermissionHandler struct{}

func (h *PermissionHandler) Check(ctx *UserContext) error {
	sendPacket := ctx.Frame.(*wkproto.SendPacket)

	// 1. 检查用户是否被封禁
	if h.isUserBanned(ctx.Conn.UID()) {
		return errors.New("user is banned")
	}

	// 2. 检查发送权限
	if !h.hasPermission(ctx.Conn.UID(), sendPacket.ChannelID) {
		return errors.New("no permission")
	}

	// 3. 检查频道是否存在
	if !h.channelExists(sendPacket.ChannelID, sendPacket.ChannelType) {
		return errors.New("channel not found")
	}

	return nil  // 通过，继续下一个Handler
}

// Handler 2: Webhook回调
type WebhookHandler struct {
	httpClient *http.Client
	webhookURL string
}

func (h *WebhookHandler) OnSend(ctx *UserContext) error {
	sendPacket := ctx.Frame.(*wkproto.SendPacket)

	// 1. 构造Webhook请求
	req := &WebhookRequest{
		Event:   "message.send",
		FromUID: ctx.Conn.UID(),
		ChannelID: sendPacket.ChannelID,
		Payload: sendPacket.Payload,
	}

	// 2. 调用Webhook
	resp, err := h.callWebhook(req)
	if err != nil {
		return err
	}

	// 3. 检查响应
	if resp.Code != 0 {
		return fmt.Errorf("webhook reject: %s", resp.Message)
	}

	// 4. 保存扩展信息到Context
	ctx.Extra = resp.Extra

	return nil
}

// Handler 3: 核心处理
type OnSendHandler struct {
	channelEventPool *ChannelEventPool
}

func (h *OnSendHandler) Handle(ctx *UserContext) error {
	sendPacket := ctx.Frame.(*wkproto.SendPacket)

	// 1. 生成MessageID
	messageID := h.genMessageID()

	// 2. 构造Message
	msg := &Message{
		MessageID:   messageID,
		ClientMsgNo: sendPacket.ClientMsgNo,
		FromUID:     ctx.Conn.UID(),
		ChannelID:   sendPacket.ChannelID,
		ChannelType: sendPacket.ChannelType,
		Payload:     sendPacket.Payload,
		Timestamp:   time.Now().UnixMilli(),
		Extra:       ctx.Extra,  // Webhook返回的扩展信息
	}

	// 3. 发送SENDACK
	ack := &wkproto.SendackPacket{
		ClientMsgNo: sendPacket.ClientMsgNo,
		MessageID:   messageID,
		MessageSeq:  0,  // 暂未分配
		ReasonCode:  0,  // 成功
	}
	ctx.Conn.WriteFrame(ack)

	// 4. 生成频道事件
	channelEvent := &ChannelContext{
		EventType:   EventChannelDistribute,
		ChannelID:   sendPacket.ChannelID,
		ChannelType: sendPacket.ChannelType,
		Messages:    []*Message{msg},
		FromUID:     ctx.Conn.UID(),
	}

	// 5. 提交到频道事件池
	h.channelEventPool.AddEvent(sendPacket.ChannelID, sendPacket.ChannelType, channelEvent)

	return nil
}
```

---

#### **示例2：消息分发责任链**

**完整流程**：
```
EventChannelDistribute 事件
    ↓
┌─────────────────────────────────────────┐
│ Handler 1: PreCheckHandler              │
│ 职责：预检查                             │
│ ├─ 检查频道是否存在                      │
│ ├─ 检查消息格式                          │
│ └─ 去重检查（ClientMsgNo）               │
└─────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────┐
│ Handler 2: StoreHandler                 │
│ 职责：存储消息                           │
│ ├─ 分配MessageSeq                        │
│ ├─ 写入PebbleDB                          │
│ └─ 更新索引                              │
└─────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────┐
│ Handler 3: ReplicateHandler             │
│ 职责：Raft复制                           │
│ ├─ 提议到Raft                            │
│ ├─ 等待多数派确认                        │
│ └─ 应用到状态机                          │
└─────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────┐
│ Handler 4: PostProcessHandler           │
│ 职责：后处理                             │
│ ├─ 查找订阅者                            │
│ ├─ 生成PushEvent                         │
│ └─ 更新统计数据                          │
└─────────────────────────────────────────┘
```

---

### **C. 责任链的优势**

**1. 易于扩展**
```go
// 需求：新增消息审核功能

// 只需添加新Handler
type AuditHandler struct{}

func (h *AuditHandler) Handle(ctx *UserContext) error {
	sendPacket := ctx.Frame.(*wkproto.SendPacket)

	// 审核逻辑
	if containsSensitiveWords(sendPacket.Payload) {
		return errors.New("sensitive content")
	}

	return nil
}

// 注册到链中（插入到合适位置）
RegisterUserHandlers(EventOnSend,
	permissionHandler.Check,  // 1. 权限校验
	auditHandler.Handle,      // 2. 内容审核（新增）
	webhookHandler.OnSend,    // 3. Webhook回调
	onSendHandler.Handle,     // 4. 核心处理
)

优点：
✅ 无需修改已有Handler
✅ 只需插入新Handler
✅ 符合开闭原则
```

---

**2. 职责分离**
```
每个Handler只负责一件事：

PermissionHandler：
└─ 只做权限校验

WebhookHandler：
└─ 只做业务回调

OnSendHandler：
└─ 只做核心处理

优点：
✅ 代码清晰
✅ 易于测试
✅ 易于维护
```

---

**3. 灵活组合**
```go
// 场景1：普通消息
RegisterUserHandlers(EventOnSend,
	permissionHandler.Check,
	webhookHandler.OnSend,
	onSendHandler.Handle,
)

// 场景2：系统消息（跳过Webhook）
RegisterUserHandlers(EventOnSystemSend,
	permissionHandler.Check,
	onSendHandler.Handle,  // 直接处理
)

// 场景3：批量消息（批量处理）
RegisterUserHandlers(EventOnBatchSend,
	permissionHandler.Check,
	batchHandler.Handle,  // 批量Handler
)
```

---

## 6️⃣ 事件转发与跨节点通信

### **A. 为什么需要跨节点通信？**

```
分布式场景：

节点A（北京）          节点B（上海）
    ├─ 用户A              ├─ 用户B
    └─ 用户C              └─ 用户D

场景：用户A发送消息到群聊（包含用户B、C、D）

问题：
├─ 用户A连接在节点A
├─ 用户B、D连接在节点B
└─ 如何推送消息给用户B、D？

解决：
节点A处理消息后，需要转发推送事件到节点B
```

---

### **B. 跨节点事件转发机制**

**代码位置**：`internal/pusher/handler/push_online.go`

```go
func (h *PushOnlineHandler) Handle(ctx *PushContext) error {
	// 1. 查找订阅者
	subscribers := h.getSubscribers(ctx.Message.ChannelID, ctx.Message.ChannelType)

	// 2. 按节点分组
	nodeGroups := h.groupByNode(subscribers)

	// 3. 本地推送
	localUIDs := nodeGroups[options.G.Cluster.NodeId]
	if len(localUIDs) > 0 {
		h.pushLocal(localUIDs, ctx.Message)
	}

	// 4. 跨节点推送
	for nodeID, uids := range nodeGroups {
		if nodeID == options.G.Cluster.NodeId {
			continue  // 跳过本地
		}

		// 发送RPC请求到目标节点
		h.pushRemote(nodeID, uids, ctx.Message)
	}

	return nil
}
```

**按节点分组**：
```go
func (h *PushOnlineHandler) groupByNode(subscribers []Subscriber) map[uint64][]string {
	groups := make(map[uint64][]string)

	for _, sub := range subscribers {
		// 查找用户连接在哪个节点
		nodeID := h.findNodeByUID(sub.UID)
		if nodeID == 0 {
			// 离线，跳过
			continue
		}

		// 按节点分组
		groups[nodeID] = append(groups[nodeID], sub.UID)
	}

	return groups
}

func (h *PushOnlineHandler) findNodeByUID(uid string) uint64 {
	// 从分布式存储（如Redis）查找用户在线信息
	nodeID, err := h.redis.HGet(ctx, "user:online", uid).Uint64()
	if err != nil {
		return 0  // 离线
	}
	return nodeID
}
```

**示例**：
```
订阅者列表：
├─ userA → 节点1
├─ userB → 节点2
├─ userC → 节点1
└─ userD → 节点2

分组结果：
groups[1] = ["userA", "userC"]
groups[2] = ["userB", "userD"]

推送：
├─ 节点1（本地）：直接推送给userA、userC
└─ 节点2（远程）：RPC推送给userB、userD
```

---

### **C. 跨节点RPC实现**

**代码位置**：`pkg/cluster/rpc/push.go`

```go
// RPC接口定义
type PushService interface {
	// 推送消息
	Push(ctx context.Context, req *PushRequest) (*PushResponse, error)
}

type PushRequest struct {
	UIDs    []string  // 目标用户列表
	Message *Message  // 消息对象
}

type PushResponse struct {
	SuccessCount int  // 成功推送数量
	FailedUIDs   []string  // 推送失败的UID
}

// 客户端实现
type PushClient struct {
	conns map[uint64]*grpc.ClientConn  // 节点连接池
}

func (c *PushClient) PushRemote(nodeID uint64, uids []string, msg *Message) error {
	// 1. 获取目标节点连接
	conn, err := c.getConn(nodeID)
	if err != nil {
		return err
	}

	// 2. 创建RPC客户端
	client := pb.NewPushServiceClient(conn)

	// 3. 构造请求
	req := &pb.PushRequest{
		Uids:    uids,
		Message: convertMessage(msg),
	}

	// 4. 发送RPC请求
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	resp, err := client.Push(ctx, req)
	if err != nil {
		return err
	}

	// 5. 检查结果
	if len(resp.FailedUids) > 0 {
		log.Warn("push failed",
			zap.Strings("failedUIDs", resp.FailedUids))
	}

	return nil
}
```

**服务端实现**：
```go
// 服务端实现
type PushServer struct {
	pusher *Pusher
}

func (s *PushServer) Push(ctx context.Context, req *pb.PushRequest) (*pb.PushResponse, error) {
	// 1. 转换消息对象
	msg := convertPBMessage(req.Message)

	successCount := 0
	failedUIDs := []string{}

	// 2. 逐个推送
	for _, uid := range req.Uids {
		// 查找本地连接
		conns := s.pusher.connMgr.ConnsByUID(uid)
		if len(conns) == 0 {
			failedUIDs = append(failedUIDs, uid)
			continue
		}

		// 编码RECV包
		recvPacket := &wkproto.RecvPacket{
			MessageID:   msg.MessageID,
			MessageSeq:  msg.MessageSeq,
			FromUID:     msg.FromUID,
			ChannelID:   msg.ChannelID,
			ChannelType: msg.ChannelType,
			Payload:     msg.Payload,
			Timestamp:   msg.Timestamp,
		}

		// 写入连接
		for _, conn := range conns {
			if err := conn.WriteFrame(recvPacket); err != nil {
				log.Error("write frame error", zap.Error(err))
			} else {
				successCount++
			}
		}
	}

	return &pb.PushResponse{
		SuccessCount: int32(successCount),
		FailedUids:   failedUIDs,
	}, nil
}
```

---

### **D. 跨节点通信优化**

**1. 批量RPC**
```go
// ❌ 低效：逐个RPC
for nodeID, uids := range nodeGroups {
	for _, uid := range uids {
		h.pushRemote(nodeID, []string{uid}, msg)  // N次RPC
	}
}

// ✅ 高效：批量RPC
for nodeID, uids := range nodeGroups {
	h.pushRemote(nodeID, uids, msg)  // 1次RPC
}

优点：
├─ 减少RPC次数（从N次减少到1次）
├─ 减少网络开销
└─ 提高吞吐量
```

---

**2. 并行RPC**
```go
func (h *PushOnlineHandler) pushRemoteParallel(nodeGroups map[uint64][]string, msg *Message) {
	var wg sync.WaitGroup

	for nodeID, uids := range nodeGroups {
		wg.Add(1)

		// 并行发送RPC
		go func(nid uint64, us []string) {
			defer wg.Done()
			h.pushRemote(nid, us, msg)
		}(nodeID, uids)
	}

	// 等待所有RPC完成
	wg.Wait()
}

优点：
✅ 并行推送到多个节点
✅ 延迟取决于最慢节点
✅ 吞吐量大幅提升
```

---

**3. 连接池复用**
```go
type PushClient struct {
	conns sync.Map  // map[uint64]*grpc.ClientConn
}

func (c *PushClient) getConn(nodeID uint64) (*grpc.ClientConn, error) {
	// 从连接池获取
	if conn, ok := c.conns.Load(nodeID); ok {
		return conn.(*grpc.ClientConn), nil
	}

	// 创建新连接
	addr := c.getNodeAddr(nodeID)
	conn, err := grpc.Dial(addr,
		grpc.WithInsecure(),
		grpc.WithKeepaliveParams(keepalive.ClientParameters{
			Time:    30 * time.Second,
			Timeout: 10 * time.Second,
		}),
	)
	if err != nil {
		return nil, err
	}

	// 存储到连接池
	c.conns.Store(nodeID, conn)

	return conn, nil
}

优点：
✅ 连接复用，避免频繁建立
✅ 长连接，减少握手开销
✅ Keepalive保持连接活跃
```

---

## 7️⃣ 总结

### **核心要点**

1. **事件处理链路**
   - 事件生成：网络层、Handler内部、定时任务
   - 事件入队：按UID/ChannelID分片，或全局队列
   - 事件路由：基于EventType查找Handler列表
   - Handler执行：责任链模式，顺序执行

2. **责任链模式**
   - 解耦：Handler之间互不依赖
   - 灵活：可动态增删Handler
   - 顺序：按注册顺序执行
   - 终止：任何Handler可终止链

3. **跨节点通信**
   - 按节点分组订阅者
   - 本地推送：直接写入连接
   - 远程推送：RPC转发
   - 优化：批量RPC、并行RPC、连接池

---

### **设计亮点**

| 特性 | 说明 |
|------|------|
| **事件驱动** | 异步解耦，高吞吐 |
| **责任链模式** | 易扩展，职责分离 |
| **三层事件流转** | 分层隔离，故障隔离 |
| **跨节点转发** | 分布式推送，无单点 |
| **性能优化** | 批量处理、对象池、并行RPC |

---

### **下一节预告**

**5.4 核心事件解析**
- EventConnect：连接建立流程
- EventOnSend：消息发送流程
- EventChannelDistribute：消息分发流程
- EventPushOnline：在线推送流程

---

> **🔗 相关代码**：
> - 事件上下文：`internal/eventbus/context.go`
> - 事件路由：`internal/eventbus/eventbus.go`
> - 用户事件池：`internal/user/reactor.go`
> - 频道事件池：`internal/channel/reactor.go`
> - 推送事件池：`internal/pusher/reactor.go`
> - Handler注册：`internal/server/server.go:initHandlers()`
> - 跨节点推送：`internal/pusher/handler/push_online.go`
> - RPC接口：`pkg/cluster/rpc/push.go`
