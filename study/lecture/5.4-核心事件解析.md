# 5.4 核心事件解析

> **本节目标**：深入理解WuKongIM核心事件的完整处理流程，掌握IM系统的关键业务逻辑

---

## 📋 目录
1. [EventConnect - 连接建立](#eventconnect---连接建立)
2. [EventOnSend - 消息发送](#eventonsend---消息发送)
3. [EventChannelDistribute - 消息分发](#eventchanneldistribute---消息分发)
4. [EventPushOnline - 在线推送](#eventpushonline---在线推送)
5. [其他核心事件](#其他核心事件)
6. [事件流转完整案例](#事件流转完整案例)

---

## 1️⃣ EventConnect - 连接建立

### **A. 事件触发时机**

```
客户端连接流程：

1. TCP连接建立
   ├─ 客户端发起TCP连接
   ├─ 三次握手完成
   └─ 连接建立成功
       ↓
2. 发送CONNECT包
   ├─ 包含：Version、DeviceID、UID、Token、ClientTimestamp
   └─ 客户端主动发送（连接后立即发送）
       ↓
3. 服务端接收
   ├─ wknet.onData() 接收数据
   ├─ Protocol.Decode() 解析CONNECT Frame
   └─ 生成 EventConnect 事件
       ↓
4. EventConnect处理
   ├─ 认证Token
   ├─ 加载会话
   ├─ 发送CONNACK
   └─ 连接建立完成
```

---

### **B. Handler责任链**

**代码位置**：`internal/server/server.go:initHandlers()`

```go
RegisterUserHandlers(EventConnect,
	s.connectHandler.Authenticate,   // 1. 认证
	s.connectHandler.LoadSession,    // 2. 加载会话
	s.connectHandler.SendConnack,    // 3. 发送连接确认
)
```

---

### **C. Handler详解**

#### **Handler 1: Authenticate（认证）**

**代码位置**：`internal/user/handler/connect.go`

```go
func (h *ConnectHandler) Authenticate(ctx *UserContext) error {
	connectPacket := ctx.Frame.(*wkproto.ConnectPacket)

	// 1. 解析Token
	token := connectPacket.Token
	if token == "" {
		return errors.New("token is empty")
	}

	// 2. 调用业务方Token验证API
	req := &TokenVerifyRequest{
		UID:      connectPacket.UID,
		DeviceID: connectPacket.DeviceID,
		Token:    token,
	}

	resp, err := h.httpClient.Post(h.config.TokenVerifyURL, req)
	if err != nil {
		log.Error("token verify failed",
			zap.String("uid", connectPacket.UID),
			zap.Error(err))
		return errors.New("token verify failed")
	}

	// 3. 检查验证结果
	if resp.Code != 0 {
		log.Warn("token invalid",
			zap.String("uid", connectPacket.UID),
			zap.String("reason", resp.Message))
		return errors.New("token invalid")
	}

	// 4. 保存认证信息到连接
	ctx.Conn.SetUID(connectPacket.UID)
	ctx.Conn.SetDeviceID(connectPacket.DeviceID)
	ctx.Conn.SetDeviceLevel(resp.DeviceLevel)  // 设备等级（用于踢人策略）

	// 5. 更新在线状态（写入Redis）
	err = h.updateOnlineStatus(connectPacket.UID, h.nodeID)
	if err != nil {
		log.Error("update online status failed", zap.Error(err))
	}

	return nil
}
```

**Token验证流程**：
```
客户端CONNECT包
    ↓
提取Token
    ↓
HTTP请求业务方Token验证API
    ↓
业务方验证：
├─ 检查Token是否有效
├─ 检查Token是否过期
├─ 检查用户是否存在
└─ 检查用户是否被封禁
    ↓
返回验证结果：
├─ Code=0：验证通过
│   └─ DeviceLevel: 设备等级（用于多端登录踢人策略）
└─ Code!=0：验证失败
    └─ Message: 失败原因
```

---

#### **Handler 2: LoadSession（加载会话）**

```go
func (h *ConnectHandler) LoadSession(ctx *UserContext) error {
	uid := ctx.Conn.UID()

	// 1. 查询用户订阅的频道列表
	channels, err := h.channelService.GetUserChannels(uid)
	if err != nil {
		log.Error("get user channels failed", zap.Error(err))
		return err
	}

	// 2. 自动订阅频道
	for _, ch := range channels {
		// 添加订阅关系
		h.subscriber.AddSubscriber(ch.ChannelID, ch.ChannelType, uid)
	}

	// 3. 加载离线消息数量
	offlineMsgCount, err := h.messageService.GetOfflineMessageCount(uid)
	if err != nil {
		log.Error("get offline message count failed", zap.Error(err))
	}

	// 4. 保存到连接上下文
	ctx.Conn.SetContext("offlineMsgCount", offlineMsgCount)

	log.Info("session loaded",
		zap.String("uid", uid),
		zap.Int("channelCount", len(channels)),
		zap.Int("offlineMsgCount", offlineMsgCount))

	return nil
}
```

**会话加载内容**：
```
会话信息：
├─ 订阅的频道列表
│   ├─ 单聊频道（ChannelType=1）
│   ├─ 群聊频道（ChannelType=2）
│   └─ 系统频道（ChannelType=3）
├─ 离线消息数量
│   └─ 用于客户端显示红点
└─ 用户设置
    ├─ 消息免打扰设置
    └─ 其他用户偏好设置
```

---

#### **Handler 3: SendConnack（发送连接确认）**

```go
func (h *ConnectHandler) SendConnack(ctx *UserContext) error {
	connectPacket := ctx.Frame.(*wkproto.ConnectPacket)

	// 1. 计算时间差（客户端与服务端）
	clientTime := connectPacket.ClientTimestamp
	serverTime := time.Now().UnixMilli()
	timeDiff := serverTime - clientTime

	// 2. 获取离线消息数量
	offlineMsgCount, _ := ctx.Conn.Context("offlineMsgCount").(int)

	// 3. 构造CONNACK包
	connackPacket := &wkproto.ConnackPacket{
		ReasonCode:      wkproto.ReasonSuccess,
		ServerTime:      serverTime,
		TimeDiff:        timeDiff,
		OfflineMsgCount: offlineMsgCount,
		NodeID:          h.nodeID,
	}

	// 4. 发送CONNACK
	err := ctx.Conn.WriteFrame(connackPacket)
	if err != nil {
		log.Error("write connack failed", zap.Error(err))
		return err
	}

	log.Info("connack sent",
		zap.String("uid", ctx.Conn.UID()),
		zap.Int64("timeDiff", timeDiff),
		zap.Int("offlineMsgCount", offlineMsgCount))

	return nil
}
```

**CONNACK包内容**：
```
CONNACK包字段：
┌─────────────────────────────────────┐
│ ReasonCode: 0（成功）                │
├─────────────────────────────────────┤
│ ServerTime: 1704067200000            │
│ ├─ 服务端时间戳（毫秒）               │
│ └─ 用于客户端同步时间                 │
├─────────────────────────────────────┤
│ TimeDiff: 50                         │
│ ├─ 客户端与服务端时间差（毫秒）        │
│ └─ 用于客户端校准时间                 │
├─────────────────────────────────────┤
│ OfflineMsgCount: 10                  │
│ ├─ 离线消息数量                       │
│ └─ 用于显示红点                       │
├─────────────────────────────────────┤
│ NodeID: 1                            │
│ └─ 服务端节点ID                       │
└─────────────────────────────────────┘
```

---

### **D. 连接建立完整时序图**

```
客户端                 网络层                  EventHandler               业务API
  │                     │                        │                        │
  │──TCP连接───────────→│                        │                        │
  │                     │                        │                        │
  │──CONNECT包─────────→│                        │                        │
  │                     │──解析Frame────────────→│                        │
  │                     │                        │──Token验证────────────→│
  │                     │                        │←─验证结果──────────────│
  │                     │                        │                        │
  │                     │                        │──加载会话（订阅频道）───→│
  │                     │                        │←─会话数据──────────────│
  │                     │                        │                        │
  │                     │←─CONNACK包─────────────│                        │
  │←─CONNACK包─────────│                        │                        │
  │                     │                        │                        │
  │   连接建立完成       │                        │                        │
  │                     │                        │                        │
```

---

## 2️⃣ EventOnSend - 消息发送

### **A. 事件触发时机**

```
客户端发送消息流程：

1. 客户端构造SEND包
   ├─ ClientMsgNo: 客户端消息ID（去重）
   ├─ ChannelID: 目标频道
   ├─ ChannelType: 频道类型
   └─ Payload: 消息内容
       ↓
2. 发送SEND包
   └─ TCP连接发送数据
       ↓
3. 服务端接收
   ├─ wknet.onData() 接收
   ├─ Protocol.Decode() 解析
   └─ 生成 EventOnSend 事件
       ↓
4. EventOnSend处理
   ├─ 权限校验
   ├─ Webhook回调
   ├─ 生成Message
   ├─ 发送SENDACK
   └─ 触发 EventChannelDistribute
```

---

### **B. Handler责任链**

```go
RegisterUserHandlers(EventOnSend,
	s.permissionHandler.Check,       // 1. 权限校验
	s.webhookHandler.OnSend,         // 2. Webhook回调
	s.onSendHandler.Handle,          // 3. 核心处理
)
```

---

### **C. Handler详解**

#### **Handler 1: 权限校验**

**代码位置**：`internal/service/permission.go`

```go
func (h *PermissionHandler) Check(ctx *UserContext) error {
	sendPacket := ctx.Frame.(*wkproto.SendPacket)
	uid := ctx.Conn.UID()

	// 1. 检查用户是否被封禁
	banned, err := h.userService.IsUserBanned(uid)
	if err != nil {
		return err
	}
	if banned {
		return errors.New("user is banned")
	}

	// 2. 检查是否在黑名单
	inBlacklist, err := h.channelService.IsInBlacklist(
		sendPacket.ChannelID,
		sendPacket.ChannelType,
		uid,
	)
	if err != nil {
		return err
	}
	if inBlacklist {
		return errors.New("in blacklist")
	}

	// 3. 检查是否被禁言
	muted, err := h.channelService.IsMuted(
		sendPacket.ChannelID,
		sendPacket.ChannelType,
		uid,
	)
	if err != nil {
		return err
	}
	if muted {
		return errors.New("user is muted")
	}

	// 4. 检查频道是否存在
	exists, err := h.channelService.ChannelExists(
		sendPacket.ChannelID,
		sendPacket.ChannelType,
	)
	if err != nil {
		return err
	}
	if !exists {
		return errors.New("channel not found")
	}

	// 5. 检查发送权限（群聊特殊权限）
	if sendPacket.ChannelType == wkproto.ChannelTypeGroup {
		hasPermission, err := h.channelService.HasSendPermission(
			sendPacket.ChannelID,
			uid,
		)
		if err != nil {
			return err
		}
		if !hasPermission {
			return errors.New("no permission to send")
		}
	}

	return nil
}
```

**权限检查项**：
```
权限校验清单：
├─ 用户是否被封禁
├─ 用户是否在频道黑名单
├─ 用户是否被禁言
├─ 频道是否存在
└─ 用户是否有发送权限（群聊）
    ├─ 普通群：所有成员可发
    ├─ 禁言群：只有管理员可发
    └─ 公告群：只有群主可发
```

---

#### **Handler 2: Webhook回调**

**代码位置**：`internal/service/webhook.go`

```go
func (h *WebhookHandler) OnSend(ctx *UserContext) error {
	sendPacket := ctx.Frame.(*wkproto.SendPacket)

	// 1. 构造Webhook请求
	req := &WebhookSendRequest{
		Event:       "message.send",
		FromUID:     ctx.Conn.UID(),
		ChannelID:   sendPacket.ChannelID,
		ChannelType: sendPacket.ChannelType,
		Payload:     base64.StdEncoding.EncodeToString(sendPacket.Payload),
		ClientMsgNo: sendPacket.ClientMsgNo,
	}

	// 2. 发送HTTP请求
	resp, err := h.callWebhook(req)
	if err != nil {
		log.Error("webhook call failed", zap.Error(err))
		// Webhook失败不影响消息发送（配置决定）
		if h.config.WebhookRequired {
			return err
		}
		return nil
	}

	// 3. 检查业务方响应
	if resp.Code != 0 {
		// 业务方拒绝消息
		log.Warn("webhook reject message",
			zap.String("reason", resp.Message))
		return fmt.Errorf("webhook reject: %s", resp.Message)
	}

	// 4. 保存业务方返回的扩展信息
	if resp.Extra != nil {
		ctx.Extra = resp.Extra
	}

	// 5. 业务方可修改消息内容
	if resp.NewPayload != "" {
		newPayload, _ := base64.StdEncoding.DecodeString(resp.NewPayload)
		sendPacket.Payload = newPayload
	}

	return nil
}
```

**Webhook应用场景**：
```
业务方可通过Webhook实现：

1. 敏感词过滤
   └─ 检测消息内容，拒绝违规消息

2. 消息审核
   └─ 人工审核或AI审核

3. 消息扩展
   └─ 添加额外信息（如@提醒、引用消息）

4. 消息转换
   └─ 修改消息内容（如替换敏感词）

5. 统计分析
   └─ 记录消息发送日志

6. 业务逻辑
   └─ 触发业务流程（如积分增加）
```

---

#### **Handler 3: 核心处理**

**代码位置**：`internal/user/handler/event_onsend.go`

```go
func (h *OnSendHandler) Handle(ctx *UserContext) error {
	sendPacket := ctx.Frame.(*wkproto.SendPacket)
	fromUID := ctx.Conn.UID()

	// 1. 生成MessageID（全局唯一）
	messageID := h.genMessageID()

	// 2. 构造Message对象
	msg := &Message{
		MessageID:   messageID,
		MessageSeq:  0,  // 暂未分配（ChannelEventPool中分配）
		ClientMsgNo: sendPacket.ClientMsgNo,
		FromUID:     fromUID,
		ChannelID:   sendPacket.ChannelID,
		ChannelType: sendPacket.ChannelType,
		Payload:     sendPacket.Payload,
		Timestamp:   time.Now().UnixMilli(),
		Extra:       ctx.Extra,  // Webhook返回的扩展信息
	}

	// 3. 发送SENDACK给客户端
	sendackPacket := &wkproto.SendackPacket{
		ClientMsgNo: sendPacket.ClientMsgNo,
		MessageID:   messageID,
		MessageSeq:  0,  // 暂未分配
		ReasonCode:  wkproto.ReasonSuccess,
	}
	ctx.Conn.WriteFrame(sendackPacket)

	// 4. 生成频道事件
	channelEvent := &ChannelContext{
		EventType:   EventChannelDistribute,
		ChannelID:   sendPacket.ChannelID,
		ChannelType: sendPacket.ChannelType,
		Messages:    []*Message{msg},
		FromUID:     fromUID,
	}

	// 5. 提交到频道事件池
	h.channelEventPool.AddEvent(
		sendPacket.ChannelID,
		sendPacket.ChannelType,
		channelEvent,
	)

	log.Info("message send",
		zap.String("messageID", messageID),
		zap.String("fromUID", fromUID),
		zap.String("channelID", sendPacket.ChannelID))

	return nil
}
```

**MessageID生成算法**：
```go
func (h *OnSendHandler) genMessageID() string {
	// Snowflake算法生成全局唯一ID
	// 64位：
	// ├─ 1位：符号位（0）
	// ├─ 41位：时间戳（毫秒）
	// ├─ 10位：机器ID
	// └─ 12位：序列号

	timestamp := time.Now().UnixMilli() - epoch  // 41位
	machineID := h.nodeID                         // 10位
	sequence := h.sequence.Add(1) & 0xFFF         // 12位

	id := (timestamp << 22) | (machineID << 12) | sequence

	return fmt.Sprintf("%d", id)
}
```

---

### **D. 消息发送完整时序图**

```
客户端          网络层           UserEventPool       ChannelEventPool
  │              │                    │                    │
  │──SEND包─────→│                    │                    │
  │              │──EventOnSend──────→│                    │
  │              │                    │──权限校验──────────→Business API
  │              │                    │←─通过───────────────│
  │              │                    │                    │
  │              │                    │──Webhook回调───────→Business API
  │              │                    │←─通过───────────────│
  │              │                    │                    │
  │              │                    │──生成MessageID─────→│
  │              │                    │──发送SENDACK───────→│
  │←─SENDACK────│←──────────────────│                    │
  │              │                    │                    │
  │              │                    │──EventChannelDistribute→│
  │              │                    │                    │──存储消息
  │              │                    │                    │──Raft复制
  │              │                    │                    │
```

---

## 3️⃣ EventChannelDistribute - 消息分发

### **A. 事件触发时机**

```
EventChannelDistribute 触发：

由 EventOnSend 的 OnSendHandler 触发：
├─ OnSendHandler.Handle()
├─ 构造 ChannelContext{EventChannelDistribute}
└─ ChannelEventPool.AddEvent()
    ↓
EventChannelDistribute 职责：
├─ 消息存储
├─ Raft共识
├─ 分配MessageSeq
└─ 触发推送事件
```

---

### **B. Handler责任链**

```go
RegisterChannelHandlers(EventChannelDistribute,
	s.distributeHandler.PreCheck,    // 1. 预检查
	s.distributeHandler.Store,       // 2. 存储消息
	s.distributeHandler.Replicate,   // 3. Raft复制
	s.distributeHandler.PostProcess, // 4. 后处理
)
```

---

### **C. Handler详解**

#### **Handler 1: PreCheck（预检查）**

```go
func (h *DistributeHandler) PreCheck(ctx *ChannelContext) error {
	// 1. 检查消息列表
	if len(ctx.Messages) == 0 {
		return errors.New("no messages")
	}

	// 2. 检查频道是否存在
	exists, err := h.channelService.ChannelExists(ctx.ChannelID, ctx.ChannelType)
	if err != nil {
		return err
	}
	if !exists {
		return errors.New("channel not found")
	}

	// 3. 去重检查（ClientMsgNo）
	for _, msg := range ctx.Messages {
		exists, err := h.messageService.MessageExists(msg.ClientMsgNo)
		if err != nil {
			log.Error("check message exists failed", zap.Error(err))
			continue
		}
		if exists {
			// 消息已存在，跳过
			msg.Skip = true
		}
	}

	return nil
}
```

---

#### **Handler 2: Store（存储消息）**

**代码位置**：`internal/channel/handler/distribute.go`

```go
func (h *DistributeHandler) Store(ctx *ChannelContext) error {
	// 1. 批量分配MessageSeq
	startSeq, err := h.seqService.AllocSeq(ctx.ChannelID, ctx.ChannelType, len(ctx.Messages))
	if err != nil {
		return err
	}

	// 2. 分配Seq给每条消息
	for i, msg := range ctx.Messages {
		if msg.Skip {
			continue
		}
		msg.MessageSeq = startSeq + uint64(i)
	}

	// 3. 批量写入数据库（PebbleDB）
	batch := h.db.NewBatch()
	for _, msg := range ctx.Messages {
		if msg.Skip {
			continue
		}

		// 构造存储Key
		key := messageKey(msg.ChannelID, msg.MessageSeq)

		// 序列化消息
		data, err := msg.Encode()
		if err != nil {
			return err
		}

		// 写入Batch
		batch.Put(key, data)
	}

	// 4. 提交Batch
	err = batch.Commit()
	if err != nil {
		return err
	}

	log.Info("messages stored",
		zap.String("channelID", ctx.ChannelID),
		zap.Int("count", len(ctx.Messages)),
		zap.Uint64("startSeq", startSeq))

	return nil
}
```

**MessageSeq分配**：
```
MessageSeq生成：

每个频道独立的递增序号：
├─ Channel A: 1, 2, 3, 4, ...
├─ Channel B: 1, 2, 3, 4, ...
└─ Channel C: 1, 2, 3, 4, ...

批量分配：
├─ 一次分配N个连续序号
├─ 减少分配次数
└─ 提高性能

存储：
├─ Key: channel:channelID:seq:messageSeq
├─ Value: 消息数据（序列化）
└─ PebbleDB LSM-Tree 存储
```

---

#### **Handler 3: Replicate（Raft复制）**

```go
func (h *DistributeHandler) Replicate(ctx *ChannelContext) error {
	// 1. 构造Raft Proposal
	proposal := &Proposal{
		Type:        ProposalTypeMessage,
		ChannelID:   ctx.ChannelID,
		ChannelType: ctx.ChannelType,
		Messages:    ctx.Messages,
	}

	// 2. 序列化Proposal
	data, err := proposal.Encode()
	if err != nil {
		return err
	}

	// 3. 提议到Raft
	err = h.raftServer.Propose(ctx.ChannelID, data)
	if err != nil {
		return err
	}

	// 4. 等待Raft提交（阻塞）
	select {
	case <-ctx.ApplyChan:
		// Raft已应用到状态机
		return nil

	case <-time.After(5 * time.Second):
		// 超时
		return errors.New("raft replicate timeout")
	}
}
```

**Raft复制流程**：
```
Raft复制保证消息不丢失：

1. Leader提议
   └─ DistributeHandler.Replicate()
       ↓
2. 复制到Follower
   ├─ Leader发送AppendEntries RPC
   └─ Follower写入Raft日志
       ↓
3. 等待多数派确认
   ├─ 3节点集群：需要2个节点确认
   └─ 5节点集群：需要3个节点确认
       ↓
4. 提交日志
   └─ Leader标记日志为已提交
       ↓
5. 应用到状态机
   ├─ 调用Apply()回调
   └─ 触发ApplyChan通知
       ↓
6. Replicate返回成功
```

---

#### **Handler 4: PostProcess（后处理）**

```go
func (h *DistributeHandler) PostProcess(ctx *ChannelContext) error {
	// 1. 查找订阅者
	subscribers, err := h.subscriberService.GetSubscribers(
		ctx.ChannelID,
		ctx.ChannelType,
	)
	if err != nil {
		return err
	}

	// 2. 生成推送事件
	for _, msg := range ctx.Messages {
		if msg.Skip {
			continue
		}

		pushEvent := &PushContext{
			EventType:   EventPushOnline,
			Message:     msg,
			Subscribers: subscribers,
		}

		// 3. 提交到推送事件池
		h.pusherEventPool.AddEvent(pushEvent)
	}

	// 4. 更新统计数据
	metrics.MessageCount.Add(float64(len(ctx.Messages)))

	log.Info("distribute post process",
		zap.String("channelID", ctx.ChannelID),
		zap.Int("subscriberCount", len(subscribers)))

	return nil
}
```

---

## 4️⃣ EventPushOnline - 在线推送

### **A. 事件触发时机**

```
EventPushOnline 触发：

由 EventChannelDistribute 的 PostProcess 触发：
├─ 查找订阅者
├─ 构造 PushContext{EventPushOnline}
└─ PusherEventPool.AddEvent()
    ↓
EventPushOnline 职责：
├─ 过滤在线订阅者
├─ 编码RECV包
├─ 写入连接
└─ 跨节点推送
```

---

### **B. Handler责任链**

```go
RegisterPusherHandlers(EventPushOnline,
	s.pushHandler.FilterOnline,      // 1. 过滤在线订阅者
	s.pushHandler.Encode,            // 2. 编码RECV包
	s.pushHandler.Write,             // 3. 写入连接
)
```

---

### **C. Handler详解**

#### **Handler 1: FilterOnline（过滤在线订阅者）**

```go
func (h *PushOnlineHandler) FilterOnline(ctx *PushContext) error {
	onlineSubscribers := make([]Subscriber, 0, len(ctx.Subscribers))

	// 1. 过滤在线订阅者
	for _, sub := range ctx.Subscribers {
		// 查询用户在线状态
		nodeID, err := h.redis.HGet(context.Background(), "user:online", sub.UID).Uint64()
		if err != nil || nodeID == 0 {
			// 离线，跳过
			continue
		}

		sub.NodeID = nodeID
		onlineSubscribers = append(onlineSubscribers, sub)
	}

	// 2. 按节点分组
	ctx.NodeGroups = h.groupByNode(onlineSubscribers)

	log.Info("filter online",
		zap.Int("totalCount", len(ctx.Subscribers)),
		zap.Int("onlineCount", len(onlineSubscribers)),
		zap.Int("nodeCount", len(ctx.NodeGroups)))

	return nil
}

func (h *PushOnlineHandler) groupByNode(subscribers []Subscriber) map[uint64][]string {
	groups := make(map[uint64][]string)

	for _, sub := range subscribers {
		groups[sub.NodeID] = append(groups[sub.NodeID], sub.UID)
	}

	return groups
}
```

---

#### **Handler 2: Encode（编码RECV包）**

```go
func (h *PushOnlineHandler) Encode(ctx *PushContext) error {
	msg := ctx.Message

	// 1. 构造RECV包
	recvPacket := &wkproto.RecvPacket{
		Setting:     0,
		MessageID:   msg.MessageID,
		MessageSeq:  msg.MessageSeq,
		ClientMsgNo: msg.ClientMsgNo,
		FromUID:     msg.FromUID,
		ChannelID:   msg.ChannelID,
		ChannelType: msg.ChannelType,
		Payload:     msg.Payload,
		Timestamp:   msg.Timestamp,
	}

	// 2. 编码为二进制
	data, err := wkproto.EncodeFrame(recvPacket, wkproto.LatestVersion)
	if err != nil {
		return err
	}

	// 3. 保存到Context
	ctx.EncodedData = data

	return nil
}
```

---

#### **Handler 3: Write（写入连接）**

```go
func (h *PushOnlineHandler) Write(ctx *PushContext) error {
	// 1. 本地推送
	localUIDs := ctx.NodeGroups[h.nodeID]
	if len(localUIDs) > 0 {
		h.pushLocal(localUIDs, ctx.EncodedData)
	}

	// 2. 跨节点推送
	for nodeID, uids := range ctx.NodeGroups {
		if nodeID == h.nodeID {
			continue  // 跳过本地
		}

		// 发送RPC到目标节点
		go h.pushRemote(nodeID, uids, ctx.Message)
	}

	return nil
}

func (h *PushOnlineHandler) pushLocal(uids []string, data []byte) {
	for _, uid := range uids {
		// 查找用户的所有连接（多端）
		conns := h.connMgr.ConnsByUID(uid)

		for _, conn := range conns {
			// 写入连接
			_, err := conn.Write(data)
			if err != nil {
				log.Error("write data failed",
					zap.String("uid", uid),
					zap.Error(err))
			}
		}
	}
}

func (h *PushOnlineHandler) pushRemote(nodeID uint64, uids []string, msg *Message) {
	// 构造RPC请求
	req := &pb.PushRequest{
		Uids:    uids,
		Message: convertMessage(msg),
	}

	// 发送RPC
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	resp, err := h.rpcClient.Push(ctx, nodeID, req)
	if err != nil {
		log.Error("push remote failed",
			zap.Uint64("nodeID", nodeID),
			zap.Error(err))
		return
	}

	log.Info("push remote success",
		zap.Uint64("nodeID", nodeID),
		zap.Int("successCount", int(resp.SuccessCount)))
}
```

---

## 5️⃣ 其他核心事件

### **A. EventRecvAck - 接收确认**

```
EventRecvAck 流程：

1. 客户端收到RECV包
   └─ 处理消息（显示到界面）

2. 客户端发送RECVACK包
   └─ MessageID、MessageSeq

3. 服务端处理
   ├─ 更新客户端已接收序号（Offset）
   ├─ 清理已确认的离线消息队列
   └─ 用于消息同步
```

**代码位置**：`internal/user/handler/event_recvack.go`

```go
func (h *RecvAckHandler) Handle(ctx *UserContext) error {
	recvackPacket := ctx.Frame.(*wkproto.RecvackPacket)
	uid := ctx.Conn.UID()

	// 1. 更新用户的已接收序号
	err := h.offsetService.UpdateOffset(
		uid,
		recvackPacket.ChannelID,
		recvackPacket.ChannelType,
		recvackPacket.MessageSeq,
	)
	if err != nil {
		return err
	}

	// 2. 清理已确认的消息
	err = h.messageQueue.ClearBefore(
		uid,
		recvackPacket.ChannelID,
		recvackPacket.MessageSeq,
	)

	return err
}
```

---

### **B. EventPing - 心跳**

```
EventPing 流程：

1. 客户端定时发送PING包
   └─ 默认30秒一次

2. 服务端处理
   ├─ 更新连接最后活跃时间
   └─ 立即返回PONG包

3. 客户端收到PONG包
   └─ 计算RTT（往返时延）
```

**代码位置**：`internal/user/handler/event_ping.go`

```go
func (h *PingHandler) Handle(ctx *UserContext) error {
	// 1. 更新最后活跃时间
	ctx.Conn.KeepLastActivity()

	// 2. 构造PONG包
	pongPacket := &wkproto.PongPacket{}

	// 3. 发送PONG
	err := ctx.Conn.WriteFrame(pongPacket)

	return err
}
```

---

### **C. EventConnClose - 连接关闭**

```
EventConnClose 流程：

1. 触发时机
   ├─ 客户端主动关闭
   ├─ 连接超时（60秒无活动）
   └─ 协议错误

2. 清理工作
   ├─ 移除订阅关系
   ├─ 更新在线状态（Redis）
   ├─ 释放资源
   └─ 记录日志
```

**代码位置**：`internal/user/handler/event_close.go`

```go
func (h *CloseHandler) Handle(ctx *UserContext) error {
	uid := ctx.Conn.UID()

	// 1. 移除订阅关系
	h.subscriberService.RemoveAllSubscriptions(uid)

	// 2. 更新在线状态
	h.redis.HDel(context.Background(), "user:online", uid)

	// 3. 清理连接管理器
	h.connMgr.RemoveConn(ctx.Conn)

	log.Info("connection closed",
		zap.String("uid", uid),
		zap.String("remoteAddr", ctx.Conn.RemoteAddr().String()))

	return nil
}
```

---

## 6️⃣ 事件流转完整案例

### **完整消息发送流程**

```
完整流程（从客户端发送到接收者收到）：

客户端A（user001）发送消息到群聊（group_001）

┌─────────────────────────────────────────────────────┐
│ Step 1: 客户端发送                                    │
│ ├─ 客户端A构造SEND包                                  │
│ ├─ ClientMsgNo: "msg_20240101_001"                   │
│ ├─ ChannelID: "group_001"                            │
│ ├─ ChannelType: 2 (GROUP)                            │
│ └─ Payload: "Hello everyone!"                        │
└─────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────┐
│ Step 2: 网络层接收                                    │
│ ├─ wknet.onData() 接收数据                            │
│ ├─ Protocol.Decode() 解析SEND Frame                  │
│ └─ 生成 UserContext{EventOnSend}                     │
└─────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────┐
│ Step 3: UserEventPool 处理                           │
│ ├─ UserEventPool.AddEvent("user001", event)         │
│ ├─ 写入user001的事件队列                              │
│ └─ Worker执行Handler链                               │
│     ├─ PermissionHandler: 权限校验通过                │
│     ├─ WebhookHandler: 业务回调通过                   │
│     └─ OnSendHandler:                                │
│         ├─ 生成MessageID: "1234567890"               │
│         ├─ 发送SENDACK给客户端A                       │
│         └─ 生成ChannelContext{EventChannelDistribute}│
└─────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────┐
│ Step 4: ChannelEventPool 处理                        │
│ ├─ ChannelEventPool.AddEvent("group_001", 2, event) │
│ ├─ 写入group_001的事件队列                            │
│ └─ Worker执行Handler链                               │
│     ├─ PreCheckHandler: 去重检查通过                  │
│     ├─ StoreHandler:                                 │
│     │   ├─ 分配MessageSeq: 1001                      │
│     │   └─ 写入PebbleDB                               │
│     ├─ ReplicateHandler:                             │
│     │   ├─ 提议到Raft                                 │
│     │   ├─ 复制到Follower                             │
│     │   └─ 等待多数派确认（成功）                      │
│     └─ PostProcessHandler:                           │
│         ├─ 查找订阅者: [user002, user003, user004]    │
│         └─ 生成PushContext{EventPushOnline}          │
└─────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────┐
│ Step 5: PusherEventPool 处理                         │
│ ├─ PusherEventPool.AddEvent(event)                  │
│ └─ Worker执行Handler链                               │
│     ├─ FilterOnlineHandler:                          │
│     │   ├─ 查询在线状态:                              │
│     │   │   ├─ user002: 节点1（在线）                 │
│     │   │   ├─ user003: 节点2（在线）                 │
│     │   │   └─ user004: 0（离线，跳过）               │
│     │   └─ 按节点分组:                                │
│     │       ├─ 节点1: [user002]                       │
│     │       └─ 节点2: [user003]                       │
│     ├─ EncodeHandler:                                │
│     │   └─ 编码RECV包（二进制）                        │
│     └─ WriteHandler:                                 │
│         ├─ 本地推送（节点1）:                          │
│         │   └─ 查找user002连接，写入数据               │
│         └─ 跨节点推送（节点2）:                        │
│             └─ RPC推送到节点2                          │
└─────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────┐
│ Step 6: 接收者收到消息                                 │
│ ├─ user002收到RECV包（节点1本地推送）                  │
│ ├─ user003收到RECV包（节点2 RPC推送）                  │
│ └─ user004离线，消息存入离线队列                       │
└─────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────┐
│ Step 7: 客户端确认                                    │
│ ├─ user002发送RECVACK                                │
│ └─ user003发送RECVACK                                │
└─────────────────────────────────────────────────────┘

完成！
```

---

### **性能数据**

```
完整流程耗时分析：

Step 1: 客户端发送          0ms
Step 2: 网络层接收          0.5ms
Step 3: UserEventPool      2ms
  ├─ 权限校验              0.5ms
  ├─ Webhook回调           1ms
  └─ 核心处理              0.5ms
Step 4: ChannelEventPool   30ms
  ├─ 存储消息              5ms
  ├─ Raft复制             20ms（主要耗时）
  └─ 后处理               5ms
Step 5: PusherEventPool    5ms
  ├─ 过滤在线              1ms
  ├─ 编码RECV             0.5ms
  └─ 写入连接              3.5ms

总耗时：约40ms（P99 < 50ms）

吞吐量：
├─ 单机：10万条消息/秒
├─ 3节点集群：25万条消息/秒
└─ 5节点集群：40万条消息/秒
```

---

## 7️⃣ 总结

### **核心要点**

1. **EventConnect - 连接建立**
   - 认证Token
   - 加载会话（订阅频道）
   - 发送CONNACK

2. **EventOnSend - 消息发送**
   - 权限校验
   - Webhook回调
   - 生成MessageID
   - 发送SENDACK
   - 触发ChannelEvent

3. **EventChannelDistribute - 消息分发**
   - 预检查（去重）
   - 存储消息（分配Seq）
   - Raft复制（保证可靠性）
   - 后处理（触发推送）

4. **EventPushOnline - 在线推送**
   - 过滤在线订阅者
   - 编码RECV包
   - 本地推送
   - 跨节点推送

---

### **事件驱动架构优势**

```
✅ 解耦：各层通过事件通信，互不依赖
✅ 异步：快速响应，不阻塞
✅ 分层：职责清晰，易维护
✅ 扩展：新增功能只需添加Handler
✅ 可靠：Raft复制，消息不丢失
✅ 分布式：跨节点转发，无单点
```

---

### **本章总结**

**第五章：EventBus事件总线**

我们学习了：
- 5.1：事件驱动架构概述
- 5.2：三大事件池（User/Channel/Pusher）
- 5.3：事件处理链（生成→入队→路由→执行）
- 5.4：核心事件解析（Connect/OnSend/Distribute/Push）

**下一章预告**：

**第六章：存储层设计**
- 6.1：PebbleDB存储引擎
- 6.2：消息存储设计
- 6.3：索引设计与优化
- 6.4：数据压缩与清理

---

> **🔗 相关代码**：
> - 连接Handler：`internal/user/handler/connect.go`
> - 发送Handler：`internal/user/handler/event_onsend.go`
> - 分发Handler：`internal/channel/handler/distribute.go`
> - 推送Handler：`internal/pusher/handler/push_online.go`
> - 权限检查：`internal/service/permission.go`
> - Webhook：`internal/service/webhook.go`
> - Raft复制：`pkg/cluster/raft/replication.go`
