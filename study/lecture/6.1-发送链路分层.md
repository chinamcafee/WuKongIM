# 6.1 发送链路分层

> **本节目标**：建立对单条消息从客户端发出到订阅端收到的完整分层认知，理解各层职责以及事件驱动协作方式

---

## 📋 目录
1. [消息旅程鸟瞰](#消息旅程鸟瞰)
2. [网络层：wknet 接入](#网络层wknet-接入)
3. [用户事件层：UserEventPool](#用户事件层usereventpool)
4. [频道事件层：ChannelEventPool](#频道事件层channeleventpool)
5. [推送层：PusherEventPool](#推送层pushereventpool)
6. [跨层协同与可观测性](#跨层协同与可观测性)

---

## 1️⃣ 消息旅程鸟瞰

### **A. 全链路时序图**

```
客户端 SEND
  ↓
[网络层] wknet.Conn → `Server.onData`
  ↓
[用户事件层] UserEventPool
  ├─ 权限&插件 → SendAck(失败)
  └─ 向频道投递 EventChannelOnSend
        ↓
[频道事件层] ChannelEventPool
  ├─ Channel.permission
  ├─ Channel.persist → Raft + WuKongDB
  ├─ Channel.sendack → SendAck(成功)
  └─ Channel.distribute → 生成 PushOnline / PushOffline
        ↓
[推送层] PusherEventPool
  ├─ pushMessageToConnections → ConnWrite → wknet
  └─ setupRetryIfNeeded → RetryManager
        ↓
订阅端 RECV / 触发 webhook / 离线通知
```

### **B. 核心角色速览**

| 层级 | 关键对象 | 代码入口 |
|------|----------|----------|
| 网络层 | `Server.handleAuthenticatedConn` | `internal/server/proto.go:73` |
| 用户层 | `user.Handler.handleOnSend` | `internal/user/handler/event_onsend.go:36` |
| 频道层 | `channel.Handler.onSend` | `internal/channel/handler/event_onsend.go:8` |
| 推送层 | `pusher.Handler.pushOnline` | `internal/pusher/handler/event_pushonline.go:20` |
| 重试/观测 | `RetryManager`、`track.Message` | `internal/manager/manager_retry.go:16` / `internal/track/track.go:15` |

---

## 2️⃣ 网络层：wknet 接入

### **A. 场景职责**
- 将 TCP/WebSocket 字节流解码为 `wkproto.Frame`
- 为 SEND 帧分配 `messageId`，并初始化追踪点
- 聚合同一批数据帧，避免逐帧调度开销

### **B. 关键流程**

**入口**：`internal/server/proto.go:22`

```go
func (s *Server) onData(conn wknet.Conn) error {
    buff, err := conn.Peek(-1)
    ...
    if isAuth {
        return s.handleAuthenticatedConn(conn, connCtx, buff, isJson)
    }
    ...
}
```

核心要点：
- 使用 `conn.Peek(-1)` 实现零拷贝探查，再按需 `Discard`（`internal/server/proto.go:22-165`）
- `handleAuthenticatedConn` 中循环 decode，将 SEND 帧统一封装为 `eventbus.Event` 并打上 `track.PositionStart`
- 单批次最多缓存 10 帧（预分配 `frames := make([]wkproto.Frame, 0, 10)`）——避免频繁扩容
- 通过 `eventbus.User.AddEvents` 批量丢给用户事件池，随后立即 `Advance` 保证及时处理

---

## 3️⃣ 用户事件层：UserEventPool

### **A. 层职责**
- 同一 UID 的消息串行化，保证发送侧顺序
- 负责全局限流/封禁、消息解密、插件拦截
- 判断是否需要直接回 SendAck（失败、同步消息等）
- 将合法消息投递到对应频道

### **B. 流程拆解**

**处理函数**：`internal/user/handler/event_onsend.go:21`

```go
func (h *Handler) onSend(ctx *eventbus.UserContext) {
    for _, event := range ctx.Events {
        switch event.Frame.GetFrameType() {
        case wkproto.SEND:
            h.handleOnSend(event)
        case wkproto.RECVACK:
            h.recvack(event)
        ...
    }
}
```

`handleOnSend` 核心步骤：
1. 轨迹记录 `Track.Record(track.PositionUserOnSend)`，串联后续耗时采集
2. `checkGlobalSendPermission` 校验发送者全局封禁状态（`internal/user/handler/event_onsend.go:67-92`）
3. 可选解密：若启用了端到端加密，则对 payload 做 AES 解密/验签（`internal/user/handler/event_onsend.go:94-113`）
4. 插件链：`PluginSend` 可阻断或改写 payload（`internal/user/handler/event_onsend.go:115-133`）
5. 统计指标：`trace.GlobalTrace` 计数 + 字节累加
6. 转换频道标识：对个人/Agent 频道生成“伪频道”ID，确保多端共用一条事件流水
7. 将事件投递至 ChannelEventPool，并 `Advance` 触发执行

**SendAck 策略**：失败场景立即下发 ACK；成功场景交由频道层统一带上 `MessageSeq` 回传。

---

## 4️⃣ 频道事件层：ChannelEventPool

### **A. 层职责**
- 以频道为粒度串行化，确保持久化与分发顺序一致
- 权限校验（频道状态、成员资格、黑白名单）
- 调用 Raft 共识写入 + WuKongDB 落盘
- 触发 webhook、分发消息、生成推送事件

### **B. 事件链路**

1. **入口**：`internal/channel/handler/event_onsend.go:8` —— 对每批事件依次执行 `permission` → `persist` → `sendack`
2. **权限层**：`internal/channel/handler/event_permission.go:12` 根据频道类型调用 `service.Permission`，兼容跨节点 RPC 查询
3. **持久化层**：`internal/channel/handler/event_persist.go:19-115`
   - `toPersistMessages` 将事件转换为 `wkdb.Message`
   - `service.Store.AppendMessages` => `ProposeBatchUntilAppliedTimeout` 交给 Raft 日志复制
   - 回填 `MessageSeq` 与 `ReasonCode`
   - 若启用 webhook，将成功事件克隆为 `EventChannelWebhook`
   - 生成 `EventChannelDistribute` 进入分发队列
4. **分发层**：`internal/channel/handler/event_distribute.go:19-188`
   - 通过 `Tag` 机制将用户映射到节点
   - 本地用户生成 `EventPushOnline` / 离线用户生成 `EventPushOffline`
   - 维护最近会话、离线队列等业务能力

显式推进：每个阶段结尾都会调用 `eventbus.Channel.Advance`，保持事件泵顺畅。

---

## 5️⃣ 推送层：PusherEventPool

### **A. 层职责**
- 负责将 `EventPushOnline` 写入在线连接
- 针对离线用户触发 webhook 或 AI 插件
- 将可靠消息挂入重试队列，等待 RecvAck 确认

### **B. 在线推送流程**

**入口**：`internal/pusher/handler/event_pushonline.go:20`

```go
func (h *Handler) pushOnline(ctx *eventbus.PushContext) {
    h.processChannelPush(ctx.Events)
}
```

关键步骤：
1. 过滤系统账号 → `shouldProcessEvent`
2. 根据目标 UID 查找所有认证连接（多端同步）
3. `Track.Record(track.PositionPushOnline)` 标记推送耗时段
4. 构建 `RecvPacket`：
   - `setRecvPacketBasicFields` 填充 `MessageSeq`、红点、Topic 等
   - `adjustPersonChannelID` 解决个人频道互视问题
   - `processPayloadEncryption` 根据目标端重新加密 payload
   - `generateMsgKey` 生成签名
5. `setupRetryIfNeeded` 将持久化消息交给 `RetryManager`，实现“ACK 异步 + 自动重推”
6. 通过 `eventbus.User.ConnWrite` 追加到用户事件队列，依旧保持串行

### **C. 离线补偿**
- `EventPushOffline` 组装 webhook/AI 事件（`internal/pusher/handler/event_pushoffline.go:7-19`）
- 调用 `service.Webhook.NotifyOfflineMsg` 与插件联动

---

## 6️⃣ 跨层协同与可观测性

### **A. Track + Trace**
- `track.Message`（`internal/track/track.go:15-74`）记录 16 个节点的耗时，输出格式 `Cost: xxms, ChannelPersist: 5ms ...`
- 各层在关键点调用 `Track.Record(...)`，串起可观测闭环

### **B. 状态推进机制**
- User/Channel/Pusher 层均通过 `eventbus.*.Advance` 控制事件泵，避免 goroutine 风暴
- `EventQueue`（`internal/eventbus/event_queue.go:9-67`）以批量方式吐出事件，提供 `maxSize` 限制防止单批过大

### **C. 可靠性保障**
- `RetryManager`（`internal/manager/manager_retry.go:16-139`）使用时间轮 + 分片队列，按消息 ID 分片重试
- `RecvAck`（`internal/user/handler/event_recvack.go:19-71`）收到客户端确认后移除重试，顺便更新会话已读
- Raft 层 `ProposeBatchUntilAppliedTimeout`（`pkg/raft/raft/raft_propose.go:53-119`）确保日志真正落盘后才返回，保证写入可见

> **小结**：发送链路以事件驱动为骨架，通过“网络→用户→频道→推送”四层顺序化处理，将权限、存储、推送、重试、观测等能力串联在一起。理解这一分层图谱，是阅读第 6 章源码的基础。
