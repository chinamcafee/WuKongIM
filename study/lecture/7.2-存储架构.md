# 7.2 存储架构

> **本节目标**：深入理解WuKongDB的分片设计、批量写入优化、多级缓存架构，掌握高性能存储的核心技术

---

## 📋 目录
1. [Sharding分片设计](#sharding分片设计)
2. [BatchDB批量写入优化](#batchdb批量写入优化)
3. [多级缓存设计](#多级缓存设计)
4. [性能监控系统](#性能监控系统)
5. [整体架构总览](#整体架构总览)

---

## 1️⃣ Sharding 分片设计

### **A. 为什么需要分片？**

**问题：单个DB实例的瓶颈**
```
假设：100万个频道，每秒10万条消息

单DB实例问题：
├─ 写入瓶颈：PebbleDB单实例约10万QPS
├─ 锁竞争：MemTable写入需要加锁
├─ Compaction压力：单个DB的压实任务过重
└─ 缓存命中率低：热数据分散在整个DB

结论：需要分片（Sharding）！
```

---

### **B. WuKongDB的分片策略**

**核心设计**：
```go
// pkg/wkdb/wukongdb.go:24-26
type wukongDB struct {
    dbs      []*pebble.DB  // 分片数组（默认16个）
    wkdbs    []*BatchDB    // 批量DB数组
    shardNum uint32        // 分片数量（一旦设置不可修改）
    ...
}
```

**分片数量**：
```
默认配置：16个分片

为什么是16？
├─ 太少（4个）：单分片压力大
├─ 太多（64个）：管理开销大，文件描述符多
└─ 16个：平衡性能与复杂度 ✅

可调整范围：8-32个分片
```

---

### **C. 分片路由算法**

**哈希分片**：
```go
// pkg/wkdb/shard.go
func (wk *wukongDB) channelDbIndex(channelId string, channelType uint8) uint32 {
    // 1. 计算频道Key
    channelKey := wkutil.ChannelToKey(channelId, channelType)

    // 2. FNV-1a哈希
    wk.h.Reset()
    wk.h.Write([]byte(channelKey))
    hashValue := wk.h.Sum32()

    // 3. 取模得到分片索引
    return hashValue % wk.shardNum
}
```

**示例**：
```
频道1："channel_001:2"
    → FNV-1a(channel_001:2) = 0x12345678
    → 0x12345678 % 16 = 8
    → 分配到分片8

频道2："channel_002:2"
    → FNV-1a(channel_002:2) = 0x87654321
    → 0x87654321 % 16 = 1
    → 分配到分片1

特点：
✅ 同一频道永远在同一分片
✅ 不同频道均匀分布
✅ O(1)时间复杂度
```

---

### **D. 分片隔离的好处**

**1. 负载均衡**
```
100万个频道分配到16个分片：
├─ 分片0：6.25万个频道
├─ 分片1：6.25万个频道
├─ ...
└─ 分片15：6.25万个频道

每个分片独立：
- 独立的MemTable（64MB）
- 独立的WAL文件
- 独立的Compaction线程
- 独立的Block Cache
```

---

**2. 减少锁竞争**
```
单DB：
├─ 所有写入竞争同一个MemTable锁
└─ 锁竞争严重（100万QPS）

16分片：
├─ 每个分片6.25万QPS
├─ 锁竞争降低16倍
└─ 吞吐量提升：10万 → 100万+ QPS ✅
```

---

**3. 故障隔离**
```
单DB崩溃：
└─ 所有频道不可用 ❌

分片隔离：
├─ 分片8崩溃
├─ 只影响1/16的频道（6.25万个）
└─ 其他15个分片正常运行 ✅
```

---

**4. Compaction并行**
```
单DB Compaction：
└─ 单线程处理，可能阻塞写入

16分片 Compaction：
├─ 16个分片独立压实
├─ 并行执行，互不影响
└─ 压实速度提升16倍 ✅
```

---

### **E. 分片目录结构**

```
数据目录：
/data/wukongdb/
├── shard_0/          # 分片0
│   ├── 000001.log    # WAL日志
│   ├── 000002.sst    # SST文件（L0）
│   ├── 000003.sst    # SST文件（L1）
│   ├── MANIFEST      # 元数据文件
│   └── OPTIONS       # 配置文件
├── shard_1/          # 分片1
│   ├── 000001.log
│   ├── 000002.sst
│   └── ...
├── ...
└── shard_15/         # 分片15
    └── ...

每个分片独立：
- 独立的PebbleDB实例
- 独立的文件系统路径
- 独立的资源限制
```

---

## 2️⃣ BatchDB 批量写入优化

### **A. 为什么需要批量写入？**

**问题：单条写入效率低**
```
场景：1秒内收到10000条消息

方案1：逐条写入
├─ 10000次 Commit()
├─ 10000次 fsync()（强制刷盘）
├─ 耗时：10000 × 1ms = 10秒 ❌
└─ QPS：1000（性能差）

方案2：批量写入（WuKongDB）
├─ 合并100条消息 → 1次 Commit()
├─ 100次 Commit()，100次 fsync()
├─ 耗时：100 × 1ms = 0.1秒 ✅
└─ QPS：100,000（性能好）

性能提升：100倍 🚀
```

---

### **B. BatchDB架构**

**核心结构**：
```go
// pkg/wkdb/wukongdb.go:365-372
type BatchDB struct {
    db        *pebble.DB           // 底层PebbleDB实例
    batchChan chan *Batch          // Batch队列（缓冲4000）
    stopper   *syncutil.Stopper    // 停止器
    Index     int                  // 分片索引
}
```

**工作流程**：
```
                   业务线程
                      ↓
┌─────────────────────────────────────────┐
│  1. 创建Batch                            │
│     batch := db.NewBatch()               │
│     batch.Set(key, value)                │
│     batch.CommitWait()                   │
└─────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────┐
│  2. 发送到batchChan（非阻塞）            │
│     batchChan <- batch                   │
└─────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────┐
│  3. 后台Worker聚合Batch                  │
│     - 从chan获取Batch                    │
│     - 聚合最多100个Batch                 │
│     - 合并为1个PebbleBatch              │
└─────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────┐
│  4. 批量Commit（1次fsync）               │
│     pebbleBatch.Commit(pebble.Sync)     │
└─────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────┐
│  5. 通知所有等待的业务线程                │
│     for _, b := range batches {         │
│         b.waitC <- err                  │
│     }                                   │
└─────────────────────────────────────────┘
```

---

### **C. 批量聚合逻辑**

**核心代码**：
```go
// pkg/wkdb/wukongdb.go:400-428
func (wk *BatchDB) loop() {
    batchSize := 100  // 最多聚合100个Batch
    batches := make([]*Batch, 0, batchSize)

    for {
        select {
        case bt := <-wk.batchChan:
            // 第1个Batch
            batches = append(batches, bt)

            // 尝试获取更多Batch（非阻塞）
            done := false
            for !done {
                select {
                case b := <-wk.batchChan:
                    batches = append(batches, b)
                    if len(batches) >= batchSize {
                        done = true  // 达到100个，停止聚合
                    }
                default:
                    done = true  // 没有更多Batch，停止聚合
                }
            }

            // 执行批量写入
            wk.executeBatch(batches)
            batches = batches[:0]
        }
    }
}
```

---

### **D. 批量执行流程**

```go
// pkg/wkdb/wukongdb.go:430-490
func (wk *BatchDB) executeBatch(bs []*Batch) {
    // 1. 创建PebbleBatch
    bt := wk.db.NewBatch()
    defer bt.Close()

    // 2. 合并所有Batch的操作
    for _, b := range bs {
        // 删除操作
        for _, kv := range b.delKvs {
            bt.Delete(kv.key, pebble.NoSync)
        }
        // 范围删除
        for _, kv := range b.delRangeKvs {
            bt.DeleteRange(kv.key, kv.val, pebble.NoSync)
        }
        // 写入操作
        for _, kv := range b.setKvs {
            bt.Set(kv.key, kv.val, pebble.NoSync)
        }
    }

    // 3. 批量Commit（1次fsync）
    err := bt.Commit(pebble.Sync)

    // 4. 通知所有等待的协程
    for _, b := range bs {
        if b.waitC != nil {
            b.waitC <- err  // 唤醒业务协程
        }
        b.release()  // 释放资源
    }
}
```

---

### **E. 性能优化效果**

**吞吐量提升**：
```
场景：10万条消息/秒

单条写入：
├─ 10万次 Commit()
├─ 10万次 fsync()
├─ QPS：5000（受fsync限制）
└─ 延迟P99：200ms

批量写入（100条聚合）：
├─ 1000次 Commit()
├─ 1000次 fsync()
├─ QPS：100,000 ✅
└─ 延迟P99：10ms

性能提升：20倍
```

---

**延迟优化**：
```
业务视角：
├─ 调用 batch.CommitWait()
├─ 等待时间：< 10ms（平均5ms）
└─ 用户无感知

底层优化：
├─ 聚合100个请求
├─ 1次fsync（10ms）
├─ 平摊到每个请求：0.1ms
└─ 延迟降低100倍 ✅
```

---

## 3️⃣ 多级缓存设计

### **A. 缓存层次**

```
┌─────────────────────────────────────────┐
│  L1: PebbleDB Block Cache（512MB）      │  ← PebbleDB内置
│      - 缓存SST文件的数据块                │
│      - LRU淘汰                           │
└─────────────────────────────────────────┘
                  ↑ 未命中
┌─────────────────────────────────────────┐
│  L2: WuKongDB业务缓存                    │
├─────────────────────────────────────────┤
│  - ChannelInfoCache（频道信息）          │
│  - ConversationCache（会话列表）         │
│  - PermissionCache（权限数据）           │
│  - DeviceCache（设备信息）               │
│  - ChannelSeqCache（频道序号）           │
│  - ClusterConfigCache（集群配置）        │
└─────────────────────────────────────────┘
                  ↑ 未命中
┌─────────────────────────────────────────┐
│  L3: PebbleDB MemTable（64MB×16）       │  ← 内存表
│      - 最新写入的数据                     │
└─────────────────────────────────────────┘
                  ↑ 未命中
┌─────────────────────────────────────────┐
│  L4: 磁盘（SST文件）                     │
│      - 持久化存储                         │
└─────────────────────────────────────────┘
```

---

### **B. 核心缓存模块**

**1. ChannelInfoCache - 频道信息缓存**
```go
// pkg/wkdb/cache_channel.go:13-25
type ChannelInfoCache struct {
    cache *lru.Cache  // LRU缓存（默认1000个）
}

type ChannelInfoCacheItem struct {
    channelInfo ChannelInfo  // 频道信息
    version     uint64       // 版本号（用于失效检测）
}

缓存内容：
├─ 频道ID、频道类型
├─ 频道配置（禁言、白名单等）
├─ 更新版本号
└─ 过期时间

命中率：85%+（频繁访问的频道）
```

---

**2. PermissionCache - 权限缓存**（统一缓存）
```go
// pkg/wkdb/cache_permission.go:23-35
type PermissionCache struct {
    cache *lru.Cache
}

type PermissionCacheItem struct {
    blacklist   []string  // 黑名单
    whitelist   []string  // 白名单
    subscribers []string  // 订阅者列表
    version     uint64    // 版本号
}

缓存内容：
├─ 黑名单列表（拉黑用户）
├─ 白名单列表（允许发送）
├─ 订阅者列表（频道成员）
└─ 权限版本号

命中率：90%+（权限查询频繁）
```

---

**3. ConversationCache - 会话缓存**
```go
// pkg/wkdb/cache_conversation.go:18
type ConversationCache struct {
    cache *lru.Cache  // 缓存1000个查询结果
}

缓存内容：
├─ 用户ID → 最近会话列表
├─ 会话元数据（最后一条消息、未读数）
└─ 查询结果（按时间排序）

命中率：80%+（会话列表频繁查询）
```

---

**4. DeviceCache - 设备缓存**
```go
// pkg/wkdb/cache_device.go:13-25
type DeviceCache struct {
    cache *lru.Cache
}

type DeviceCacheItem struct {
    devices []Device  // 用户的设备列表
    version uint64    // 版本号
}

缓存内容：
├─ 用户ID → 设备列表
├─ 设备ID、设备类型
├─ 连接节点信息
└─ 在线状态

命中率：75%+（在线用户设备查询）
```

---

### **C. 缓存管理器**

**统一管理**：
```go
// pkg/wkdb/cache_manager.go:13
type CacheManager struct {
    permissionCache    *PermissionCache
    conversationCache  *ConversationCache
    channelInfoCache   *ChannelInfoCache
    clusterConfigCache *ChannelClusterConfigCache
    deviceCache        *DeviceCache
}

职责：
1️⃣ 统一失效：版本更新时清空相关缓存
2️⃣ 预热：启动时加载热数据
3️⃣ 监控：统计命中率、内存占用
4️⃣ 调优：动态调整缓存大小
```

---

### **D. 缓存失效策略**

**1. 版本控制失效**
```go
// 写入时更新版本号
func (wk *wukongDB) UpdateChannelInfo(info ChannelInfo) error {
    // 1. 递增版本号
    info.Version++

    // 2. 写入数据库
    err := wk.db.Set(key, value)

    // 3. 失效缓存
    wk.channelInfoCache.Delete(info.ChannelID, info.ChannelType)

    return err
}

// 读取时检查版本
func (wk *wukongDB) GetChannelInfo(id string, typ uint8) (ChannelInfo, error) {
    // 1. 查询缓存
    cached, ok := wk.channelInfoCache.Get(id, typ)
    if ok {
        // 2. 检查版本是否一致
        dbVersion := wk.getChannelVersion(id, typ)
        if cached.version == dbVersion {
            return cached.channelInfo  // 缓存有效
        }
        // 版本不一致，删除缓存
        wk.channelInfoCache.Delete(id, typ)
    }

    // 3. 从DB加载
    info := wk.loadChannelInfoFromDB(id, typ)

    // 4. 写入缓存
    wk.channelInfoCache.Set(id, typ, info)

    return info
}
```

---

**2. LRU淘汰策略**
```
缓存大小限制：1000个条目

LRU（Least Recently Used）：
├─ 缓存满时，淘汰最久未访问的条目
├─ 每次Get()操作，更新访问时间
└─ 保证热数据留在缓存中

示例：
缓存状态：[A(5min前), B(3min前), C(1min前)]
新增D：
├─ 缓存满（1000个）
├─ 淘汰A（最久未访问）
└─ 新状态：[B, C, D]
```

---

### **E. 缓存预热**

**启动时加载热数据**：
```go
// pkg/wkdb/cache_manager.go
func (cm *CacheManager) WarmUp(data *CacheWarmupData) {
    // 1. 加载活跃频道信息
    for _, channelID := range data.ActiveChannels {
        info := cm.db.GetChannelInfo(channelID)
        cm.channelInfoCache.Set(channelID, info)
    }

    // 2. 加载在线用户设备
    for _, uid := range data.OnlineUsers {
        devices := cm.db.GetUserDevices(uid)
        cm.deviceCache.Set(uid, devices)
    }

    // 3. 加载热门会话
    for _, uid := range data.ActiveUsers {
        conversations := cm.db.GetConversations(uid)
        cm.conversationCache.Set(uid, conversations)
    }
}

预热效果：
├─ 冷启动命中率：10%
├─ 预热后命中率：85%+
└─ 启动后查询延迟降低10倍
```

---

## 4️⃣ 性能监控系统

### **A. 监控指标**

**核心指标**：
```go
// pkg/wkdb/performance_monitor.go
type PerformanceMonitor struct {
    // 缓存统计
    CacheStats struct {
        ChannelInfoHitRate    float64  // 频道信息缓存命中率
        PermissionHitRate     float64  // 权限缓存命中率
        ConversationHitRate   float64  // 会话缓存命中率
        DeviceHitRate         float64  // 设备缓存命中率
    }

    // 性能统计
    PerformanceStats struct {
        AppendMessageCount    int64    // 消息追加次数
        AppendMessageLatency  float64  // 追加消息延迟（ms）
        QueryLatency          float64  // 查询延迟（ms）
        CompactionCount       int64    // Compaction次数
    }

    // 资源统计
    ResourceStats struct {
        MemTableSize    int64  // MemTable总大小
        SSTFileCount    int64  // SST文件总数
        DiskUsage       int64  // 磁盘占用（字节）
        WriteAmplification float64  // 写入放大倍数
    }
}
```

---

### **B. 监控报表**

**实时监控输出**：
```
=== WuKongDB Performance Report ===

Cache Hit Rates:
├─ ChannelInfo:   88.5% (优秀)
├─ Permission:    92.3% (优秀)
├─ Conversation:  81.2% (良好)
└─ Device:        76.8% (良好)

Performance Metrics:
├─ AppendMessage QPS:  95,230
├─ Append Latency P99:  8ms
├─ Query Latency P99:   5ms
└─ Compaction/min:      12

Resource Usage:
├─ MemTable:       1.2GB (16 shards × 64MB)
├─ SST Files:      2,345
├─ Disk Usage:     120GB
└─ Write Amp:      2.3x (优秀)

Shard Distribution:
├─ Shard 0:  6.1万频道,  8.2GB
├─ Shard 1:  6.3万频道,  8.5GB
├─ ...
└─ Shard 15: 6.2万频道,  8.3GB
```

---

## 5️⃣ 整体架构总览

### **A. 完整架构图**

```
┌─────────────────────────────────────────────────────────┐
│                    WuKongDB 架构                         │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│                  Hash Routing（哈希路由）                 │
│  ChannelID + ChannelType → FNV-1a → Shard Index        │
└─────────────────────────────────────────────────────────┘
                          ↓
┌───────┬───────┬───────┬───────┬─────────┬───────────────┐
│Shard0 │Shard1 │Shard2 │ ...   │Shard15  │   (16分片)    │
└───────┴───────┴───────┴───────┴─────────┴───────────────┘
    ↓       ↓       ↓       ↓         ↓
┌─────────────────────────────────────────────────────────┐
│              BatchDB（批量写入优化）                      │
│  - 聚合100个Batch → 1次Commit                           │
│  - 性能提升：20倍                                        │
└─────────────────────────────────────────────────────────┘
    ↓       ↓       ↓       ↓         ↓
┌─────────────────────────────────────────────────────────┐
│              PebbleDB（LSM-Tree存储）                    │
│  - MemTable（内存表）                                    │
│  - WAL（预写日志）                                       │
│  - SST Files（磁盘文件）                                 │
└─────────────────────────────────────────────────────────┘
                          ↑
┌─────────────────────────────────────────────────────────┐
│              Multi-Level Cache（多级缓存）                │
│  - L1: Block Cache（512MB）                             │
│  - L2: Business Cache（ChannelInfo, Permission, ...)   │
│  - L3: MemTable（1GB）                                  │
└─────────────────────────────────────────────────────────┘
                          ↑
┌─────────────────────────────────────────────────────────┐
│           Performance Monitor（性能监控）                 │
│  - 缓存命中率监控                                        │
│  - 性能指标统计                                          │
│  - 资源使用监控                                          │
└─────────────────────────────────────────────────────────┘
```

---

### **B. 数据写入完整流程**

```
1️⃣ 业务层调用
   AppendMessages(channelId, msgs)

2️⃣ 哈希路由
   shardIndex = FNV-1a(channelId) % 16

3️⃣ 获取BatchDB
   batchDB = wk.wkdbs[shardIndex]

4️⃣ 创建Batch
   batch = batchDB.NewBatch()
   batch.Set(key, value)

5️⃣ 提交Batch
   batch.CommitWait()  // 发送到batchChan

6️⃣ 后台Worker聚合
   - 收集100个Batch
   - 合并为1个PebbleBatch

7️⃣ 批量Commit
   pebbleBatch.Commit(pebble.Sync)  // 1次fsync

8️⃣ 通知业务线程
   batch.waitC <- err  // 唤醒等待的协程

9️⃣ 更新缓存
   - 更新ChannelSeqCache（最新序号）
   - 失效相关缓存
```

---

### **C. 数据查询完整流程**

```
1️⃣ 业务层调用
   GetMessages(channelId, startSeq, limit)

2️⃣ 查询缓存（L2）
   cached := channelSeqCache.Get(channelId)
   if cached != nil && valid {
       return cached  // 缓存命中 ✅
   }

3️⃣ 哈希路由
   shardIndex = FNV-1a(channelId) % 16

4️⃣ 查询PebbleDB
   db = wk.dbs[shardIndex]

5️⃣ 查询MemTable（L3）
   result := db.Get(key)
   if found {
       return result  // MemTable命中 ✅
   }

6️⃣ 查询Block Cache（L1）
   if blockCache.Contains(blockId) {
       return blockCache.Get(blockId)  // 块缓存命中 ✅
   }

7️⃣ 查询磁盘（L4）
   - 使用Bloom Filter过滤
   - 二分查找SST文件
   - 读取数据块

8️⃣ 更新缓存
   - 写入Block Cache
   - 写入业务缓存

9️⃣ 返回结果
   return messages
```

---

## 6️⃣ 总结

### **核心要点**

1. **Sharding分片设计**：
   - 默认16个分片，均匀分布负载
   - FNV-1a哈希路由，O(1)定位
   - 分片隔离：独立MemTable、WAL、Compaction
   - 性能提升：单分片5万QPS → 16分片80万+QPS

2. **BatchDB批量写入**：
   - 聚合最多100个Batch → 1次Commit
   - 减少fsync次数：10万次 → 1000次
   - 性能提升：20倍吞吐量
   - 延迟优化：200ms → 10ms（P99）

3. **多级缓存架构**：
   - L1: PebbleDB Block Cache（512MB）
   - L2: 业务缓存（ChannelInfo、Permission等）
   - L3: MemTable（1GB）
   - 命中率：85%+，查询延迟降低10倍

4. **性能监控**：
   - 缓存命中率、QPS、延迟监控
   - 资源使用统计（内存、磁盘、写入放大）
   - 实时报表，支持调优

5. **整体性能**：
   - 写入：80万+ QPS
   - 查询：10万+ QPS
   - 延迟P99：<10ms
   - 成本：降低80%

---

### **下一节预告**

**7.3 数据模型**
- 消息数据模型（Message）
- 频道数据模型（Channel）
- 会话数据模型（Conversation）
- 订阅关系模型（Subscriber）

---

> **🔗 相关代码**：
> - WuKongDB结构：`pkg/wkdb/wukongdb.go:24-49`
> - 分片路由：`pkg/wkdb/shard.go`
> - BatchDB实现：`pkg/wkdb/wukongdb.go:365-490`
> - 缓存管理：`pkg/wkdb/cache_manager.go:13`
> - 性能监控：`pkg/wkdb/performance_monitor.go:38`
