# 7.3 数据模型

> **本节目标**：深入理解WuKongDB的四大核心数据模型：消息、频道、会话、订阅关系，掌握IM系统的数据结构设计

---

## 📋 目录
1. [消息数据模型](#消息数据模型)
2. [频道数据模型](#频道数据模型)
3. [会话数据模型](#会话数据模型)
4. [订阅关系模型](#订阅关系模型)
5. [设备与用户模型](#设备与用户模型)

---

## 1️⃣ 消息数据模型

### **A. Message 结构**

**核心定义**：
```go
// pkg/wkdb/model.go:22-26
type Message struct {
    wkproto.RecvPacket  // 继承RecvPacket（消息包）
    Term    uint64      // Raft任期号
    version uint8       // 数据协议版本
}
```

**RecvPacket 字段**（继承自wkproto）：
```go
type RecvPacket struct {
    // 基础字段
    Setting       uint8   // 设置标记
    MessageID     int64   // 消息全局唯一ID（雪花算法）
    MessageSeq    uint32  // 消息序号（频道内递增）
    ClientMsgNo   string  // 客户端消息编号（去重用）
    StreamNo      string  // 流式消息编号
    StreamSeq     uint32  // 流式消息序号
    StreamFlag    uint8   // 流式消息标记

    // 频道信息
    ChannelID   string  // 频道ID
    ChannelType uint8   // 频道类型（1=个人,2=群聊）

    // 消息内容
    FromUID     string  // 发送者UID
    Payload     []byte  // 消息内容（加密后的）

    // 时间戳
    Timestamp   int32   // 消息时间戳（秒）

    // 扩展字段
    Expire      uint32  // 过期时间（秒）
    Topic       string  // 主题
    MsgKey      string  // 消息密钥（端到端加密）

    // 消息扩展
    MessageExtra MessageExtra  // 扩展字段
}
```

---

### **B. 消息序列化**

**Marshal（编码）**：
```go
// pkg/wkdb/model.go:83-101
func (m *Message) Marshal() ([]byte, error) {
    // 1. 编码RecvPacket（wkproto协议）
    data, err := proto.EncodeFrame(&m.RecvPacket, wkproto.LatestVersion)

    // 2. 构建完整消息格式
    fixVersion := uint8(100)  // 版本标识
    enc := wkproto.NewEncoder()

    enc.WriteUint8(wkproto.LatestVersion + fixVersion)  // 版本号
    enc.WriteUint8(m.version)                            // 数据版本
    enc.WriteUint32(uint32(len(data)))                   // RecvPacket长度
    enc.WriteBytes(data)                                 // RecvPacket数据
    enc.WriteUint64(m.Term)                              // Raft Term

    return enc.Bytes(), nil
}

存储格式：
┌──────────────────────────────────────────┐
│ Version(1) │ DataVer(1) │ Len(4) │ ...   │
│ 版本号     │ 数据版本    │ 长度   │ 数据  │
├──────────────────────────────────────────┤
│ RecvPacket Data (变长)                    │
├──────────────────────────────────────────┤
│ Term(8)                                   │
└──────────────────────────────────────────┘
```

---

### **C. 消息存储示例**

**存储Key**：
```
消息Key格式：
channel:{channelId}:{channelType}:msg:{messageSeq}

示例：
频道：channel_001（群聊）
消息序号：100
→ Key: channel:channel_001:2:msg:100

优势：
✅ 按频道分组，范围查询高效
✅ 按序号排序，查询最新消息快
✅ Key有序，LSM-Tree友好
```

**查询示例**：
```go
// 查询最新100条消息
func GetLastMessages(channelId string, channelType uint8, limit int) []Message {
    startKey := fmt.Sprintf("channel:%s:%d:msg:%d", channelId, channelType, math.MaxUint32)
    endKey   := fmt.Sprintf("channel:%s:%d:msg:%d", channelId, channelType, 0)

    // 反向迭代（从大到小）
    iter := db.NewIter(&pebble.IterOptions{
        LowerBound: []byte(endKey),
        UpperBound: []byte(startKey),
    })

    messages := make([]Message, 0, limit)
    for iter.Last(); iter.Valid() && len(messages) < limit; iter.Prev() {
        var msg Message
        msg.Unmarshal(iter.Value())
        messages = append(messages, msg)
    }

    return messages
}
```

---

### **D. 消息ID生成**

**雪花算法（Snowflake）**：
```
MessageID（64位）：
┌────────────────────────────────────────────────────┐
│ Timestamp(41) │ NodeID(10) │ Sequence(12) │ 1bit  │
│ 时间戳41位    │ 节点10位   │ 序列号12位   │ 符号位│
└────────────────────────────────────────────────────┘

示例：
时间戳：2025-01-04 12:00:00 → 1735977600000
节点ID：5
序列号：123
→ MessageID: 123456789012345678

特点：
✅ 全局唯一（分布式环境）
✅ 时间有序（可按时间范围查询）
✅ 高性能（本地生成，无网络开销）
```

**生成代码**：
```go
// pkg/wkdb/wukongdb.go:51-55
prmaryKeyGen, err := snowflake.NewNode(int64(opts.NodeId))

// 生成消息ID
messageId := wk.prmaryKeyGen.Generate().Int64()
```

---

## 2️⃣ 频道数据模型

### **A. ChannelInfo 结构**

```go
// pkg/wkdb/model.go:147-174
type ChannelInfo struct {
    Id              uint64     // 主键ID
    ChannelId       string     // 频道ID（业务ID）
    ChannelType     uint8      // 频道类型

    // 频道配置
    Ban             bool       // 是否封禁
    Disband         bool       // 是否解散
    Large           bool       // 是否大群（>500人）

    // 消息序号
    MessageSeq      uint32     // 当前最大消息序号

    // 订阅关系
    SubscriberCount int        // 订阅者数量
    AllowlistCount  int        // 白名单数量
    DenylistCount   int        // 黑名单数量

    // 时间戳
    LastMsgTime     int64      // 最后一条消息时间
    CreatedAt       *time.Time // 创建时间
    UpdatedAt       *time.Time // 更新时间

    // 版本控制
    Version         uint64     // 版本号（缓存失效用）
}
```

---

### **B. 频道类型**

```go
频道类型定义：
const (
    ChannelTypePerson        = 1  // 个人频道（1v1）
    ChannelTypeGroup         = 2  // 群聊
    ChannelTypeCommunity     = 3  // 社区/频道
    ChannelTypeCustomerService = 4 // 客服
    ChannelTypeInfo          = 5  // 系统消息
)

示例：
1. 个人频道：user001 与 user002 聊天
   → ChannelId: "user002"（对端ID）
   → ChannelType: 1

2. 群聊：群ID为 group_123
   → ChannelId: "group_123"
   → ChannelType: 2

3. 社区频道：频道ID为 channel_456
   → ChannelId: "channel_456"
   → ChannelType: 3
```

---

### **C. 频道配置存储**

**存储Key设计**：
```
频道信息Key：
channel_info:{primaryKey}

索引Key：
channel_info_index:{channelId}:{channelType} → primaryKey

示例：
频道：group_123（群聊）
PrimaryKey：987654321

主数据：
Key:   channel_info:987654321
Value: {ChannelInfo对象序列化}

索引：
Key:   channel_info_index:group_123:2
Value: 987654321（PrimaryKey）

查询流程：
1. 通过索引获取PrimaryKey
2. 通过PrimaryKey获取完整ChannelInfo
```

---

### **D. 频道操作**

**新增频道**：
```go
// pkg/wkdb/channel.go:14-59
func (wk *wukongDB) AddChannel(channelInfo ChannelInfo) (uint64, error) {
    // 1. 生成主键
    primaryKey, err := wk.getChannelPrimaryKey(channelInfo.ChannelId, channelInfo.ChannelType)

    // 2. 创建Batch
    w := wk.channelDb(channelInfo.ChannelId, channelInfo.ChannelType).NewBatch()
    defer w.Close()

    // 3. 写入频道信息
    if err := wk.writeChannelInfo(primaryKey, channelInfo, w); err != nil {
        return 0, err
    }

    // 4. 提交
    err = w.Commit(wk.sync)

    // 5. 更新缓存
    channelInfo.Id = primaryKey
    wk.channelInfoCache.SetChannelInfo(channelInfo)

    return primaryKey, nil
}
```

---

**更新频道**：
```go
// pkg/wkdb/channel.go:61-116
func (wk *wukongDB) UpdateChannel(channelInfo ChannelInfo) error {
    // 1. 获取主键
    primaryKey, err := wk.getChannelPrimaryKey(channelInfo.ChannelId, channelInfo.ChannelType)

    // 2. 获取旧数据
    oldChannelInfo, err := wk.GetChannel(channelInfo.ChannelId, channelInfo.ChannelType)

    // 3. 删除旧索引
    if !IsEmptyChannelInfo(oldChannelInfo) {
        if err := wk.deleteChannelInfoBaseIndex(oldChannelInfo, w); err != nil {
            return err
        }
    }

    // 4. 写入新数据和索引
    if err := wk.writeChannelInfo(primaryKey, newChannelInfo, w); err != nil {
        return err
    }

    // 5. 提交
    err = w.Commit(wk.sync)

    // 6. 更新缓存
    wk.channelInfoCache.SetChannelInfo(newChannelInfo)

    return nil
}
```

---

## 3️⃣ 会话数据模型

### **A. Conversation 结构**

```go
// pkg/wkdb/model.go:322
type Conversation struct {
    Id            uint64     // 主键ID
    Uid           string     // 用户ID
    ChannelId     string     // 频道ID
    ChannelType   uint8      // 频道类型

    // 会话状态
    Type          int        // 会话类型
    UnreadCount   int        // 未读数

    // 消息信息
    LastMsgSeq      uint64   // 最后一条消息序号
    LastClientMsgNo string   // 最后一条客户端消息号
    LastMsgTime     int64    // 最后一条消息时间

    // 已读位置
    ReadToMsgSeq  uint64     // 已读到的消息序号

    // 时间戳
    Timestamp     int64      // 会话时间戳（用于排序）
    CreatedAt     *time.Time // 创建时间
    UpdatedAt     *time.Time // 更新时间

    // 版本控制
    Version       uint64     // 版本号
}
```

---

### **B. 会话列表存储**

**存储Key设计**：
```
会话数据Key：
conversation:{uid}:{primaryKey}

会话索引Key（按时间排序）：
conversation_index:{uid}:{timestamp}:{channelId}:{channelType} → primaryKey

示例：
用户：user001
频道：group_123（群聊）
时间戳：1735977600
PrimaryKey：123456789

主数据：
Key:   conversation:user001:123456789
Value: {Conversation对象}

索引：
Key:   conversation_index:user001:1735977600:group_123:2
Value: 123456789

查询最近会话：
StartKey: conversation_index:user001:999999999999:
EndKey:   conversation_index:user001:0:
反向迭代 → 获取最新的会话
```

---

### **C. 会话操作**

**新增/更新会话**：
```go
// pkg/wkdb/conversation.go:14-77
func (wk *wukongDB) AddOrUpdateConversations(conversations []Conversation) error {
    userBatchMap := make(map[uint32]*Batch)

    for _, conversation := range conversations {
        // 1. 按用户分片
        shardId := wk.shardId(conversation.Uid)
        batch := userBatchMap[shardId]
        if batch == nil {
            batch = wk.shardBatchDBById(shardId).NewBatch()
            userBatchMap[shardId] = batch
        }

        // 2. 获取旧会话
        oldConversation, err := wk.GetConversation(conversation.Uid, conversation.ChannelId, conversation.ChannelType)

        // 3. 如果会话存在，删除旧索引
        if !IsEmptyConversation(oldConversation) {
            err = wk.deleteConversationIndex(oldConversation, batch)
            conversation.Id = oldConversation.Id
        }

        // 4. 写入新会话
        if err := wk.writeConversation(conversation, batch); err != nil {
            return err
        }
    }

    // 5. 批量提交
    err := Commits(batchs)

    // 6. 智能更新缓存
    wk.conversationCache.UpdateConversationsInCache(conversations)

    return nil
}
```

---

### **D. 会话查询**

**查询最近会话列表**：
```go
func GetLastConversations(uid string, limit int) []Conversation {
    // 1. 检查缓存
    cached, ok := wk.conversationCache.Get(uid)
    if ok {
        return cached[:limit]
    }

    // 2. 从DB查询
    startKey := fmt.Sprintf("conversation_index:%s:%d:", uid, math.MaxInt64)
    endKey   := fmt.Sprintf("conversation_index:%s:%d:", uid, 0)

    iter := db.NewIter(&pebble.IterOptions{
        LowerBound: []byte(endKey),
        UpperBound: []byte(startKey),
    })

    conversations := make([]Conversation, 0, limit)
    for iter.Last(); iter.Valid() && len(conversations) < limit; iter.Prev() {
        primaryKey := binary.BigEndian.Uint64(iter.Value())
        conv := wk.getConversationByPrimaryKey(uid, primaryKey)
        conversations = append(conversations, conv)
    }

    // 3. 写入缓存
    wk.conversationCache.Set(uid, conversations)

    return conversations
}
```

---

## 4️⃣ 订阅关系模型

### **A. Subscriber 结构**

```go
type Subscriber struct {
    Id            uint64     // 主键ID
    Uid           string     // 订阅者UID
    ChannelId     string     // 频道ID
    ChannelType   uint8      // 频道类型

    CreatedAt     *time.Time // 创建时间
    UpdatedAt     *time.Time // 更新时间
}
```

---

### **B. 订阅关系存储**

**存储Key设计**：
```
订阅者列表：
subscriber:{channelId}:{channelType}:{uid}

示例：
频道：group_123（群聊）
订阅者：user001, user002, user003

Keys:
- subscriber:group_123:2:user001 → {Subscriber对象}
- subscriber:group_123:2:user002 → {Subscriber对象}
- subscriber:group_123:2:user003 → {Subscriber对象}

查询订阅者：
StartKey: subscriber:group_123:2:
EndKey:   subscriber:group_123:2:~
范围查询 → 获取所有订阅者
```

---

### **C. 黑白名单**

**黑名单（Denylist）**：
```
黑名单Key：
denylist:{channelId}:{channelType}:{uid}

示例：
频道：group_123
拉黑用户：user999

Key: denylist:group_123:2:user999 → {Denylist对象}

权限检查：
if db.Exists("denylist:group_123:2:user999") {
    return "用户已被拉黑，无法发送消息"
}
```

---

**白名单（Allowlist）**：
```
白名单Key：
allowlist:{channelId}:{channelType}:{uid}

示例：
频道：group_123（仅白名单可发言）
白名单用户：user001, user002

Keys:
- allowlist:group_123:2:user001
- allowlist:group_123:2:user002

权限检查：
if channel.OnlyAllowlistSend {
    if !db.Exists("allowlist:group_123:2:user001") {
        return "不在白名单，无法发送消息"
    }
}
```

---

## 5️⃣ 设备与用户模型

### **A. Device 结构**

```go
// pkg/wkdb/model.go:109-122
type Device struct {
    Id           uint64     // 主键ID
    Uid          string     // 用户UID
    Token        string     // 设备Token
    DeviceFlag   uint64     // 设备标记
    DeviceLevel  uint8      // 设备等级

    // 连接统计
    ConnCount    uint32     // 连接数量
    SendMsgCount uint64     // 发送消息数量
    RecvMsgCount uint64     // 接收消息数量
    SendMsgBytes uint64     // 发送字节数
    RecvMsgBytes uint64     // 接收字节数

    CreatedAt    *time.Time // 创建时间
    UpdatedAt    *time.Time // 更新时间
}
```

**设备标识（DeviceFlag）**：
```
设备标识用于区分同一用户的多个设备：
├─ Web端：   DeviceFlag = 1
├─ iOS端：   DeviceFlag = 2
├─ Android端：DeviceFlag = 3
├─ PC端：    DeviceFlag = 4
└─ ...

多设备在线：
用户user001同时登录3个设备
→ Devices: [
    {Uid: "user001", DeviceFlag: 1, ...},  // Web
    {Uid: "user001", DeviceFlag: 2, ...},  // iOS
    {Uid: "user001", DeviceFlag: 3, ...},  // Android
]
```

---

### **B. User 结构**

```go
// pkg/wkdb/model.go:130-143
type User struct {
    Id                uint64     // 主键ID
    Uid               string     // 用户UID

    // 设备统计
    DeviceCount       uint32     // 设备总数
    OnlineDeviceCount uint32     // 在线设备数
    ConnCount         uint32     // 连接总数

    // 消息统计
    SendMsgCount      uint64     // 发送消息数
    RecvMsgCount      uint64     // 接收消息数
    SendMsgBytes      uint64     // 发送字节数
    RecvMsgBytes      uint64     // 接收字节数

    // 扩展
    PluginNo          string     // 插件编号
    CreatedAt         *time.Time // 创建时间
    UpdatedAt         *time.Time // 更新时间
}
```

---

### **C. 设备存储**

**存储Key设计**：
```
设备列表：
device:{uid}:{deviceFlag} → {Device对象}

示例：
用户：user001
设备：iOS（DeviceFlag=2）

Key:   device:user001:2
Value: {Device对象}

查询用户所有设备：
StartKey: device:user001:
EndKey:   device:user001:~
范围查询 → 获取所有设备
```

---

## 6️⃣ 数据关系图

```
┌─────────────────────────────────────────────────────┐
│                   数据关系图                         │
└─────────────────────────────────────────────────────┘

            [User]
              │
              │ 1:N
              ↓
          [Device]  ← 用户的多个设备
              │
              │ N:M
              ↓
        [Conversation]  ← 用户的会话列表
              │
              │ N:1
              ↓
         [Channel]  ← 频道信息
              │
              ├─ 1:N → [Message]      ← 频道的消息
              ├─ 1:N → [Subscriber]   ← 频道的订阅者
              ├─ 1:N → [Denylist]     ← 频道的黑名单
              └─ 1:N → [Allowlist]    ← 频道的白名单

示例：
用户user001：
├─ 设备：[Web, iOS, Android]
├─ 会话：[
│    {频道: group_123, 未读: 5},
│    {频道: user002, 未读: 2},
│  ]
└─ ...

频道group_123：
├─ 消息：[msg1, msg2, msg3, ...]
├─ 订阅者：[user001, user002, user003, ...]
├─ 黑名单：[user999]
└─ 白名单：[user001, user002]
```

---

## 7️⃣ 总结

### **核心要点**

1. **消息模型（Message）**：
   - 继承RecvPacket，包含完整消息信息
   - 雪花算法生成全局唯一MessageID
   - 按频道+序号存储，支持高效范围查询
   - 序列化支持版本兼容

2. **频道模型（ChannelInfo）**：
   - 支持5种频道类型（个人、群聊、社区、客服、系统）
   - 主键+索引双存储，查询高效
   - 版本控制，支持缓存失效
   - 记录订阅者数、黑白名单数

3. **会话模型（Conversation）**：
   - 用户维度的会话列表
   - 按时间戳排序，查询最近会话快
   - 记录未读数、已读位置
   - 智能缓存更新

4. **订阅关系（Subscriber）**：
   - 频道-用户多对多关系
   - 黑名单控制（禁止发言）
   - 白名单控制（仅允许发言）
   - 范围查询获取所有订阅者

5. **设备与用户（Device/User）**：
   - 多设备在线支持（DeviceFlag区分）
   - 统计信息（消息数、字节数）
   - 设备级别控制

---

### **下一节预告**

**7.4 索引设计**
- 消息ID索引（全局唯一查询）
- 频道消息索引（范围查询）
- 用户会话索引（时间排序）
- 时间序列优化

---

> **🔗 相关代码**：
> - Message模型：`pkg/wkdb/model.go:22-101`
> - ChannelInfo模型：`pkg/wkdb/model.go:147-174`
> - Conversation模型：`pkg/wkdb/model.go:322`
> - Device模型：`pkg/wkdb/model.go:109-122`
> - 频道操作：`pkg/wkdb/channel.go:14-116`
> - 会话操作：`pkg/wkdb/conversation.go:14-77`
