# 7.4 索引设计

> **本节目标**：深入理解WuKongDB的索引体系设计，掌握消息ID索引、频道消息索引、用户会话索引以及时间序列优化的核心技术

---

## 📋 目录
1. [索引体系概览](#索引体系概览)
2. [消息ID索引](#消息id索引)
3. [频道消息索引](#频道消息索引)
4. [用户会话索引](#用户会话索引)
5. [时间序列优化](#时间序列优化)
6. [索引性能分析](#索引性能分析)

---

## 1️⃣ 索引体系概览

### **A. 索引类型**

**WuKongDB索引分类**：
```
索引类型：
├─ 主键索引（Primary Key）
│  └─ 唯一标识，直接定位数据
│
├─ 唯一索引（Unique Index）
│  └─ 字段唯一，返回PrimaryKey
│
├─ 二级索引（Secondary Index）
│  └─ 非唯一，支持范围查询
│
└─ 组合索引（Composite Index）
   └─ 多字段组合，支持复杂查询
```

---

### **B. Key设计原则**

**表结构（通用格式）**：
```
// pkg/wkdb/key/table.go:3-7
Key结构：
┌─────────────────────────────────────────────────┐
│ TableID │ DataType │ PrimaryKey │ ColumnKey     │
│ 2 byte  │ 1 byte   │ 8 byte     │ 2 byte        │
└─────────────────────────────────────────────────┘

DataType类型：
├─ 0x01: 表数据（Table）
├─ 0x02: 唯一索引（Index）
├─ 0x03: 二级索引（SecondIndex）
└─ 0x04: 其他数据（Other）
```

**设计原则**：
```
1️⃣ 前缀一致：同类数据Key前缀相同，支持范围查询
2️⃣ 有序存储：Key按字典序排序，LSM-Tree友好
3️⃣ 固定长度：核心字段固定长度，查询高效
4️⃣ 哈希优化：长字符串用Hash，减少Key长度
```

---

## 2️⃣ 消息 ID 索引

### **A. 索引结构**

**消息表结构**：
```go
// pkg/wkdb/key/table.go:17-22
消息Key格式：
┌──────────────────────────────────────────────────────────┐
│ TableID │ DataType │ ChannelHash │ MessageSeq │ ColumnKey│
│ 2 byte  │ 1 byte   │ 8 byte      │ 8 byte     │ 2 byte   │
└──────────────────────────────────────────────────────────┘

示例：
TableMessage.Id    = [0x01, 0x01]  // 消息表ID
dataTypeTable      = 0x01          // 表数据
ChannelHash        = Hash("channel_001:2")  // 频道哈希
MessageSeq         = 100                     // 消息序号
ColumnKey          = [0x01, 0x04]           // MessageId字段
```

---

### **B. MessageID 唯一索引**

**索引Key设计**：
```go
// pkg/wkdb/key/table.go:44-46
MessageID索引：
┌────────────────────────────────────────────┐
│ TableID │ DataType │ IndexName │ MsgIdHash│
│ 2 byte  │ 1 byte   │ 2 byte    │ 8 byte   │
└────────────────────────────────────────────┘

IndexSize = 2 + 1 + 2 + 8 = 13 bytes

示例：
TableID     = [0x01, 0x01]         // 消息表
DataType    = 0x02                 // 唯一索引
IndexName   = [0x01, 0x01]         // MessageId索引
MsgIdHash   = Hash(MessageId)      // 消息ID哈希

Key:   [0x01, 0x01, 0x02, 0x01, 0x01, <8字节Hash>]
Value: PrimaryKey（8字节）
```

---

### **C. 查询流程**

**通过MessageID查询消息**：
```go
func GetMessageByMessageID(messageId int64) (Message, error) {
    // 1. 构造索引Key
    msgIdHash := Hash(messageId)
    indexKey := NewMessageIndexKey(TableMessage.Index.MessageId, msgIdHash)

    // 2. 查询索引，获取PrimaryKey
    primaryKeyBytes, err := db.Get(indexKey)
    if err != nil {
        return nil, err
    }
    primaryKey := binary.BigEndian.Uint64(primaryKeyBytes)

    // 3. 构造数据Key
    channelHash, messageSeq := parsePrimaryKey(primaryKey)
    dataKey := NewMessageTableKey(channelHash, messageSeq, TableMessage.Column.Payload)

    // 4. 查询数据
    data, err := db.Get(dataKey)
    if err != nil {
        return nil, err
    }

    // 5. 反序列化
    var msg Message
    msg.Unmarshal(data)
    return msg, nil
}

查询复杂度：
- 索引查询：O(1)（Hash定位）
- 数据查询：O(1)（PrimaryKey直接定位）
- 总复杂度：O(1) ✅
```

---

### **D. 二级索引**

**ClientMsgNo索引（客户端消息号）**：
```go
// pkg/wkdb/key/table.go:47-52
ClientMsgNo索引（用于去重）：
┌──────────────────────────────────────────────────────────────┐
│ TableID │ DataType │ IndexName │ ClientMsgNoHash │ PrimaryKey │
│ 2 byte  │ 1 byte   │ 2 byte    │ 8 byte          │ 8 byte     │
└──────────────────────────────────────────────────────────────┘

SecondIndexSize = 2 + 1 + 2 + 8 + 8 = 21 bytes

为什么需要PrimaryKey？
- ClientMsgNo可能重复（不同频道）
- PrimaryKey保证唯一性
- 支持范围查询

示例：
客户端发送消息：ClientMsgNo="client_msg_123"

索引Key：
[0x01, 0x01, 0x03, 0x01, 0x06, Hash("client_msg_123"), PrimaryKey]

查询：检查消息是否已存在（去重）
db.Get(indexKey) → 存在 → 返回"消息已发送"
```

---

**Timestamp索引（时间戳）**：
```go
Timestamp索引（按时间范围查询）：
┌──────────────────────────────────────────────────────────────┐
│ TableID │ DataType │ IndexName │ Timestamp │ PrimaryKey       │
│ 2 byte  │ 1 byte   │ 2 byte    │ 8 byte    │ 8 byte           │
└──────────────────────────────────────────────────────────────┘

示例：
查询某频道昨天的所有消息

startTime = 昨天00:00:00 → 1735891200
endTime   = 昨天23:59:59 → 1735977599

startKey = [TableID, 0x03, TimestampIndex, 1735891200, 0]
endKey   = [TableID, 0x03, TimestampIndex, 1735977599, MaxUint64]

iter := db.NewIter(&pebble.IterOptions{
    LowerBound: startKey,
    UpperBound: endKey,
})

for iter.First(); iter.Valid(); iter.Next() {
    _, primaryKey := parseSecondIndexKey(iter.Key())
    msg := getMessageByPrimaryKey(primaryKey)
    messages = append(messages, msg)
}

复杂度：O(n)（n为时间范围内的消息数）
```

---

## 3️⃣ 频道消息索引

### **A. 频道消息Key设计**

**主数据Key**：
```
频道消息Key：
┌──────────────────────────────────────────────────────────┐
│ TableID │ DataType │ ChannelHash │ MessageSeq │ ColumnKey│
│ 2 byte  │ 1 byte   │ 8 byte      │ 8 byte     │ 2 byte   │
└──────────────────────────────────────────────────────────┘

ChannelHash计算：
channelKey := fmt.Sprintf("%s:%d", channelId, channelType)
channelHash := fnv.New64a()
channelHash.Write([]byte(channelKey))
hash := channelHash.Sum64()

示例：
频道：channel_001（群聊）
ChannelKey: "channel_001:2"
ChannelHash: 0x1234567890ABCDEF

消息序号：100

Key: [0x01, 0x01, 0x01, 0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x01, 0x04]
```

---

### **B. 范围查询优化**

**查询最新N条消息**：
```go
func GetLastMessages(channelId string, channelType uint8, limit int) []Message {
    // 1. 计算ChannelHash
    channelHash := calcChannelHash(channelId, channelType)

    // 2. 构造范围Key
    startSeq := uint64(math.MaxUint64)  // 最大值
    endSeq   := uint64(0)                // 最小值

    startKey := NewMessageTableKey(channelHash, startSeq, TableMessage.Column.Payload)
    endKey   := NewMessageTableKey(channelHash, endSeq, TableMessage.Column.Payload)

    // 3. 反向迭代（从新到旧）
    iter := db.NewIter(&pebble.IterOptions{
        LowerBound: endKey,
        UpperBound: startKey,
    })

    messages := make([]Message, 0, limit)
    for iter.Last(); iter.Valid() && len(messages) < limit; iter.Prev() {
        var msg Message
        msg.Unmarshal(iter.Value())
        messages = append(messages, msg)
    }

    return messages
}

性能分析：
- 迭代器定位：O(log n)（LSM-Tree查找）
- 迭代N条：O(N)
- 总复杂度：O(log n + N)
- 实际延迟：<5ms（热数据在MemTable）
```

---

### **C. Bloom Filter 加速**

**Bloom Filter原理**：
```
Bloom Filter（布隆过滤器）：
- 作用：快速判断Key是否存在
- 特点：可能误判"存在"，但绝不误判"不存在"
- 存储：位图（Bitmap）

示例：
查询消息：channel_001:2:msg:999999

1. 检查Bloom Filter
   if !bloomFilter.MayContain(key) {
       return ErrNotFound  // 快速返回（99%准确）
   }

2. 查询SST文件
   data, err := sst.Get(key)

性能提升：
- 避免无效的磁盘I/O
- 减少90%+的查询延迟
```

**PebbleDB的Bloom Filter配置**：
```go
opts := &pebble.Options{
    Levels: []pebble.LevelOptions{
        {
            FilterPolicy: bloom.FilterPolicy(10),  // 10位/Key
            // 误判率：(1/2)^10 ≈ 0.1%
        },
    },
}
```

---

## 4️⃣ 用户会话索引

### **A. 会话索引结构**

**会话数据Key**：
```
会话Key：
conversation:{uid}:{primaryKey}

会话索引Key（按时间排序）：
┌──────────────────────────────────────────────────────────────────┐
│ TableID │ DataType │ UidHash │ Timestamp │ ChannelHash │ PrimaryKey│
│ 2 byte  │ 1 byte   │ 8 byte  │ 8 byte    │ 8 byte      │ 8 byte    │
└──────────────────────────────────────────────────────────────────┘

为什么包含ChannelHash？
- 同一用户可能同时更新多个会话（同一时间戳）
- ChannelHash保证唯一性

示例：
用户：user001
时间戳：1735977600（2025-01-04 12:00:00）
频道：group_123（群聊）

UidHash     = Hash("user001")     = 0xAABBCCDDEEFF0011
Timestamp   = 1735977600           = 0x00000000677A1E80
ChannelHash = Hash("group_123:2") = 0x1122334455667788
PrimaryKey  = 987654321            = 0x000000003ADE68B1

索引Key：
[TableID, 0x03, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00, 0x11,
 0x00, 0x00, 0x00, 0x00, 0x67, 0x7A, 0x1E, 0x80,
 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,
 0x00, 0x00, 0x00, 0x00, 0x3A, 0xDE, 0x68, 0xB1]
```

---

### **B. 会话列表查询**

**查询最近会话**：
```go
func GetLastConversations(uid string, limit int) []Conversation {
    // 1. 构造范围Key
    uidHash := Hash(uid)
    startTime := uint64(math.MaxUint64)  // 最新时间
    endTime   := uint64(0)                // 最早时间

    startKey := NewConversationIndexKey(uidHash, startTime, 0, 0)
    endKey   := NewConversationIndexKey(uidHash, endTime, 0, 0)

    // 2. 反向迭代
    iter := db.NewIter(&pebble.IterOptions{
        LowerBound: endKey,
        UpperBound: startKey,
    })

    conversations := make([]Conversation, 0, limit)
    for iter.Last(); iter.Valid() && len(conversations) < limit; iter.Prev() {
        // 解析索引Key
        _, _, _, primaryKey := parseConversationIndexKey(iter.Key())

        // 获取会话数据
        conv := getConversationByPrimaryKey(uid, primaryKey)
        conversations = append(conversations, conv)
    }

    return conversations
}

性能：
- 定位：O(log n)
- 迭代：O(limit)
- 总计：O(log n + limit)
- 延迟：<3ms（热数据）
```

---

### **C. 会话更新优化**

**智能缓存更新**：
```go
// pkg/wkdb/conversation.go:73
func (wk *wukongDB) AddOrUpdateConversations(conversations []Conversation) error {
    // 1. 批量写入DB
    err := Commits(batchs)

    // 2. 智能更新缓存
    wk.conversationCache.UpdateConversationsInCache(conversations)

    return nil
}

// 智能更新策略
func (cc *ConversationCache) UpdateConversationsInCache(newConvs []Conversation) {
    for _, newConv := range newConvs {
        cached, ok := cc.cache.Get(newConv.Uid)
        if !ok {
            continue  // 缓存未命中，跳过
        }

        // 查找并更新
        for i, oldConv := range cached {
            if oldConv.ChannelId == newConv.ChannelId &&
               oldConv.ChannelType == newConv.ChannelType {
                cached[i] = newConv  // 更新
                break
            }
        }

        // 重新排序（按时间戳）
        sort.Slice(cached, func(i, j int) bool {
            return cached[i].Timestamp > cached[j].Timestamp
        })

        // 更新缓存
        cc.cache.Set(newConv.Uid, cached)
    }
}

优势：
✅ 只更新变化的会话
✅ 避免全量刷新缓存
✅ 减少DB查询
```

---

## 5️⃣ 时间序列优化

### **A. 时间倒序存储**

**为什么倒序？**
```
IM场景特点：
- 用户主要查询最新消息
- 历史消息访问少

传统正序存储：
MessageSeq: 1, 2, 3, ..., 10000
查询最新100条：从10000倒序扫描 → 慢

倒序存储（WuKongDB）：
使用 (MaxUint64 - Timestamp) 作为Key的一部分

示例：
Timestamp = 1735977600
Key中的时间戳 = MaxUint64 - 1735977600 = 18446744071973574015

效果：
- 最新的消息Key最小
- 范围查询从前往后扫描 → 快 ✅
```

---

### **B. 分区压缩**

**按时间分区**：
```
历史消息压缩策略：
┌─────────────────────────────────────────┐
│ 最近1天：无压缩（热数据，查询频繁）      │
├─────────────────────────────────────────┤
│ 1-7天：  Snappy压缩（温数据）            │
├─────────────────────────────────────────┤
│ 7-30天： Zstd压缩（冷数据）              │
├─────────────────────────────────────────┤
│ >30天：  高压缩比Zstd（归档数据）        │
└─────────────────────────────────────────┘

PebbleDB配置：
opts := &pebble.Options{
    Levels: []pebble.LevelOptions{
        {Compression: pebble.NoCompression},       // L0-L1：不压缩
        {Compression: pebble.SnappyCompression},  // L2-L3：Snappy
        {Compression: pebble.ZstdCompression},    // L4+：Zstd
    },
}

效果：
- 热数据快速访问（无解压开销）
- 冷数据高压缩比（节省存储）
- 压缩比：2-3倍
```

---

### **C. TTL过期删除**

**消息过期机制**：
```go
type Message struct {
    Expire uint32  // 过期时间（秒）
    ...
}

过期删除流程：
1️⃣ 写入消息时记录Expire
2️⃣ 后台Compaction时检查过期
3️⃣ 删除过期消息

Compaction Filter（PebbleDB）：
filter := func(key, value []byte) (bool, error) {
    msg := unmarshalMessage(value)

    if msg.Expire > 0 {
        expireTime := msg.Timestamp + msg.Expire
        if time.Now().Unix() > expireTime {
            return true, nil  // 删除
        }
    }

    return false, nil  // 保留
}

优势：
✅ 自动清理过期数据
✅ 节省存储空间
✅ 无需定时任务
```

---

## 6️⃣ 索引性能分析

### **A. 查询性能对比**

| 查询类型 | 传统B+Tree | LSM-Tree+索引 | 性能提升 |
|---------|-----------|--------------|---------|
| **MessageID精确查询** | 10-20ms | 1-3ms | 5倍 |
| **频道最新100条** | 20-50ms | 2-5ms | 8倍 |
| **用户会话列表** | 30-100ms | 3-10ms | 8倍 |
| **时间范围查询** | 50-200ms | 10-30ms | 6倍 |

---

### **B. 索引开销**

**存储开销**：
```
假设：1亿条消息

主数据：
- 每条消息：1KB
- 总计：100GB

索引：
- MessageID索引：13 bytes × 1亿 = 1.3GB
- ClientMsgNo索引：21 bytes × 1亿 = 2.1GB
- Timestamp索引：21 bytes × 1亿 = 2.1GB
- 总计：5.5GB（主数据的5.5%）

结论：
- 索引开销小（<6%）
- 查询性能提升巨大（5-10倍）
- 性价比高 ✅
```

---

### **C. 写入性能**

**索引写入开销**：
```
写入1条消息：
├─ 主数据写入：1次
├─ MessageID索引：1次
├─ ClientMsgNo索引：1次
├─ Timestamp索引：1次
└─ 总计：4次写入

批量写入优化（BatchDB）：
- 聚合100条消息
- 1次Commit（4 × 100 = 400次写入）
- fsync开销：平摊到100条消息
- 写入延迟：<10ms

写入放大：
- LSM-Tree：2-3倍
- 索引：1.5倍
- 总计：3-4.5倍
- 仍优于B+Tree（5-10倍）
```

---

## 7️⃣ 总结

### **核心要点**

1. **索引体系**：
   - 主键索引：直接定位数据
   - 唯一索引：MessageID → PrimaryKey
   - 二级索引：ClientMsgNo、Timestamp
   - 组合索引：支持复杂查询

2. **Key设计原则**：
   - 前缀一致，支持范围查询
   - 固定长度，查询高效
   - 哈希优化，减少Key长度
   - LSM-Tree友好，有序存储

3. **消息ID索引**：
   - MessageID → PrimaryKey（O(1)查询）
   - 支持全局唯一查询
   - Bloom Filter加速（减少90%无效I/O）

4. **频道消息索引**：
   - ChannelHash + MessageSeq（范围查询）
   - 查询最新N条：O(log n + N)
   - 倒序存储，查询最新消息快

5. **会话索引**：
   - UidHash + Timestamp + ChannelHash
   - 按时间倒序排列
   - 智能缓存更新，减少DB查询

6. **时间序列优化**：
   - 倒序存储（最新数据Key最小）
   - 分区压缩（冷热数据分离）
   - TTL过期删除（自动清理）

7. **性能优化**：
   - 查询性能：5-10倍提升
   - 索引开销：<6%
   - 写入放大：3-4.5倍（优于B+Tree）

---

### **最佳实践**

**1. 索引选择**：
```
✅ 频繁精确查询 → 唯一索引（MessageID）
✅ 范围查询 → 二级索引（Timestamp）
✅ 去重查询 → 二级索引（ClientMsgNo）
✅ 复杂查询 → 组合索引（UidHash + Timestamp）
```

**2. 性能优化**：
```
✅ 批量写入（BatchDB）
✅ 缓存热数据（80%命中率）
✅ Bloom Filter过滤
✅ 分区压缩（冷热分离）
```

**3. 存储优化**：
```
✅ 控制索引数量（<5个）
✅ 使用Hash减少Key长度
✅ 过期数据自动清理
✅ 压缩冷数据（2-3倍压缩比）
```

---

> **🔗 相关代码**：
> - Key设计：`pkg/wkdb/key/table.go:1-100`
> - 消息索引：`pkg/wkdb/key/table.go:23-102`
> - 会话索引：`pkg/wkdb/conversation.go`
> - 索引操作：`pkg/wkdb/channel_cluster_config.go:521-568`
